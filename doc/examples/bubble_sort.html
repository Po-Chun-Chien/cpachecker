<!--
This file is part of CPAchecker,
a tool for configurable software verification:
https://cpachecker.sosy-lab.org

SPDX-FileCopyrightText: 2007-2020 Dirk Beyer <https://www.sosy-lab.org>
SPDX-FileCopyrightText: 2018 Lokesh Nandanwar

SPDX-License-Identifier: Apache-2.0
-->

<!-- Refer to the doc/ReportTemplateStyleGuide.md for Coding and Style Guide. They will let you write better code
with considerably less effort -->

<!DOCTYPE html>
<html ng-app='report'>

<head>
  <meta charset="UTF-8">
<meta name='generator' content='CPAchecker 2.0.1-svn / predicateAnalysis-faultlocalization-maxsat'>
  <title>CPAchecker Report</title>
<style>
/*
 * This file is part of CPAchecker,
 * a tool for configurable software verification:
 * https://cpachecker.sosy-lab.org
 *
 * SPDX-FileCopyrightText: 2007-2020 Dirk Beyer <https://www.sosy-lab.org>
 * SPDX-FileCopyrightText: 2018 Lokesh Nandanwar
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/* Refer to the doc/ReportTemplateStyleGuide.md for Coding and Style Guide. They will let you write better code
with considerably less effort */

html {
	position: relative;
	height: 100%;
	overflow: hidden;
}

body {
	padding-top: 50px;
	height: 100%;
	min-height: 300px;
	min-width: 750px;
	background-color: white;
}

.sections section {
	position: absolute;
}

.sections {
	width: 100%;
	overflow: auto;
	padding: 0;
	height: 100%;
}

.ui-resizable-e {
	cursor: e-resize;
	display: block !important;
	width: 20px;
	right: -10px;
	top: 0;
	bottom: 0;
	background: lightgrey;
}

.header {
	position: absolute;
	top: 0;
	width: 100%;
	min-width: 750px;
	height: 50px;
	background-color: #ffef96;
	border-bottom: solid 4px;
	border-bottom-color: lightgrey;
	padding: 7px;
	padding-top: 5px;
	text-align: center;
	justify-content: center;
}

.nav>li>a:hover {
	background-color: #c0c0c0;
}

.btn {
	cursor: pointer;
}

.disabled-btn {
        color: #c0c0c0;
        border-color: #ffffff !important;
}

.disabled-btn:hover {
        background-color: #ffffff !important;
        color: #c0c0c0 !important;
}

.header img.logo {
	float: left;
	height: 40px;
	margin-left: 10px;
}

.header h1 {
	display: inline;
	font-size: 21px;
	color: #50394c;
}

.header .generated {
	float: right;
	margin-left: 2em;
	font-size: 80%;
}

.popover {
	min-width: 500px;
	max-height: 500px;
	white-space: pre-line !important;
	overflow: auto;
	background-color: #f5fff8;
	border: solid 2px;
	border-color: #00d415;
	font-family: monospace
}

.dropdown-menu a:hover {
	background-color: #71afff !important;
}

.dropdown-menu a {
	cursor: pointer;
}

/* The switch - the box around the slider */

.switch {
	position: relative;
	display: inline-block;
	width: 60px;
	height: 34px;
}

/* Hide default HTML checkbox */

.switch input {
	padding: 10px;
	display: none;
}

/* The slider */

.slider {
	position: absolute;
	cursor: pointer;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background-color: grey;
	-webkit-transition: .4s;
	transition: .4s;
}

.slider:before {
	position: absolute;
	content: "";
	height: 26px;
	width: 26px;
	left: 4px;
	bottom: 4px;
	background-color: white;
	-webkit-transition: .4s;
	transition: .4s;
}

input:checked+.slider {
	background-color: #ffc107;
}

input:focus+.slider {
	box-shadow: 0 0 1px #ffc107;
}

input:checked+.slider:before {
	-webkit-transform: translateX(26px);
	-ms-transform: translateX(26px);
	transform: translateX(26px);
}

/* Rounded sliders */

.slider.round {
	border-radius: 34px;
}

.slider.round:before {
	border-radius: 50%;
}

#errorpath_section {
	width: 25%;
	float: left;
	min-width: 0px;
	height: inherit;
	max-width: 60%;
	background-color: white;
	padding: 5px;
}

#errorpath_section header .input-group {
	margin-top: 5px;
	margin-bottom: 5px;
}

/* -185px for buttons and controllers
   -2px for the border of the change view button
   -2.25rem for the font size and the radius of the change view button */
#errorpath_section .fileContent {
	height: calc(100% - 187px - 2.25rem);
	margin: 5px;
	overflow: auto;
}

#searchOptions label {
	font-weight: normal;
}

#matches {
	display: none;
}

.markedValues {
	background-color: #83d480;
	border-radius: 25px;
	margin-bottom: 2px;
	padding: 2px;
	padding-left: 8px;
	max-width: 270px;
}

.markedDescriptions {
	background-color: #71afff;
	border-radius: 20px;
	padding: 2px;
	padding-left: 8px;
	margin-bottom: 2px;
	max-width: 270px;
}

.markedTableElement {
	border: solid 2px;
	border-color: #00d415;
}

.markedValueElement pre {
	background-color: #83d480 !important;
}

.markedDescElement pre {
	background-color: #71afff !important;
}

.markedValueDescElement pre {
	background: linear-gradient(#83d480, #71afff) !important;
}

#err-table td {
	cursor: pointer;
}

#err-table td.disabled {
	cursor: not-allowed;
	pointer-events: none;
}

#err-table td:hover {
	font-weight: bold;
}

#err-table td:first-child {
	border-radius: 6px;
}

#err-table td pre {
	padding: 0px;
	margin: 0px;
	border: none;
}

#err-table tr td pre.make-pretty {
	background-color: #ffe5d5;
}

#err-table tr.clickedErrPathElement {
	outline: #df80ff solid 2px;
}

.rank {
	text-align: center;
}

.fault-table {
	width: 100%;
	border-collapse: collapse;
}

.fault-table td {
	cursor: pointer;
	padding: 7px;
	border: #000000 2px solid;
}

.fault-table .fault-rank {
	background-color: #28a745;
	text-align: center;
	font-weight: 700;
	width: 10%;
}

.fault-table .fault-score {
	background-color: #ffc107;
	text-align: center;
	width: 10%;
}

.fault-table .fault-details-header {
	background-color: #ff3907aa;
	font-weight: 700;
}

.fault-table .fault-precond-header {
	background-color: #28a745;
	font-weight: 700;
}

.fault-table .fault-lines {
	max-height: 8em;
	overflow: auto;
	border: 1px solid gray;
	border-radius: 3px;
}

.fault-lines {
	padding: 3px;
	list-style: none;
}

.interval-scrollbox {
	width: 100%;
    height: 4rem;
    font-size: 100%;
    overflow: auto;
}

.precondition {
	border: 1px solid gray;
	border-radius: 3px;
	padding: 3px;
}

.value-table {
	border-collapse: collapse;
	width: 100%;
}
  
.value-table th, .value-table td {
	text-align: left;
	padding: 8px;
}

.value-table tr:nth-child(even){background-color: #f2f2f2}
  
.value-table th {
	border: 2px solid black;
	background-color: #4CAF50;
	color: white;
}

ul.fault-lines li {
	display: grid;
	grid-template-columns: minmax(2em, min-content) auto;
	grid-column-gap: 5px;
}

.fault-lines .line-number {
	text-align: right;
}

.fault-lines .line-number::after {
	content: ':';
}

.horizontal-div {
    display: inline;
    margin-left: auto;
	margin-right: auto 
}

#hint-list {
	list-style-type: none;
	counter-reset: elementcounter;
  }
  
#hint-list>li::before {
	position: relative;
	content: "Hint " counter(elementcounter) ": ";
	counter-increment: elementcounter;
	font-weight: 700;
}

#fix-list {
	list-style-type: none;
	counter-reset: elementcounter;
  }

#fix-list>li::before {
	position: relative;
	content: "Potential Fix " counter(elementcounter) ": ";
	counter-increment: elementcounter;
	font-weight: 700;
}

.important {
        background-color: #ffc107;
        outline: #ffc107 solid 2px;
}

.highlight-line {
	font-weight: 700;
	outline: #57301d solid 3px;
}

.highlight-selected-line {
	font-weight: 700;
	outline: #ff0000 solid 3px;
}

.fault {
        background-color: #ff3333;
        outline: #aa3333 solid 2px;
		font-weight: 900;
}

.tableheader{
	font-weight: 700;
	background-color: #bbbbbb;
	text-align: center;
}

.marked-source-line {
	background-color: #df80ff !important;
}

.marked-cfa-edge path {
	stroke: #8B008B !important;
	stroke-width: 3px !important;
}

.marked-arg-edge path {
	stroke: #8B008B !important;
	stroke-width: 3px !important;
}

.marked-cfa-node>rect {
	outline: #8B008B solid thick !important;
	rx: 5;
	ry: 5
}

.marked-cfa-node>polygon {
	stroke: #8B008B !important;
	stroke-width: 5px !important;
}

.marked-cfa-node>circle {
	stroke: #8B008B !important;
	stroke-width: 5px !important;
}

.marked-cfa-node-label {
	fill: #ff00ff !important;
}

.marked-arg-node>rect {
	outline: #8B008B solid thick !important;
	rx: 5;
	ry: 5
}

#externalFiles_section {
	float: right;
	position: absolute;
	right: 0px;
	width: 100%;
	height: 100%;
	background-color: white;
	padding: 10px;
	overflow: hidden;
}

#externalFiles_section .popover {
	overflow-x: hidden;
	overflow-y: auto;
}

#externalFiles_section .fileContent {
	height: calc(100% - 160px);
	width: 100%;
	margin: 5px;
	position: relative;
}

#externalFiles_section div.content {
	overflow: scroll;
	position: absolute;
	top: 100px;
	bottom: 5px;
	left: 5px;
	right: 5px;
}

#externalFiles_section div.cfa-content {
	overflow: scroll;
	position: absolute;
	height: calc(100% - 250px);
	top: 200px;
	bottom: 5px;
	left: 5px;
	right: 5px;
}

#externalFiles_section div.arg-content {
	overflow: scroll;
	position: absolute;
	height: calc(100% - 250px);
	top: 200px;
	bottom: 5px;
	left: 5px;
	right: 5px;
}

table {
	border-collapse: separate;
	border-spacing: 2px;
}

.dataTables_wrapper {
	padding: 10px;
}

#statistics_table td:first-child {
	white-space: pre;
}

#statistics_table .table_head {
	background-color: #ccc;
}

#err-table td:first-child {
	background-color: #ccc;
}

.sourceContent td:first-child {
	background-color: #ccc;
}

.sourceContent td pre {
	padding: 0px;
	margin: 0px;
	border: none;
}

.sourceContent tr:nth-child(odd) td pre.prettyprint {
	background-color: #c6dce7;
}

.sourceContent tr:nth-child(even) td pre.prettyprint {
	background-color: #a8cfe2;
}

.edit-line {
	width: 100%;
	background-color: white;
	padding: 5px;
}

.edit-line div {
	display: inline-block;
}

.edit-line label {
	margin-right: 100px;
	display: inline-block;
}

.edit-line p {
	display: inline-block;
}

div pre {
	background-color: transparent;
	border: 0;
	margin: 0;
	padding: 0;
	overflow: visible;
}

.help_button {
	padding: 0px;
	border: 0px;
	margin: 0px;
	display: inline-block;
}

#externalFiles_section .help_button {
	margin-left: 10px;
	float: left;
}

.cfa-graph {
	visibility: hidden;
}

.arg-graph {
	visibility: hidden;
}

.loader {
	font-family: "Helvetica Neue", Helvetica, Arial, "sans-serf";
	font-size: 20px;
	font-style: italic;
	color: #4040a1;
}

#cfa-toolbar {
	width: auto;
	background-color: white;
	margin-top: 5px;
	margin-left: 10px;
	padding: 5px;
	position: fixed;
	display: inline-block;
	visibility: hidden;
}

#cfa-toolbar select {
	max-width: 150px;
}

#cfa-toolbar label {
	margin-left: 20px;
	margin-right: 5px;
}

#cfa-toolbar text {
	font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
	font-size: 11px;
}

input[type=text] {
	width: 80px;
	height: 34px;
}

#arg-container {
	top: 200px;
}

#cfa-container {
	top: 200px;
}

#arg-toolbar {
	width: auto;
	background-color: white;
	margin-top: 5px;
	margin-left: 10px;
	padding: 5px;
	position: fixed;
	display: inline-block;
	visibility: hidden;
}

#arg-toolbar label {
	margin-left: 20px;
	margin-right: 5px;
}

#arg-toolbar text {
	font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
	font-size: 11px;
}

text {
	font-weight: bold;
	font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
	font-size: 12px;
}

.arg-node.target>rect {
	fill: red;
	rx: 5;
	ry: 5
}

.arg-node.not-expanded>rect {
	fill: orange;
	rx: 5;
	ry: 5
}

.arg-node.highlighted>rect {
	fill: cornflowerblue;
	rx: 5;
	ry: 5
}

.arg-node.covered>rect {
	fill: green;
	rx: 5;
	ry: 5
}

.arg-node text {
	text-anchor: middle;
	font-family: "Times New Roman", serif;
}

.arg-node rect {
	fill: #fff;
	rx: 5;
	ry: 5
}

.cfa-node rect {
	stroke: #999;
	fill: #fff;
	stroke-width: 1.5px;
	rx: 5;
	ry: 5
}

.cfa-node circle {
	stroke: #999;
	fill: #fff;
	stroke-width: 1.5px;
}

.cfa-node polygon {
	stroke: #999;
	fill: #fff;
	stroke-width: 1.5px;
}

.cfa-dummy rect {
	fill: #fff;
	stroke: #c0c0c0;
	stroke-width: 0.5px;
	rx: 5;
	ry: 5
}

.arg-dummy rect {
	fill: #fff;
	stroke: #c0c0c0;
	stroke-width: 0.5px;
	rx: 5;
	ry: 5
}

.fcall rect {
	stroke: #999;
	fill: #fff;
	stroke-width: 1.5px;
	rx: 5;
	ry: 5
}

.edgePath path {
	stroke: #A9A9A9;
	fill: #ffffff;
	stroke-width: 1.5px;
}

.error-edge path {
	stroke: red;
	fill: #ffffff;
	stroke-width: 1.5px;
}

/* if we have display: none here Firefox cannot render the edges connecting to the dummy nodes */

.dummy rect {
	visibility: hidden;
}

#infoBox {
	visibility: hidden;
	position: absolute;
	top: 10px;
	left: 10px;
	z-index: 1;
	width: 200px;
	background-color: #ffef96;
	display: inline-block;
	border-radius: 6px;
}

.tool_tip #boxContent::after {
	content: "";
	position: absolute;
	top: 25%;
	right: 100%;
	margin-top: -5px;
	border-width: 5px;
	border-style: solid;
	border-color: transparent #ffef96 transparent transparent;
}

#insideBox {
	padding-top: 10px;
}

#boxContent {
	font-family: Verdana, Arial, Helvetica, sans-serif;
	font-size: 12px;
	line-height: 130%;
	color: black;
	text-align: center;
	padding: 5px 0;
}

.bold {
	font-weight: bold;
}

</style>  <link rel="stylesheet" href="https://www.sosy-lab.org/lib/fontawesome-free/css/fontawesome-all.min.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp"
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://www.sosy-lab.org/lib/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB"
    crossorigin="anonymous">
  <script src="https://www.sosy-lab.org/lib/jquery/3.3.1/jquery.min.js" integrity="sha384-tsQFqpEReu7ZLhBV2VZlAu7zcOV+rXbYlF2cqB8txI/8aZajjp4Bqd+V6D5IgvKT"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://www.sosy-lab.org/lib/jquery-ui/1.12.1/jquery-ui.min.css" integrity="sha384-VK/ia2DWrvtO05YDcbWI8WE3WciOH0RhfPNuRJGSa3dpAs5szXWQuCnPNv/yzpO4"
    crossorigin="anonymous">
  <script src="https://www.sosy-lab.org/lib/jquery-ui/1.12.1/jquery-ui.min.js" integrity="sha384-PtTRqvDhycIBU6x1wwIqnbDo8adeWIWP3AHmnrvccafo35E7oIvW7HPXn2YimvWu"
    crossorigin="anonymous"></script>
  <script src="https://www.sosy-lab.org/lib/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
    crossorigin="anonymous"></script>
  <script src="https://www.sosy-lab.org/lib/tooltip.js/1.2.0/tooltip.min.js" integrity="sha384-9MYfW4+cUynMIN6UiFuOu/5GAs2JEbbknCAyCvLPttuYxlLpocQpEkX210OoGn4p"
    crossorigin="anonymous"></script>
  <script src="https://www.sosy-lab.org/lib/angularjs/1.7.0/angular.min.js" integrity="sha384-OGKaWeggmIvCx/zchfRERRmxXYyFHhSRKBcld3xfy5N42zsVueW6rVyiL7E53ZGJ"
    crossorigin="anonymous"></script>
  <script src="https://www.sosy-lab.org/lib/d3js/5.4.0/d3.min.js" integrity="sha384-Ha//YQhNUuPzmPKgC8aYpurZcTiV3JhEvEhH5uGW0IRjBfEgDQxvo0aF1Gef+blI"
    crossorigin="anonymous"></script>
  <script src="https://www.sosy-lab.org/lib/dagre-d3/0.5.0/dagre-d3.min.js" integrity="sha384-0qz1K6Ihi4XT9AwqcOOC/ciBQ9ufdzKZUc8G1It6RZ+oLJSk41EhaZiLPVoBE0JT"
    crossorigin="anonymous"></script>
  <script src="https://www.sosy-lab.org/lib/google-code-prettify/2018-04-29-453bd5f/prettify.js" integrity="sha384-KlbExXRJYYILJYRAJR121vJXgBDx+puqf1yjznMcTt7C5njwQajOLFwk6pMafFnX"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://www.sosy-lab.org/lib/google-code-prettify/2018-04-29-453bd5f/prettify.css" integrity="sha384-tGeLopS7aWCwgeqg+ah7c+iI19JU3teQPshyaQVybvOMRravAVLscwoeT4HPsfoW"
    crossorigin="anonymous">
  <script src="https://www.sosy-lab.org/lib/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://www.sosy-lab.org/lib/datatables/1.10.18/datatables.min.css" integrity="sha384-t1jrh3H+gcVq93cU14/FvFkiDDLHAupR2uFWQFOIqqB0ZgNvd09e5yjT5Mc9mGPZ"
    crossorigin="anonymous">
  <script src="https://www.sosy-lab.org/lib/datatables/1.10.18/datatables.min.js" integrity="sha384-b6lz7vBoPNFWulOisoJlEziEWnbO6TbeulJvmrmuro+kXqlUgmn+sVfASUlqVcZo"
    crossorigin="anonymous"></script>
  <script>
// This file is part of CPAchecker,
// a tool for configurable software verification:
// https://cpachecker.sosy-lab.org
//
// SPDX-FileCopyrightText: 2007-2020 Dirk Beyer <https://www.sosy-lab.org>
// SPDX-FileCopyrightText: 2018 Lokesh Nandanwar
//
// SPDX-License-Identifier: Apache-2.0

/* Refer to the doc/ReportTemplateStyleGuide.md for Coding and Style Guide. They will let you write better code
with considerably less effort */

(function () {
	$(function () {
		// initialize all popovers
		$('[data-toggle="popover"]').popover({
			html: true
		});
		// initialize all tooltips
		$("[data-toggle=tooltip]").tooltip({
			trigger: 'hover'
		});
		$(document).on('hover', '[data-toggle=tooltip]', function () {
			$(this).tooltip('show');
		});

		// hide tooltip after 5 seconds
		var timeout;
		$(document).on('shown.bs.tooltip', function (e) {
			if (timeout) {
				clearTimeout(timeout)
			}
			timeout = setTimeout(function () {
				$(e.target).tooltip('hide');
			}, 5000);
		});

		//Statistics table initialization
		$(document).ready(function () {
			$('#statistics_table').DataTable({
				"order": [],
				aLengthMenu: [
					[25, 50, 100, 200, -1],
					[25, 50, 100, 200, "All"]
				],
				iDisplayLength: -1, //Default display all entries
				"columnDefs": [{
						"orderable": false, //No ordering
						"targets": 0,
					}, {
						"orderable": false, //No Ordering
						"targets": 1,
					},
					{
						"orderable": false, //No ordering
						"targets": 2,
					},
				]
			});
		});

		// Initialize Google pretiffy code
		$(document).ready(function () {
			PR.prettyPrint();
		});

		//Configuration table initialization
		$(document).ready(function () {
			$('#config_table').DataTable({
				"order": [
					[1, "asc"]
				],
				aLengthMenu: [
					[25, 50, 100, 200, -1],
					[25, 50, 100, 200, "All"]
				],
				iDisplayLength: -1 //Default display all entries
			});
		});

		//Log table initialization
		$(document).ready(function () {
			$('#log_table').DataTable({
				"order": [
					[0, "asc"]
				],
				autoWidth: false,
				aoColumns: [{
						sWidth: '12%'
					},
					{
						sWidth: '10%'
					},
					{
						sWidth: '10%'
					},
					{
						sWidth: '25%'
					},
					{
						sWidth: '43%'
					},
				],
				aLengthMenu: [
					[25, 50, 100, 200, -1],
					[25, 50, 100, 200, "All"]
				],
				iDisplayLength: -1
			});
		});

		// Draggable divider between error path section and file section
		$(function resizeSection() {
			$("#errorpath_section").resizable({
				autoHide: true,
				handles: 'e',
				resize: function (e, ui) {
					var parent = ui.element.parent();
					//alert(parent.attr('class'));
					var remainingSpace = parent.width() - ui.element.outerWidth(),
						divTwo = ui.element.next(),
						divTwoWidth = (remainingSpace - (divTwo.outerWidth() - divTwo.width())) / parent.width() * 100 + "%";
					divTwo.width(divTwoWidth);
				},
				stop: function (e, ui) {
					var parent = ui.element.parent();
					ui.element.css({
						width: ui.element.width() / parent.width() * 100 + "%",
					});
				}
			});
		});
	});

	var app = angular.module('report', []);

	reportController = app.controller('ReportController', ['$rootScope', '$scope',
		function ($rootScope, $scope) {
			$scope.logo = "https://cpachecker.sosy-lab.org/logo.svg";
			$scope.help_content = "<div class=\"container \" style=\"font-family: Arial\"><p><b>CFA</b> (Control Flow Automaton) shows the control flow of the program. <br> For each function in the source code one CFA graph is created. <br>" +
				"Initially all CFA's are displayed below one another beginning with the CFA for the program entry function.</p>" + "<p> If an error path is detected by the analysis the edges leading to it will appear red.</p>" +
				"<p>&#9675; &nbsp; normal element</p>" +
				"<p>&#9634; &nbsp; combined normal elements</p>" +
				"<p>&#9645; &nbsp; function node</p>" +
				"<p>&#9671; &nbsp; loop head</p>" +
				"<p>- doubleclick on a function node to select the CFA for this function</p>" +
				"<p>- doubleclick on edges to jump to the relating line in the Source tab</p>" +
				"<p>- use the Displayed CFA select box to display only the CFA for the desired function </p>" +
				"<p>- use the Mouse Wheel Zoom checkbox to alter between scroll and zoom behaviour on mouse wheel</p>" +
				"<p>- use Split Threshold and 'Refresh button' to redraw the graph (values between 500 and 900)</p>" +
				"<p><b>ARG</b> (Abstract Reachability Graph) shows the explored abstract state space</p>" +
				"<p> If an error path is detected by the analysis the edges leading to it will appear red.</p>" +
				"<p><span style=\"background-color:green;\">&#9645;</span> covered state</p>" +
				"<p><span style=\"background-color:orange;\">&#9645;</span> not yet processed state</p>" +
				"<p><span style=\"background-color:cornflowerblue;\">&#9645;</span> important state (depending on used analysis)</p>" +
				"<p><span style=\"background-color:red;\">&#9645;</span> target state</p>" +
				"<p>- doubleclick on node to jump to relating node in CFA</p>" +
				"<p>- use the Displayed ARG select box to select between the complete ARG and ARG containing only the error path (only in case an error was found) </p>" +
				"<p>- use the Mouse Wheel Zoom checkbox to alter between scroll and zoom behaviour on mouse wheel</p>" +
				"<p>- use Split Threshold and 'Refresh button' to redraw the graph (values between 500 and 900)</p>" +
				"<p><b>In case of split graph (applies to both CFA and ARG)</b><br> -- doubleclick on labelless node to jump to target node<br> -- doubleclick on 'split edge' to jump to initial edge </p></div>";
			$scope.help_fault_localization = "<div class=\"container \" style=\"font-family: Arial\"> <b>Change view</b> Toggle between two different views: The default counter example and the information provided by the selected fault localization algorithm. " +
				"In the second view, every entry consists of a header with three elements and a bigger section with more details." +
				"<ul><li>The <span style=\"color: #28a745\"><b>first element</b></span> of the header shows the rank.</li>" +
				"<li>The <span style=\"color: #ffc107\"><b>second element</b></span> shows the score, which is computed by several heuristics.</li></ul>" +
				"<p>Usually, faults with a higher score have a higher rank, too. " +
				"The Error-Invariants-Algorithm does not sort the faults by score, but by hierarchical order.</p>" +
				"<p>Every fault localization technique provides information shown in the details section. " +
				"In the details section, variables are displayed as follows function::variable-name@ssa-index. " +
				"In some cases, a program contains calls to <code>__VERIFIER_nondet_X()</code> where <code>X</code> " +
				"stands for all supported data types. CPAchecker creates temporary variables for every call to <code>__VERIFIER_nondet_X()</code>. " +
				"Starting with <code>!2</code> CPAchecker sequentially increments the counter for every new call to <code>__VERIFIER_nondet_X()</code>.</p>" +
				"<p><b>Example:</b><br> A possible formula for the given program<br>" +
				"<code>int x = __VERIFIER_nondet_int();</code><br>" +
				"<code>int y = __VERIFIER_nondet_int();</code><br>" +
				"<code>if (x == 1 && y == 2) goto ERROR;</code><br>" +
				"may look like this:<br>" +
				"<code>__VERIFIER_nondet_int!2@ = 1 && __VERIFIER_nondet_int!3@ = 2</code></p>" +
				"</div>";
			$scope.help_errorpath = "<div style=\"font-family: Arial\"><p>The errorpath leads to the error 'edge by edge' (CFA) or 'node by node' (ARG) or 'line by line' (Source)</p>" +
				"<p><b>-V- (Value Assignments)</b> Click to show all initialized variables and their values at that point in the programm.</p>" +
				"<p><b>Edge-Description (Source-Code-View)</b> Click to jump to the relating edge in the CFA / node in the ARG / line in Source (depending on active tab).\n If non of the mentioned tabs is currently set, the ARG tab will be selected.</p>" +
				"<p><b>Buttons (Prev, Start, Next)</b> Click to navigate through the errorpath and jump to the relating position in the active tab</p>" +
				"<p><b>Search</b>\n - You can search for words or numbers in the edge-descriptions (matches appear blue)\n" +
				"- You can search for value-assignments (variable names or their value) - it will highlight only where a variable has been initialized or where it has changed its value (matches appear green)\n" +
				"- An 'exact matches' search will look for a variable declarator matching exactly the provided text considering both, edge descriptions and value assignments</p></div>";
			$scope.tab = 1;
			$scope.$on("ChangeTab", function (event, tabIndex) {
				$scope.setTab(tabIndex);
			});

			//Toggle button to hide the error path section
			$scope.toggleErrorPathSection = function (e) {
				$('#toggle_error_path').on('change', function () {
					if ($(this).is(':checked')) {
						d3.select("#errorpath_section").style("display", "inline");
						d3.select("#errorpath_section").style("width", "25%");
						d3.select("#externalFiles_section").style("width", "75%");
						d3.select("#cfa-toolbar").style("width", "auto");
					} else {
						d3.select("#errorpath_section").style("display", "none");
						d3.select("#externalFiles_section").style("width", "100%");
						d3.select("#cfa-toolbar").style("width", "95%");
					}
				});
			};

			//Full screen mode function to view the report in full screen
			$('#full_screen_mode').click(function () {
				$(this).find('i').toggleClass('fa-compress fa-expand')
			});

			$scope.makeFullScreen = function () {
				if ((document.fullScreenElement && document.fullScreenElement !== null) || (!document.mozFullScreen && !
						document.webkitIsFullScreen)) {
					if (document.documentElement.requestFullScreen) {
						document.documentElement.requestFullScreen();
					} else if (document.documentElement.mozRequestFullScreen) {
						document.documentElement.mozRequestFullScreen();
					} else if (document.documentElement.webkitRequestFullScreen) {
						document.documentElement.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
					}
				} else {
					if (document.cancelFullScreen) {
						document.cancelFullScreen();
					} else if (document.mozCancelFullScreen) {
						document.mozCancelFullScreen();
					} else if (document.webkitCancelFullScreen) {
						document.webkitCancelFullScreen();
					}
				}
			};

			$scope.setTab = function (tabIndex) {
				if (tabIndex === 1) {
					if (d3.select("#arg-toolbar").style("visibility") !== "hidden") {
						d3.select("#arg-toolbar").style("visibility", "hidden");
						d3.selectAll(".arg-graph").style("visibility", "hidden");
						d3.selectAll(".arg-simplified-graph").style("visibility", "hidden");
						d3.selectAll(".arg-reduced-graph").style("visibility", "hidden");
						d3.selectAll(".arg-error-graph").style("visibility", "hidden");
						if (d3.select("#arg-container").classed("arg-content")) {
							d3.select("#arg-container").classed("arg-content", false);
						}
					}
					d3.select("#cfa-toolbar").style("visibility", "visible");
					if (!d3.select("#cfa-container").classed("cfa-content")) {
						d3.select("#cfa-container").classed("cfa-content", true);
					}
					d3.selectAll(".cfa-graph").style("visibility", "visible");
				} else if (tabIndex === 2) {
					if (argTabDisabled) return;
					if (d3.select("#cfa-toolbar").style("visibility") !== "hidden") {
						d3.select("#cfa-toolbar").style("visibility", "hidden");
						d3.selectAll(".cfa-graph").style("visibility", "hidden");
						if (d3.select("#cfa-container").classed("cfa-content")) {
							d3.select("#cfa-container").classed("cfa-content", false);
						}
					}
					d3.select("#arg-toolbar").style("visibility", "visible");
					if (!d3.select("#arg-container").classed("arg-content")) {
						d3.select("#arg-container").classed("arg-content", true);
					}
					d3.selectAll(".arg-simplified-graph").style("display", "none");
					d3.selectAll(".arg-reduced-graph").style("display", "none");
					if ($rootScope.displayedARG.indexOf("error") !== -1) {
						d3.selectAll(".arg-error-graph").style("visibility", "visible");
						if ($("#arg-container").scrollTop() === 0) {
							$("#arg-container").scrollTop(200).scrollLeft(0);
						}
					} else {
						d3.selectAll(".arg-graph").style("visibility", "visible");
						if ($("#arg-container").scrollTop() === 0) {
							var boundingRect = d3.select(".arg-node").node().getBoundingClientRect();
							$("#arg-container").scrollTop(boundingRect.top + $("#arg-container").scrollTop() - 300).scrollLeft(boundingRect.left + $("#arg-container").scrollLeft() - 500);
						}
					}
				} else {
					if (d3.select("#cfa-toolbar").style("visibility") !== "hidden") {
						d3.select("#cfa-toolbar").style("visibility", "hidden");
						d3.selectAll(".cfa-graph").style("visibility", "hidden");
						if (d3.select("#cfa-container").classed("cfa-content")) {
							d3.select("#cfa-container").classed("cfa-content", false);
						}
					}
					if (d3.select("#arg-toolbar").style("visibility") !== "hidden") {
						d3.select("#arg-toolbar").style("visibility", "hidden");
						d3.selectAll(".arg-graph").style("visibility", "hidden");
						d3.selectAll(".arg-simplified-graph").style("visibility", "hidden");
						d3.selectAll(".arg-reduced-graph").style("visibility", "hidden");
						d3.selectAll(".arg-error-graph").style("visibility", "hidden");
						if (d3.select("#arg-container").classed("arg-content")) {
							d3.select("#arg-container").classed("arg-content", false);
						}
					}
				}
				$scope.tab = tabIndex;
			};
			$scope.tabIsSet = function (tabIndex) {
				return $scope.tab === tabIndex;
			};

			$scope.getTabSet = function () {
				return $scope.tab;
			};
		}
	]);

	var errorpathController = app.controller("ErrorpathController", ['$rootScope', '$scope', function ($rootScope, $scope) {
		$rootScope.errorPath = [];

		//Fault Localization
		function getLinesOfFault(fault) {
			var lines = {};
			for (var i = 0; i < fault["errPathIds"].length; i++) {
				var errorPathIdx = fault["errPathIds"][i];
				var errorPathElem = $rootScope.errorPath[errorPathIdx];
				var line = {"line": errorPathElem["line"], "desc": errorPathElem["desc"]};
				var line_key = line["line"] + line["desc"];
				lines[line_key] = line;
			}
			return Object.values(lines);
		};

		function getValues(val, prevValDict) {
			var values = {};
			if (val != "") {
				var singleStatements = val.split("\n");
				for (var i = 0; i < singleStatements.length - 1; i++) {
					if (!Object.keys(prevValDict).includes(singleStatements[i].split("==")[0].trim())) {
						// previous dictionary does not include the statement
						values[singleStatements[i].split("==")[0].trim()] = singleStatements[i].split("==")[1].trim().slice(0, -1);
					} else if (prevValDict[singleStatements[i].split("==")[0].trim()] !== singleStatements[i].split("==")[1].trim().slice(0, -1)) {
						// statement is included but with different value
						values[singleStatements[i].split("==")[0].trim()] = singleStatements[i].split("==")[1].trim().slice(0, -1);
					}
				}
			}
			return values;
		};

		// initialize array that stores the important edges. Index counts only, when edges appear in the report.
		var importantEdges = [];
		var importantIndex = -1;
		var faultEdges = [];
		if (errorPath !== undefined) {
			var indentationlevel = 0;
			for (var i = 0; i < errorPath.length; i++) {
				var errPathElem = errorPath[i];

				// do not show start, return and blank edges
				if (errPathElem.desc.indexOf("Return edge from") === -1 && errPathElem.desc != "Function start dummy edge" && errPathElem.desc != "") {
					importantIndex += 1;
					var previousValueDictionary = {};
					errPathElem["valDict"] = {};
					errPathElem["valString"] = "";
					if (i > 0) {
						$.extend(errPathElem.valDict, $rootScope.errorPath[$rootScope.errorPath.length - 1].valDict);
						previousValueDictionary = $rootScope.errorPath[$rootScope.errorPath.length - 1].valDict;
					}
					var newValues = getValues(errPathElem.val, previousValueDictionary);
					errPathElem["newValDict"] = newValues;
					if (!$.isEmptyObject(newValues)) {
						$.extend(errPathElem.valDict, newValues);
					}
					for (var key in errPathElem.valDict) {
						errPathElem.valString += key + ":  " + errPathElem.valDict[key] + "\n";
					}
					// add indentation
					for (var j = 1; j <= indentationlevel; j++) {
						errPathElem.desc = "   " + errPathElem.desc;
					}
					$rootScope.errorPath.push(errPathElem);
				} else if (errPathElem.desc.indexOf("Return edge from") !== -1) {
					indentationlevel -= 1;
				} else if (errPathElem.desc.indexOf("Function start dummy") !== -1) {
					indentationlevel += 1;
				}

				if (errPathElem.faults !== undefined && errPathElem.faults.length > 0) {
					errPathElem["importantindex"] = importantIndex;
					errPathElem["bestrank"] = cfaJson.faults[errPathElem.faults[0]].rank;
					errPathElem["bestreason"] = cfaJson.faults[errPathElem.faults[0]].reason;
					if (errPathElem["additional"] !== undefined && errPathElem["additional"] !== "") {
						errPathElem["bestreason"] = errPathElem["bestreason"] + errPathElem["additional"];
					}
					faultEdges.push(errPathElem);
				}

				// store the important edges
                                if(errPathElem.importance == 1){
                                      importantEdges.push(importantIndex);
                                   }
			}

			function addFaultLocalizationInfo(){
				if (faultEdges !== undefined && faultEdges.length > 0) {
					for (var j = 0; j < faultEdges.length; j++) {
						d3.selectAll("#errpath-" + faultEdges[j].importantindex + " td pre").classed("fault", true);
					}
					d3.selectAll("#errpath-header td pre").classed("tableheader", true);
				}
			};

                        // this function puts the important edges into a CSS class that highlights them
			function highlightEdges(impEdges){
			    for (var j = 0; j < impEdges.length; j++){
			        d3.selectAll("#errpath-" + impEdges[j] + " td pre").classed("important", true);
			    }
                        };

                        angular.element(document).ready(function(){
				highlightEdges(importantEdges);
				addFaultLocalizationInfo();
                        });


		}

		// make faults visible to angular
		$rootScope.faults = [];
		$rootScope.precondition = cfaJson.precondition === undefined ? "" : cfaJson.precondition["fl-precondition"];
		$rootScope.hasPrecondition = $rootScope.precondition !== "";
		if (cfaJson.faults !== undefined) {
			for (var i = 0; i < cfaJson.faults.length; i++) {
				var fault = cfaJson.faults[i];
				var fInfo = Object.assign({}, fault);
				// store all error-path elements related to this fault.
				// we can't do  this in the Java backend because
				// we can't be sure to have the full error-path elements in the FaultLocalizationInfo
				// when the faults-code is generated.
				fInfo["errPathIds"] = [];
				for (var j = 0; j < $rootScope.errorPath.length; j++) {
					var element = $rootScope.errorPath[j];
					if (element.faults.includes(i)) {
						fInfo["errPathIds"].push(j);
						fInfo["valDict"] = element.valDict;
					}
					fInfo["lines"] = getLinesOfFault(fInfo);
				}
				$rootScope.faults.push(fInfo);
			}
		}


		$scope.hideFaults = ($rootScope.faults == undefined || $rootScope.faults.length == 0);

		$scope.faultClicked = function(){
			$scope.hideErrorTable = !$scope.hideErrorTable;
		};

		$scope.clickedFaultLocElement = function ($event) {
			d3.selectAll(".clickedFaultLocElement").classed("clickedFaultLocElement", false);
			var clickedElement = d3.select($event.currentTarget);
			clickedElement.classed("clickedFaultLocElement", true);
			var faultElementIdx = clickedElement.attr("id").substring("fault-".length);
			var faultElement = $rootScope.faults[faultElementIdx];
			markErrorPathElementInTab(faultElement.errPathIds);
		};

		$scope.errPathPrevClicked = function ($event) {
			var selection = d3.select("tr.clickedErrPathElement");
			if (!selection.empty()) {
				var prevId = parseInt(selection.attr("id").substring("errpath-".length)) - 1;
				selection.classed("clickedErrPathElement", false);
				d3.select("#errpath-" + prevId).classed("clickedErrPathElement", true);
				$("#value-assignment").scrollTop($("#value-assignment").scrollTop() - 18);
				markErrorPathElementInTab(prevId);
			}
		};

		$scope.errPathStartClicked = function () {
			d3.select("tr.clickedErrPathElement").classed("clickedErrPathElement", false);
			d3.select("#errpath-0").classed("clickedErrPathElement", true);
			$("#value-assignment").scrollTop(0);
			markErrorPathElementInTab(0);
		};

		$scope.errPathNextClicked = function ($event) {
			var selection = d3.select("tr.clickedErrPathElement");
			if (!selection.empty()) {
				var nextId = parseInt(selection.attr("id").substring("errpath-".length)) + 1;
				selection.classed("clickedErrPathElement", false);
				d3.select("#errpath-" + nextId).classed("clickedErrPathElement", true);
				$("#value-assignment").scrollTop($("#value-assignment").scrollTop() + 18);
				markErrorPathElementInTab(nextId);
			}
		};

		$scope.clickedErrpathElement = function ($event) {
			d3.select("tr.clickedErrPathElement").classed("clickedErrPathElement", false);
			var clickedElement = d3.select($event.currentTarget.parentNode);
			clickedElement.classed("clickedErrPathElement", true);
			markErrorPathElementInTab(clickedElement.attr("id").substring("errpath-".length));
		};

		function markErrorPathElementInTab(selectedErrPathElemId) {
			var currentTab = $("#report-controller").scope().getTabSet();
			if (!Array.isArray(selectedErrPathElemId)) {
				selectedErrPathElemId = [selectedErrPathElemId];
			}
			unmarkEverything();
			for (var i = 0; i < selectedErrPathElemId.length; i++) {
				var id = selectedErrPathElemId[i];
				if ($rootScope.errorPath[id] === undefined) {
					return;
				}
				handleErrorPathElemClick(currentTab, id);
			}
		}

		function handleErrorPathElemClick(currentTab, errPathElemIndex) {
			markCfaEdge($rootScope.errorPath[errPathElemIndex]);
			markArgNode($rootScope.errorPath[errPathElemIndex]);
			markSourceLine($rootScope.errorPath[errPathElemIndex]);
			if (![1, 2, 3].includes(currentTab)) {
				$("#report-controller").scope().setTab(2);
			}
		}

		function unmarkEverything() {
			[
				"marked-cfa-edge",
				"marked-cfa-node",
				"marked-cfa-node-label",
				"marked-arg-node",
				"marked-source-line",
			].forEach(function (c) { d3.selectAll("." + c).classed(c, false) });
		}


		function markCfaEdge(errPathEntry) {
			var actualSourceAndTarget = getActualSourceAndTarget(errPathEntry);
			if ($.isEmptyObject(actualSourceAndTarget)) return;
			if (actualSourceAndTarget.target === undefined) {
				var selection = d3.select("#cfa-node" + actualSourceAndTarget.source);
				selection.classed("marked-cfa-node", true);
				var boundingRect = selection.node().getBoundingClientRect();
				$("#cfa-container").scrollTop(boundingRect.top + $("#cfa-container").scrollTop() - 300).scrollLeft(boundingRect.left - d3.select("#cfa-container").style("width").split("px")[0] - $("#cfa-container"));
				if (actualSourceAndTarget.source in cfaJson.combinedNodes) {
					selection.selectAll("tspan").each(function (d, i) {
						if (d3.select(this).html().includes(errPathEntry.source)) {
							d3.select(this).classed("marked-cfa-node-label", true);
						}
					});
				}
				return;
			}
			var selection = d3.select("#cfa-edge_" + actualSourceAndTarget.source + "-" + actualSourceAndTarget.target);
			selection.classed("marked-cfa-edge", true);
			var boundingRect = selection.node().getBoundingClientRect();
			$("#cfa-container").scrollTop(boundingRect.top + $("#cfa-container").scrollTop() - 300).scrollLeft(boundingRect.left - d3.select("#cfa-container").style("width").split("px")[0] - $("#cfa-container"));
		}

		function getActualSourceAndTarget(element) {
			var result = {};
			if (cfaJson.mergedNodes.includes(element.source) && cfaJson.mergedNodes.includes(element.target)) {
				result["source"] = getMergingNode(element.source);
				return result;
			}
			if (element.source in cfaJson.combinedNodes) {
				result["source"] = element.source;
				return result;
			}
			if (!cfaJson.mergedNodes.includes(element.source) && !cfaJson.mergedNodes.includes(element.target)) {
				result["source"] = element.source;
				result["target"] = element.target;
			} else if (!cfaJson.mergedNodes.includes(element.source) && cfaJson.mergedNodes.includes(element.target)) {
				result["source"] = element.source;
				result["target"] = getMergingNode(element.target);
			} else if (cfaJson.mergedNodes.includes(element.source) && !cfaJson.mergedNodes.includes(element.target)) {
				result["source"] = getMergingNode(element.source);
				result["target"] = element.target;
			}
			if (Object.keys(cfaJson.functionCallEdges).includes("" + result["source"])) {
				result["target"] = cfaJson.functionCallEdges["" + result["source"]][0];
			}
			// Ensure empty object is returned if source = target (edge non existent)
			if (result["source"] === result["target"]) {
				delete result["source"];
				delete result["target"];
			}
			return result;
		}

		// Retrieve the node in which this node was merged
		function getMergingNode(index) {
			var result = "";
			Object.keys(cfaJson.combinedNodes).some(function (key) {
				if (cfaJson.combinedNodes[key].includes(index)) {
					result = key;
					return result;
				}
			})
			return result;
		}

		function markArgNode(errPathEntry) {
			if (errPathEntry.argelem === undefined) {
				return;
			}
			var idToSelect;
			if (d3.select("#arg-graph0").style("display") !== "none")
				idToSelect = "#arg-node";
			else
				idToSelect = "#arg-error-node";
			var selection = d3.select(idToSelect + errPathEntry.argelem);
			selection.classed("marked-arg-node", true);
			var boundingRect = selection.node().getBoundingClientRect();
			$("#arg-container").scrollTop(boundingRect.top + $("#arg-container").scrollTop() - 300).scrollLeft(boundingRect.left - d3.select("#arg-container").style("width").split("px")[0] - $("#arg-container"));
		}

		function markSourceLine(errPathEntry) {
			if (errPathEntry.line === 0) {
				errPathEntry.line = 1;
			}
			var selection = d3.select("#source-" + errPathEntry.line + " td pre.prettyprint");
			selection.classed("marked-source-line", true);
			$(".sourceContent").scrollTop(selection.node().getBoundingClientRect().top + $(".sourceContent").scrollTop() - 200);
		}

	}]);

	var searchController = app.controller("SearchController", ['$rootScope', '$scope', function ($rootScope, $scope) {
		$scope.numOfValueMatches = 0;
		$scope.numOfDescriptionMatches = 0;

		$scope.checkIfEnter = function ($event) {
			if ($event.keyCode == 13) {
				$scope.searchFor();
			}
		};

		$scope.searchFor = function () {
			$scope.numOfValueMatches = 0;
			$scope.numOfDescriptionMatches = 0;
			if (d3.select("#matches").style("display") === "none") {
				d3.select("#matches").style("display", "inline");
			}
			d3.selectAll(".markedValueDescElement").classed("markedValueDescElement", false);
			d3.selectAll(".markedValueElement").classed("markedValueElement", false);
			d3.selectAll(".markedDescElement").classed("markedDescElement", false);
			var searchInput = $(".search-input").val().trim();
			if (searchInput != "") {
				if ($("#optionExactMatch").prop("checked")) {
					$rootScope.errorPath.forEach(function (it, i) {
						var exactMatchInValues = searchInValues(it.newValDict, searchInput, true);
						if (exactMatchInValues && searchInDescription(it.desc.trim(), searchInput)) {
							$scope.numOfValueMatches++;
							$scope.numOfDescriptionMatches++;
							$("#errpath-" + i + " td")[1].classList.add("markedValueDescElement");
						} else if (exactMatchInValues) {
							$scope.numOfValueMatches++;
							$("#errpath-" + i + " td")[1].classList.add("markedValueElement");
						} else if (searchInDescription(it.desc.trim(), searchInput)) {
							$scope.numOfDescriptionMatches++;
							$("#errpath-" + i + " td")[1].classList.add("markedDescElement");
						}
					})
				} else {
					$rootScope.errorPath.forEach(function (it, i) {
						var matchInValues = searchInValues(it.newValDict, searchInput, false);
						if (matchInValues && it.desc.indexOf(searchInput) !== -1) {
							$scope.numOfValueMatches++;
							$scope.numOfDescriptionMatches++;
							$("#errpath-" + i + " td")[1].classList.add("markedValueDescElement");
						} else if (matchInValues) {
							$scope.numOfValueMatches++;
							$("#errpath-" + i + " td")[1].classList.add("markedValueElement");
						} else if (it.desc.indexOf(searchInput) !== -1) {
							$scope.numOfDescriptionMatches++;
							$("#errpath-" + i + " td")[1].classList.add("markedDescElement");
						}
					})
				}
			}
		};

		// Search for input in the description by using only words. A word is defined by a-zA-Z0-9 and underscore
		function searchInDescription(desc, searchInput) {
			var descStatements = desc.split(" ");
			for (var i = 0; i < descStatements.length; i++) {
				if (descStatements[i].replace(/[^\w.]/g, "") === searchInput) {
					return true;
				}
			}
			return false;
		}

		// Search for input in object, either exact match or a match containing the input
		function searchInValues(values, searchInput, exact) {
			if ($.isEmptyObject(values)) return false;
			var match;
			if (exact) {
				match = Object.keys(values).find(function (v) {
					return v === searchInput;
				})
			} else {
				match = Object.keys(values).find(function (v) {
					return v.indexOf(searchInput) !== -1;
				})
			}
			if (match) return true;
			else return false;
		}
	}]);

	var valueAssignmentsController = app.controller("ValueAssignmentsController", ['$rootScope', '$sce', '$scope', function ($rootScope, $sce, $scope) {
		$scope.showValues = function ($event) {
			var element = $event.currentTarget;
			if (element.classList.contains("markedTableElement")) {
				element.classList.remove("markedTableElement");
			} else {
				element.classList.add("markedTableElement");
			}
		};

		$scope.htmlTrusted = function(html) {
			return $sce.trustAsHtml(html);
		};
	}]);

	cfaToolbarController = app.controller('CFAToolbarController', ['$scope',
		function ($scope) {
			if (functions) {
				if (functions.length > 1) {
					$scope.functions = ["all"].concat(functions);
				} else {
					$scope.functions = functions;
				}
				$scope.selectedCFAFunction = $scope.functions[0];
				$scope.zoomEnabled = false;
			}


			$scope.setCFAFunction = function () {
				if ($scope.zoomEnabled) {
					$scope.zoomControl();
				}
				// FIXME: two-way binding does not update the selected option
				d3.selectAll("#cfa-toolbar option").attr("selected", null).attr("disabled", null);
				d3.select("#cfa-toolbar [label=" + $scope.selectedCFAFunction + "]").attr("selected", "selected").attr("disabled", true);
				if ($scope.selectedCFAFunction === "all") {
					functions.forEach(function (func) {
						d3.selectAll(".cfa-svg-" + func).attr("display", "inline-block");
					});
				} else {
					var funcToHide = $scope.functions.filter(function (it) {
						return it !== $scope.selectedCFAFunction && it !== "all";
					});
					funcToHide.forEach(function (func) {
						d3.selectAll(".cfa-svg-" + func).attr("display", "none");
					});
					d3.selectAll(".cfa-svg-" + $scope.selectedCFAFunction).attr("display", "inline-block");
				}
				var firstElRect = d3.select("[display=inline-block] .cfa-node:nth-child(2)").node().getBoundingClientRect();
				if (d3.select("#errorpath_section").style("display") !== "none") {
					$("#cfa-container").scrollTop(firstElRect.top + $("#cfa-container").scrollTop() - 300).scrollLeft(firstElRect.left - $("#cfa-container").scrollLeft() - d3.select("#externalFiles_section").style("width"));
				} else {
					$("#cfa-container").scrollTop(firstElRect.top + $("#cfa-container").scrollTop() - 300).scrollLeft(firstElRect.left - $("#cfa-container"));
				}
			};

			$scope.cfaFunctionIsSet = function (value) {
				return value === $scope.selectedCFAFunction;
			};

			$scope.zoomControl = function () {
				if ($scope.zoomEnabled) {
					$scope.zoomEnabled = false;
					d3.select("#cfa-zoom-button").html("<i class='far fa-square'></i>");
					// revert zoom and remove listeners
					d3.selectAll(".cfa-svg").each(function (d, i) {
						d3.select(this).on("zoom", null).on("wheel.zoom", null).on("dblclick.zoom", null).on("touchstart.zoom", null);
					});
				} else {
					$scope.zoomEnabled = true;
					d3.select("#cfa-zoom-button").html("<i class='far fa-check-square'></i>");
					d3.selectAll(".cfa-svg").each(function (d, i) {
						var svg = d3.select(this),
							svgGroup = d3.select(this.firstChild);
						var zoom = d3.zoom().on("zoom", function () {
							svgGroup.attr("transform", d3.event.transform);
						});
						svg.call(zoom);
						svg.on("dblclick.zoom", null).on("touchstart.zoom", null);
					});
				}
			};

			$scope.redraw = function () {
				var input = $("#cfa-split-threshold").val();
				if (!$scope.validateInput(input)) {
					alert("Invalid input!");
					return;
				}
				d3.selectAll(".cfa-graph").remove();
				if ($scope.zoomEnabled) {
					$scope.zoomControl();
				}
				$scope.selectedCFAFunction = $scope.functions[0];
				cfaSplit = true;
				var graphCount = 0;
				cfaJson.functionNames.forEach(function (f) {
					var fNodes = cfaJson.nodes.filter(function (n) {
						return n.func === f;
					})
					graphCount += Math.ceil(fNodes.length / input);
				});
				$("#cfa-modal").text("0/" + graphCount);
				graphCount = null;
				$("#renderStateModal").modal("show");
				if (cfaWorker === undefined) {
					cfaWorker = new Worker(URL.createObjectURL(new Blob(["(" + cfaWorker_function + ")()"], {
						type: "text/javascript"
					})));
				}
				cfaWorker.postMessage({
					"split": input
				});
				cfaWorker.postMessage({
					"renderer": "ready"
				});
			};

			$scope.validateInput = function (input) {
				if (input % 1 !== 0) return false;
				if (input < 500 || input > 900) return false;
				return true;
			}
		}
	]);

	var argToolbarController = app.controller('ARGToolbarController', ['$rootScope', '$scope',
		function ($rootScope, $scope) {
			$scope.zoomEnabled = false;
			$scope.argSelections = ["complete"];
			if (errorPath !== undefined) {
				$scope.argSelections.push("error path");
			}
			if (relevantEdges !== undefined) {
                        	$scope.argSelections.push("simplified");
                        }
			if (reducedEdges !== undefined) {
				$scope.argSelections.push("witness");
			}
			$rootScope.displayedARG = $scope.argSelections[0];

			$scope.displayARG = function () {
				if ($scope.argSelections.length > 1) {
					if ($rootScope.displayedARG.indexOf("error") !== -1) {
						d3.selectAll(".arg-graph").style("display", "none");
						if (!d3.select(".arg-simplified-graph").empty()) {
							d3.selectAll(".arg-simplified-graph").style("display", "none");
						}
						if (!d3.select(".arg-reduced-graph").empty()) {
							d3.selectAll(".arg-reduced-graph").style("display", "none");
						}
						$("#arg-container").scrollTop(0).scrollLeft(0);
						if (d3.select(".arg-error-graph").empty()) {
							argWorker.postMessage({
								"errorGraph": true
							});
						} else {
							d3.selectAll(".arg-error-graph").style("display", "inline-block").style("visibility", "visible");
						}
					} else if ($rootScope.displayedARG.indexOf("simplified") !== -1) {
					        d3.selectAll(".arg-graph").style("display", "none");
					        d3.selectAll(".arg-reduced-graph").style("display", "none");
					        $("#arg-container").scrollTop(0).scrollLeft(0);
					        if (!d3.select(".arg-error-graph").empty()) {
                                                	d3.selectAll(".arg-error-graph").style("display", "none");
                                                }
                                                if (d3.select(".arg-simplified-graph").empty()) {
                                                	argWorker.postMessage({
                                                	      "simplifiedGraph": true
                                                	});
                                                } else {
                                                        d3.selectAll(".arg-simplified-graph").style("display", "inline-block").style("visibility", "visible");
                                                }
					} else if ($rootScope.displayedARG.indexOf("witness") !== -1) {
						console.log("reduced graph selected");
						d3.selectAll(".arg-graph").style("display", "none");
						d3.selectAll(".arg-simplified-graph").style("display", "none");
						$("#arg-container").scrollTop(0).scrollLeft(0);
						if (!d3.select(".arg-error-graph").empty()) {
							d3.selectAll(".arg-error-graph").style("display", "none");
						}
						if (d3.select(".arg-reduced-graph").empty()) {
							argWorker.postMessage({
								"reducedGraph": true
							});
						} else {
							d3.selectAll(".arg-reduced-graph").style("display", "inline-block").style("visibility", "visible");
						}
					} else {
						if (!d3.select(".arg-error-graph").empty()) {
							d3.selectAll(".arg-error-graph").style("display", "none");
						}
						if (!d3.select(".arg-simplified-graph").empty()) {
                                                	d3.selectAll(".arg-simplified-graph").style("display", "none");
                                                }
						if (!d3.select(".arg-reduced-graph").empty()) {
							d3.selectAll(".arg-reduced-graph").style("display", "none");
						}
						d3.selectAll(".arg-graph").style("display", "inline-block").style("visibility", "visible");
						$("#arg-container").scrollLeft(d3.select(".arg-svg").attr("width") / 4);
					}
				}
			};

			$scope.argZoomControl = function () {
				if ($scope.zoomEnabled) {
					$scope.zoomEnabled = false;
					d3.select("#arg-zoom-button").html("<i class='far fa-square'></i>");
					// revert zoom and remove listeners
					d3.selectAll(".arg-svg").each(function (d, i) {
						d3.select(this).on("zoom", null).on("wheel.zoom", null).on("dblclick.zoom", null).on("touchstart.zoom", null);
					});
				} else {
					$scope.zoomEnabled = true;
					d3.select("#arg-zoom-button").html("<i class='far fa-check-square'></i>");
					d3.selectAll(".arg-svg").each(function (d, i) {
						var svg = d3.select(this),
							svgGroup = d3.select(this.firstChild);
						var zoom = d3.zoom().on("zoom", function () {
							svgGroup.attr("transform", d3.event.transform);
						});
						svg.call(zoom);
						svg.on("dblclick.zoom", null).on("touchstart.zoom", null);
					});
				}
			};

			$scope.argRedraw = function () {
				var input = $("#arg-split-threshold").val();
				if (!$scope.validateInput(input)) {
					alert("Invalid input!");
					return;
				}
				d3.selectAll(".arg-graph").remove();
				d3.selectAll(".arg-simplified-graph").remove();
				d3.selectAll(".arg-reduced-graph").remove();
				d3.selectAll(".arg-error-graph").remove();
				if ($scope.zoomEnabled) {
					$scope.argZoomControl();
				}
				var graphCount = Math.ceil(argJson.nodes.length / input);
				$("#arg-modal").text("0/" + graphCount);
				graphCount = null;
				$("#renderStateModal").modal("show");
				if (argWorker === undefined) {
					argWorker = new Worker(URL.createObjectURL(new Blob(["(" + argWorker_function + ")()"], {
						type: "text/javascript"
					})));
				}
				argWorker.postMessage({
					"split": input
				});
				argWorker.postMessage({
					"renderer": "ready"
				});
			};

			$scope.validateInput = function (input) {
				if (input % 1 !== 0) return false;
				if (input < 500 || input > 900) return false;
				return true;
			};
		}
	]);

	var sourceController = app.controller('SourceController', ['$rootScope', '$scope', '$location',
		'$anchorScroll',
		function ($rootScope, $scope, $location, $anchorScroll) {
			// available sourcefiles
			$scope.sourceFiles = sourceFiles;
			$scope.selectedSourceFile = 0;
			$scope.setSourceFile = function (value) {
				$scope.selectedSourceFile = value;
			};
			$scope.sourceFileIsSet = function (value) {
				return value === $scope.selectedSourceFile;
			};
		}
	]);

})();

var argJson = {
"nodes":[{"func":"main","index":0,"label":"0 @ N697\nmain entry\nAbstractionState: ABS0: true\\","type":"highlighted"},{"func":"gl_read","index":128,"label":"128 @ N566\ngl_read\n","type":""},{"func":"gl_read","index":129,"label":"129 @ N567\ngl_read\n","type":""},{"func":"gl_read","index":130,"label":"130 @ N570\ngl_read\n","type":""},{"func":"gl_read","index":131,"label":"131 @ N569\ngl_read\n","type":""},{"func":"gl_read","index":132,"label":"132 @ N568\ngl_read\n","type":""},{"func":"gl_read","index":134,"label":"134 @ N561\ngl_readAbstractionState: ABS8\\","type":"covered"},{"func":"gl_read","index":135,"label":"135 @ N572\ngl_read\n","type":""},{"func":"gl_read","index":136,"label":"136 @ N573\ngl_read\n","type":""},{"func":"gl_read","index":137,"label":"137 @ N556\ngl_read exit\n","type":""},{"func":"main","index":138,"label":"138 @ N701\nmain\n","type":""},{"func":"main","index":139,"label":"139 @ N702\nmain\n","type":""},{"func":"inspect","index":140,"label":"140 @ N17\ninspect entry\n","type":""},{"func":"inspect","index":141,"label":"141 @ N141\ninspect\n","type":""},{"func":"inspect","index":142,"label":"142 @ N143\ninspect\n","type":""},{"func":"inspect","index":143,"label":"143 @ N145\ninspect\n","type":""},{"func":"inspect","index":144,"label":"144 @ N146\ninspect\n","type":""},{"func":"inspect","index":145,"label":"145 @ N144\ninspect\n","type":""},{"func":"fail","index":146,"label":"146 @ N9\nfail entry\n","type":""},{"func":"fail","index":147,"label":"147 @ N10\nfail\n","type":""},{"func":"inspect","index":149,"label":"149 @ N149\ninspect\n","type":""},{"func":"inspect","index":150,"label":"150 @ N152\ninspect\n","type":""},{"func":"inspect","index":151,"label":"151 @ N154\ninspect\n","type":""},{"func":"inspect","index":152,"label":"152 @ N158\ninspect\n","type":""},{"func":"inspect","index":153,"label":"153 @ N160\ninspect\n","type":""},{"func":"inspect","index":154,"label":"154 @ N161\ninspect\n","type":""},{"func":"inspect","index":155,"label":"155 @ N159\ninspect\n","type":""},{"func":"fail","index":156,"label":"156 @ N9\nfail entry\n","type":""},{"func":"fail","index":157,"label":"157 @ N10\nfail\n","type":""},{"func":"inspect","index":159,"label":"159 @ N164\ninspect\n","type":""},{"func":"inspect","index":160,"label":"160 @ N167\ninspect\n","type":""},{"func":"inspect","index":161,"label":"161 @ N169\ninspect\n","type":""},{"func":"inspect","index":162,"label":"162 @ N175\ninspect\n","type":""},{"func":"inspect","index":163,"label":"163 @ N177\ninspect\n","type":""},{"func":"inspect","index":164,"label":"164 @ N178\ninspect\n","type":""},{"func":"inspect","index":165,"label":"165 @ N176\ninspect\n","type":"not-expanded"},{"func":"fail","index":166,"label":"166 @ N9\nfail entry\n","type":""},{"func":"fail","index":167,"label":"167 @ N10\nfail\n","type":""},{"func":"fail","index":169,"label":"169 @ N11\nfail\nAbstractionState: ABS11: true\\n AutomatonState: ErrorLabelAutomaton: _predefinedState_ERROR\\","type":"target"},{"func":"main","index":52,"label":"52 @ N709\nmain\n","type":""},{"func":"main","index":53,"label":"53 @ N700\nmain\n","type":""},{"func":"gl_read","index":54,"label":"54 @ N557\ngl_read entry\n","type":""},{"func":"gl_read","index":55,"label":"55 @ N560\ngl_read\n","type":""},{"func":"gl_read","index":104,"label":"104 @ N561\ngl_read\nAbstractionState: ABS7\\","type":"highlighted"},{"func":"gl_read","index":105,"label":"105 @ N562\ngl_read\n","type":""},{"func":"gl_read","index":106,"label":"106 @ N564\ngl_read\n","type":""},{"func":"gl_read","index":107,"label":"107 @ N565\ngl_read\n","type":""},{"func":"gl_insert","index":108,"label":"108 @ N510\ngl_insert entry\n","type":""},{"func":"gl_insert","index":109,"label":"109 @ N528\ngl_insert\n","type":""},{"func":"gl_insert","index":110,"label":"110 @ N530\ngl_insert\n","type":""},{"func":"gl_insert","index":111,"label":"111 @ N531\ngl_insert\n","type":""},{"func":"gl_insert","index":112,"label":"112 @ N529\ngl_insert\n","type":""},{"func":"gl_insert","index":113,"label":"113 @ N536\ngl_insert\n","type":""},{"func":"list_add","index":114,"label":"114 @ N489\nlist_add entry\n","type":""},{"func":"list_add","index":115,"label":"115 @ N492\nlist_add\n","type":""},{"func":"__list_add","index":116,"label":"116 @ N463\n__list_add entry\n","type":""},{"func":"__list_add","index":117,"label":"117 @ N476\n__list_add\n","type":""},{"func":"__list_add","index":118,"label":"118 @ N462\n__list_add exit\n","type":""},{"func":"list_add","index":119,"label":"119 @ N493\nlist_add\n","type":""},{"func":"list_add","index":120,"label":"120 @ N488\nlist_add exit\n","type":""},{"func":"gl_insert","index":121,"label":"121 @ N537\ngl_insert\n","type":""},{"func":"gl_insert","index":122,"label":"122 @ N539\ngl_insert\n","type":""},{"func":"gl_insert","index":123,"label":"123 @ N541\ngl_insert\n","type":""},{"func":"gl_insert","index":124,"label":"124 @ N551\ngl_insert\n","type":""},{"func":"gl_insert","index":125,"label":"125 @ N553\ngl_insert\n","type":""},{"func":"gl_insert","index":126,"label":"126 @ N554\ngl_insert\n","type":""},{"func":"gl_insert","index":127,"label":"127 @ N509\ngl_insert exit\n","type":""}],
"edges":[{"file":"test\/bs2.i","line":"653","source":120,"label":"Line 653\nReturn edge from list_add to gl_insert\n list_add(__cil_tmp7, &gl_list);","type":"FunctionReturnEdge","target":121},{"file":"test\/bs2.i","line":"689","source":130,"label":"Line 689\nGoto: while_19_break","type":"BlankEdge","target":135},{"file":"test\/bs2.i","line":"694","source":136,"label":"Line 694\nreturn;","type":"ReturnStatementEdge","target":137},{"file":"test\/bs2.i","line":"684","source":107,"label":"Line 684\ngl_insert(tmp)","type":"FunctionCallEdge","target":108},{"file":"<none>","line":"0","source":0,"label":"Line 0\nINIT GLOBAL VARS","type":"BlankEdge","target":52},{"file":"<none>","line":"0","source":146,"label":"Line 0\nFunction start dummy edge","type":"BlankEdge","target":147},{"file":"test\/bs2.i","line":"580","source":117,"label":"Line 580\nreturn;","type":"ReturnStatementEdge","target":118},{"file":"<none>","source":140,"label":"Lines 0 - 179:\nFunction start dummy edge\nconst struct node *node;\nunsigned int __cil_tmp3;\nstruct list_head *__cil_tmp4;\nunsigned int __cil_tmp5;\nint __cil_tmp6;\nunsigned int __cil_tmp7;\nunsigned int __cil_tmp8;\nunsigned int __cil_tmp9;\nstruct list_head *__cil_tmp10;\nunsigned int __cil_tmp11;\nint __cil_tmp12;\nunsigned int __cil_tmp13;\nunsigned int __cil_tmp14;\nstruct list_head *__cil_tmp15;\nunsigned int __cil_tmp16;\nstruct list_head *__cil_tmp17;\nunsigned int __cil_tmp18;\nint __cil_tmp19;\nunsigned int __cil_tmp20;\nunsigned int __cil_tmp21;\nunsigned int __cil_tmp22;\nstruct list_head *__cil_tmp23;\nunsigned int __cil_tmp24;\nint __cil_tmp25;\nstruct node *__cil_tmp26;\nunsigned int __cil_tmp27;\nunsigned int __cil_tmp28;\nstruct list_head *__cil_tmp29;\nunsigned long __cil_tmp30;\nchar *__cil_tmp31;\nchar *__cil_tmp32;\nstruct node *__cil_tmp33;\nunsigned int __cil_tmp34;\nunsigned int __cil_tmp35;\nconst struct list_head *__cil_tmp36;\nunsigned int __cil_tmp37;\nunsigned int __cil_tmp38;\nunsigned int __cil_tmp39;\nstruct list_head *__cil_tmp40;\nunsigned int __cil_tmp41;\nint __cil_tmp42;\nunsigned int __cil_tmp43;\nunsigned int __cil_tmp44;\nconst struct list_head *__cil_tmp45;\nunsigned int __cil_tmp46;\nunsigned int __cil_tmp47;\nunsigned int __cil_tmp48;\nunsigned int __cil_tmp49;\nstruct list_head *__cil_tmp50;\nunsigned int __cil_tmp51;\nint __cil_tmp52;\nunsigned int __cil_tmp53;\nunsigned int __cil_tmp54;\nconst struct list_head *__cil_tmp55;\nunsigned int __cil_tmp56;\nunsigned int __cil_tmp57;\nunsigned int __cil_tmp58;\nstruct list_head *__cil_tmp59;\nunsigned int __cil_tmp60;\nint __cil_tmp61;\nunsigned int __cil_tmp62;\nunsigned int __cil_tmp63;\nconst struct list_head *__cil_tmp64;\nunsigned int __cil_tmp65;\nunsigned int __cil_tmp66;\nunsigned int __cil_tmp67;\nunsigned int __cil_tmp68;\nstruct list_head *__cil_tmp69;\nunsigned int __cil_tmp70;\nint __cil_tmp71;\nconst struct node *__cil_tmp72;\nunsigned int __cil_tmp73;\nunsigned int __cil_tmp74;\nint __cil_tmp75;\nunsigned int __cil_tmp76;\nunsigned int __cil_tmp77;\nconst struct list_head *__cil_tmp78;\nconst struct node *__cil_tmp79;\nunsigned int __cil_tmp80;\nunsigned int __cil_tmp81;\nint __cil_tmp82;\nconst int *__cil_tmp83;\nconst struct node *__cil_tmp84;\nunsigned int __cil_tmp85;\nunsigned int __cil_tmp86;\nint __cil_tmp87;\nunsigned int __cil_tmp88;\nunsigned int __cil_tmp89;\nstruct list_head *__cil_tmp90;\nunsigned int __cil_tmp91;\nunsigned int __cil_tmp92;\nstruct list_head *__cil_tmp93;\nunsigned int __cil_tmp94;\nunsigned int __cil_tmp95;\nint __cil_tmp96;\nunsigned int __cil_tmp97;\nunsigned int __cil_tmp98;\nunsigned int __cil_tmp99;\nstruct list_head *__cil_tmp100;\nstruct list_head *__cil_tmp101;\nunsigned int __cil_tmp102;\nunsigned int __cil_tmp103;\nint __cil_tmp104;\nstruct list_head *__cil_tmp105;\nunsigned int __cil_tmp106;\nunsigned int __cil_tmp107;\nunsigned int __cil_tmp108;\nconst struct list_head *__cil_tmp109;\nunsigned int __cil_tmp110;\nstruct list_head *__cil_tmp111;\nunsigned int __cil_tmp112;\nstruct node *__cil_tmp113;\nunsigned int __cil_tmp114;\nunsigned int __cil_tmp115;\nstruct list_head *__cil_tmp116;\nunsigned long __cil_tmp117;\nchar *__cil_tmp118;\nchar *__cil_tmp119;\nstruct node *__cil_tmp120;\nunsigned int __cil_tmp121;\nint __cil_tmp122;\nwhile\n","type":"BlankEdge","lines":"0 - 179:","target":141},{"file":"<none>","line":"0","source":111,"label":"Line 0\n","type":"BlankEdge","target":112},{"file":"test\/bs2.i","line":"683","source":106,"label":"Line 683\ntmp = __VERIFIER_nondet_int();","type":"StatementEdge","target":107},{"file":"test\/bs2.i","line":"187","source":145,"label":"Line 187\nGoto: while_0_break","type":"BlankEdge","target":149},{"file":"<none>","source":116,"label":"Lines 0 - 579:\nFunction start dummy edge\nunsigned int __cil_tmp4;\nunsigned int __cil_tmp5;\nunsigned int __cil_tmp6;\nunsigned int __cil_tmp7;\n__cil_tmp4 = (unsigned int)next;\n__cil_tmp5 = __cil_tmp4 + 4;\n*((struct list_head **)__cil_tmp5) = new;\n*((struct list_head **)new) = next;\n__cil_tmp6 = (unsigned int)new;\n__cil_tmp7 = __cil_tmp6 + 4;\n*((struct list_head **)__cil_tmp7) = prev;\n*((struct list_head **)prev) = new;","type":"BlankEdge","lines":"0 - 579:","target":117},{"file":"test\/bs2.i","line":"206","source":155,"label":"Line 206\nGoto: while_1_break","type":"BlankEdge","target":159},{"file":"test\/bs2.i","line":"642","source":109,"label":"Line 642\n[!(node == 0)]","type":"AssumeEdge","target":111},{"file":"test\/bs2.i","line":"642","source":109,"label":"Line 642\n[node == 0]","type":"AssumeEdge","target":110},{"file":"test\/bs2.i","line":"672","source":126,"label":"Line 672\nreturn;","type":"ReturnStatementEdge","target":127},{"file":"<none>","line":"0","source":154,"label":"Line 0\n","type":"BlankEdge","target":155},{"file":"test\/bs2.i","line":"685","source":128,"label":"Line 685\ntmp___0 = __VERIFIER_nondet_int();","type":"StatementEdge","target":129},{"file":"test\/bs2.i","source":151,"label":"Lines 195 - 198:\n__cil_tmp3 = (unsigned int)head;\n__cil_tmp4 = *((struct list_head * const *)head);\n__cil_tmp5 = (unsigned int)__cil_tmp4;\n__cil_tmp6 = __cil_tmp5 != __cil_tmp3;","type":"StatementEdge","lines":"195 - 198:","target":152},{"file":"test\/bs2.i","line":"670","source":125,"label":"Line 670\nLabel: while_18_break","type":"BlankEdge","target":126},{"file":"test\/bs2.i","line":"687","source":129,"label":"Line 687\n[tmp___0 == 0]","type":"AssumeEdge","target":130},{"file":"test\/bs2.i","line":"657","source":122,"label":"Line 657\nLabel: while_18_continue","type":"BlankEdge","target":123},{"file":"test\/bs2.i","line":"687","source":129,"label":"Line 687\n[!(tmp___0 == 0)]","type":"AssumeEdge","target":131},{"file":"test\/bs2.i","line":"680","source":55,"label":"Line 680\nwhile","type":"BlankEdge","target":104},{"file":"<none>","line":"0","source":166,"label":"Line 0\nFunction start dummy edge","type":"BlankEdge","target":167},{"file":"test\/bs2.i","line":"839","source":137,"label":"Line 839\nReturn edge from gl_read to main\n gl_read();","type":"FunctionReturnEdge","target":138},{"file":"test\/bs2.i","line":"212","source":160,"label":"Line 212\nLabel: while_2_continue","type":"BlankEdge","target":161},{"file":"test\/bs2.i","line":"222","source":163,"label":"Line 222\nfail()","type":"FunctionCallEdge","target":166},{"file":"<none>","source":108,"label":"Lines 0 - 640:\nFunction start dummy edge\nstruct node *node;\nvoid *tmp;\nunsigned int __cil_tmp4;\nunsigned int __cil_tmp5;\nunsigned int __cil_tmp6;\nstruct list_head *__cil_tmp7;\nunsigned int __cil_tmp8;\nunsigned int __cil_tmp9;\nunsigned int __cil_tmp10;\nunsigned int __cil_tmp11;\nunsigned int __cil_tmp12;\nunsigned int __cil_tmp13;\nunsigned int __cil_tmp14;\nunsigned int __cil_tmp15;\n__cil_tmp4 = 20U;\ntmp = malloc(__cil_tmp4);\nnode = (struct node *)tmp;","type":"BlankEdge","lines":"0 - 640:","target":109},{"file":"<none>","line":"0","source":131,"label":"Line 0\n","type":"BlankEdge","target":132},{"source":134,"label":"covered by","type":"covered","target":104},{"file":"test\/bs2.i","line":"681","source":105,"label":"Line 681\nLabel: while_19_continue","type":"BlankEdge","target":106},{"file":"test\/bs2.i","source":149,"label":"Lines 189 - 192:\nLabel: while_0_break\nwhile\n","type":"BlankEdge","lines":"189 - 192:","target":150},{"file":"test\/bs2.i","line":"220","source":162,"label":"Line 220\n[!(__cil_tmp12 == 0)]","type":"AssumeEdge","target":164},{"file":"test\/bs2.i","line":"220","source":162,"label":"Line 220\n[__cil_tmp12 == 0]","type":"AssumeEdge","target":163},{"file":"test\/bs2.i","line":"680","source":104,"label":"Line 680\n","type":"BlankEdge","target":105},{"file":"test\/bs2.i","line":"183","source":143,"label":"Line 183\nfail()","type":"FunctionCallEdge","target":146},{"file":"<none>","source":114,"label":"Lines 0 - 598:\nFunction start dummy edge\nstruct list_head *__cil_tmp3;\n__cil_tmp3 = *((struct list_head **)head);","type":"BlankEdge","lines":"0 - 598:","target":115},{"file":"<none>","line":"0","source":132,"label":"Line 0\n","type":"BlankEdge","target":134},{"file":"<none>","source":54,"label":"Lines 0 - 677:\nFunction start dummy edge\nint tmp;\nint tmp___0;","type":"BlankEdge","lines":"0 - 677:","target":55},{"file":"test\/bs2.i","line":"181","source":142,"label":"Line 181\n[head == 0]","type":"AssumeEdge","target":143},{"file":"test\/bs2.i","line":"181","source":142,"label":"Line 181\n[!(head == 0)]","type":"AssumeEdge","target":144},{"file":"test\/bs2.i","line":"653","source":113,"label":"Line 653\nlist_add(__cil_tmp7, &gl_list)","type":"FunctionCallEdge","target":114},{"file":"test\/bs2.i","line":"199","source":152,"label":"Line 199\n[!(__cil_tmp6 == 0)]","type":"AssumeEdge","target":154},{"file":"test\/bs2.i","line":"199","source":152,"label":"Line 199\n[__cil_tmp6 == 0]","type":"AssumeEdge","target":153},{"file":"test\/bs2.i","source":123,"label":"Lines 658 - 667:\n__cil_tmp8 = (unsigned int)node;\n__cil_tmp9 = __cil_tmp8 + 12;\n__cil_tmp10 = (unsigned int)node;\n__cil_tmp11 = __cil_tmp10 + 12;\n*((struct list_head **)__cil_tmp9) = (struct list_head *)__cil_tmp11;\n__cil_tmp12 = (unsigned int)node;\n__cil_tmp13 = __cil_tmp12 + 12;\n__cil_tmp14 = (unsigned int)node;\n__cil_tmp15 = __cil_tmp14 + 12;\n*((struct list_head **)__cil_tmp13) = (struct list_head *)__cil_tmp15;","type":"StatementEdge","lines":"658 - 667:","target":124},{"file":"<none>","line":"0","source":144,"label":"Line 0\n","type":"BlankEdge","target":145},{"file":"test\/bs2.i","line":"599","source":118,"label":"Line 599\nReturn edge from __list_add to list_add\n __list_add(new, head, __cil_tmp3);","type":"FunctionReturnEdge","target":119},{"file":"test\/bs2.i","line":"599","source":115,"label":"Line 599\n__list_add(new, head, __cil_tmp3)","type":"FunctionCallEdge","target":116},{"file":"test\/bs2.i","line":"180","source":141,"label":"Line 180\nLabel: while_0_continue","type":"BlankEdge","target":142},{"file":"test\/bs2.i","line":"601","source":119,"label":"Line 601\nreturn;","type":"ReturnStatementEdge","target":120},{"file":"test\/bs2.i","source":112,"label":"Lines 649 - 652:\n*((int *)node) = value;\n__cil_tmp5 = (unsigned int)node;\n__cil_tmp6 = __cil_tmp5 + 4;\n__cil_tmp7 = (struct list_head *)__cil_tmp6;","type":"StatementEdge","lines":"649 - 652:","target":113},{"file":"test\/bs2.i","source":52,"label":"Lines 1 - 836:\nvoid abort();\nvoid __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function);\nvoid __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function);\nvoid __assert(const char *__assertion, const char *__file, int __line);\nvoid reach_error();\ntypedef unsigned int size_t;\nstruct list_head { struct list_head *next; struct list_head *prev; };\nstruct node { int value; struct list_head linkage; struct list_head nested; };\nvoid *malloc(size_t __size);\nvoid free(void *__ptr);\nint __VERIFIER_nondet_int();\nvoid fail();\nstruct list_head gl_list = { &gl_list, &gl_list };\nvoid inspect(const struct list_head *head);\nvoid __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);\nvoid __list_del(struct list_head *prev, struct list_head *next);\nvoid list_add(struct list_head *new, struct list_head *head);\nvoid list_move(struct list_head *list, struct list_head *head);\nvoid gl_insert(int value);\nvoid gl_read();\nvoid gl_destroy();\nint val_from_node(struct list_head *head);\n_Bool gl_sort_pass();\nvoid gl_sort();\nint main();\nFunction start dummy edge\nconst struct list_head *__cil_tmp1;\nconst struct list_head *__cil_tmp2;","type":"DeclarationEdge","lines":"1 - 836:","target":53},{"file":"test\/bs2.i","line":"46","source":167,"label":"Line 46\nLabel: ERROR","type":"BlankEdge","target":169},{"file":"test\/bs2.i","line":"840","source":138,"label":"Line 840\n__cil_tmp1 = (const struct list_head *)(&gl_list);","type":"StatementEdge","target":139},{"file":"<none>","line":"0","source":164,"label":"Line 0\n","type":"BlankEdge","target":165},{"file":"test\/bs2.i","source":161,"label":"Lines 214 - 219:\n__cil_tmp7 = (unsigned int)head;\n__cil_tmp8 = (unsigned int)head;\n__cil_tmp9 = __cil_tmp8 + 4;\n__cil_tmp10 = *((struct list_head * const *)__cil_tmp9);\n__cil_tmp11 = (unsigned int)__cil_tmp10;\n__cil_tmp12 = __cil_tmp11 != __cil_tmp7;","type":"StatementEdge","lines":"214 - 219:","target":162},{"file":"test\/bs2.i","line":"692","source":135,"label":"Line 692\nLabel: while_19_break","type":"BlankEdge","target":136},{"file":"test\/bs2.i","line":"201","source":153,"label":"Line 201\nfail()","type":"FunctionCallEdge","target":156},{"file":"<none>","line":"0","source":156,"label":"Line 0\nFunction start dummy edge","type":"BlankEdge","target":157},{"file":"test\/bs2.i","line":"684","source":127,"label":"Line 684\nReturn edge from gl_insert to gl_read\n gl_insert(tmp);","type":"FunctionReturnEdge","target":128},{"file":"test\/bs2.i","line":"193","source":150,"label":"Line 193\nLabel: while_1_continue","type":"BlankEdge","target":151},{"file":"test\/bs2.i","line":"668","source":124,"label":"Line 668\nGoto: while_18_break","type":"BlankEdge","target":125},{"file":"test\/bs2.i","source":121,"label":"Lines 656 - 656:\nwhile\n","type":"BlankEdge","lines":"656 - 656:","target":122},{"file":"test\/bs2.i","line":"841","source":139,"label":"Line 841\ninspect(__cil_tmp1)","type":"FunctionCallEdge","target":140},{"file":"test\/bs2.i","line":"839","source":53,"label":"Line 839\ngl_read()","type":"FunctionCallEdge","target":54},{"file":"test\/bs2.i","source":159,"label":"Lines 208 - 211:\nLabel: while_1_break\nwhile\n","type":"BlankEdge","lines":"208 - 211:","target":160}]
,
"relevantnodes":[{"func":"main","index":0,"label":"0 @ N697\nmain entry\nAbstractionState: ABS0: true\\","type":"highlighted"},{"func":"inspect","index":165,"label":"165 @ N176\ninspect\n","type":"not-expanded"},{"func":"gl_read","index":134,"label":"134 @ N561\ngl_read\nAbstractionState: ABS8\\","type":"not-expanded"},{"func":"fail","index":166,"label":"166 @ N9\nfail entry\n","type":""},{"func":"gl_read","index":104,"label":"104 @ N561\ngl_read\nAbstractionState: ABS7\\","type":"highlighted"},{"func":"gl_read","index":137,"label":"137 @ N556\ngl_read exit\n","type":""},{"func":"fail","index":169,"label":"169 @ N11\nfail\nAbstractionState: ABS11: true\\n AutomatonState: ErrorLabelAutomaton: _predefinedState_ERROR\\","type":"target"},{"func":"gl_insert","index":108,"label":"108 @ N510\ngl_insert entry\n","type":""},{"func":"inspect","index":140,"label":"140 @ N17\ninspect entry\n","type":""},{"func":"list_add","index":114,"label":"114 @ N489\nlist_add entry\n","type":""},{"func":"fail","index":146,"label":"146 @ N9\nfail entry\n","type":""},{"func":"__list_add","index":116,"label":"116 @ N463\n__list_add entry\n","type":""},{"func":"gl_read","index":54,"label":"54 @ N557\ngl_read entry\n","type":""},{"func":"__list_add","index":118,"label":"118 @ N462\n__list_add exit\n","type":""},{"func":"list_add","index":120,"label":"120 @ N488\nlist_add exit\n","type":""},{"func":"fail","index":156,"label":"156 @ N9\nfail entry\n","type":""},{"func":"gl_insert","index":127,"label":"127 @ N509\ngl_insert exit\n","type":""}],
"relevantedges":[{"source":108,"label":"dummy edge","type":"dummy type","target":114},{"file":"test\/bs2.i","source":104,"label":"Lines 680 - 684:\n\nLabel: while_19_continue\ntmp = __VERIFIER_nondet_int();\ngl_insert(tmp)","type":"BlankEdge","lines":"680 - 684:","target":108},{"source":120,"label":"dummy edge","type":"dummy type","target":127},{"source":140,"label":"dummy edge","type":"dummy type","target":146},{"source":127,"label":"dummy edge","type":"dummy type","target":134},{"source":140,"label":"dummy edge","type":"dummy type","target":156},{"file":"<none>","source":114,"label":"Lines 0 - 599:\nFunction start dummy edge\nstruct list_head *__cil_tmp3;\n__cil_tmp3 = *((struct list_head **)head);\n__list_add(new, head, __cil_tmp3)","type":"BlankEdge","lines":"0 - 599:","target":116},{"source":127,"label":"dummy edge","type":"dummy type","target":137},{"source":140,"label":"dummy edge","type":"dummy type","target":166},{"file":"test\/bs2.i","source":137,"label":"Lines 839 - 841:\nReturn edge from gl_read to main\n gl_read();\n__cil_tmp1 = (const struct list_head *)(&gl_list);\ninspect(__cil_tmp1)","type":"FunctionReturnEdge","lines":"839 - 841:","target":140},{"source":140,"label":"dummy edge","type":"dummy type","target":165},{"file":"<none>","source":166,"label":"Lines 0 - 46:\nFunction start dummy edge\nLabel: ERROR","type":"BlankEdge","lines":"0 - 46:","target":169},{"file":"<none>","source":116,"label":"Lines 0 - 580:\nFunction start dummy edge\nunsigned int __cil_tmp4;\nunsigned int __cil_tmp5;\nunsigned int __cil_tmp6;\nunsigned int __cil_tmp7;\n__cil_tmp4 = (unsigned int)next;\n__cil_tmp5 = __cil_tmp4 + 4;\n*((struct list_head **)__cil_tmp5) = new;\n*((struct list_head **)new) = next;\n__cil_tmp6 = (unsigned int)new;\n__cil_tmp7 = __cil_tmp6 + 4;\n*((struct list_head **)__cil_tmp7) = prev;\n*((struct list_head **)prev) = new;\nreturn;","type":"BlankEdge","lines":"0 - 580:","target":118},{"file":"test\/bs2.i","source":118,"label":"Lines 599 - 601:\nReturn edge from __list_add to list_add\n __list_add(new, head, __cil_tmp3);\nreturn;","type":"FunctionReturnEdge","lines":"599 - 601:","target":120},{"file":"<none>","source":54,"label":"Lines 0 - 680:\nFunction start dummy edge\nint tmp;\nint tmp___0;\nwhile","type":"BlankEdge","lines":"0 - 680:","target":104},{"file":"<none>","source":0,"label":"Lines 0 - 839:\nINIT GLOBAL VARS\nvoid abort();\nvoid __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function);\nvoid __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function);\nvoid __assert(const char *__assertion, const char *__file, int __line);\nvoid reach_error();\ntypedef unsigned int size_t;\nstruct list_head { struct list_head *next; struct list_head *prev; };\nstruct node { int value; struct list_head linkage; struct list_head nested; };\nvoid *malloc(size_t __size);\nvoid free(void *__ptr);\nint __VERIFIER_nondet_int();\nvoid fail();\nstruct list_head gl_list = { &gl_list, &gl_list };\nvoid inspect(const struct list_head *head);\nvoid __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);\nvoid __list_del(struct list_head *prev, struct list_head *next);\nvoid list_add(struct list_head *new, struct list_head *head);\nvoid list_move(struct list_head *list, struct list_head *head);\nvoid gl_insert(int value);\nvoid gl_read();\nvoid gl_destroy();\nint val_from_node(struct list_head *head);\n_Bool gl_sort_pass();\nvoid gl_sort();\nint main();\nFunction start dummy edge\nconst struct list_head *__cil_tmp1;\nconst struct list_head *__cil_tmp2;\ngl_read()","type":"BlankEdge","lines":"0 - 839:","target":54}]
}

var sourceFiles = ["test\/bs2.i"];
var cfaJson = {
"functionNames":["main","__list_add","__list_del","fail","gl_destroy","gl_insert","gl_read","gl_sort","gl_sort_pass","inspect","list_add","list_move","reach_error","val_from_node"],
"functionCallEdges":{"192":[100027,194],"705":[100008,706],"706":[100009,707],"326":[100020,328],"455":[100014,457],"264":[100023,266],"11":[100011,12],"395":[100016,397],"207":[100026,209],"145":[100030,147],"341":[100019,343],"662":[100002,666],"536":[100032,537],"667":[100003,668],"285":[100022,287],"414":[100015,416],"224":[100025,226],"160":[100029,162],"675":[100004,676],"359":[100018,361],"492":[100031,493],"687":[100001,688],"305":[100021,307],"177":[100028,179],"244":[100024,246],"565":[100010,566],"375":[100017,377],"505":[100012,506],"506":[100013,507],"700":[100005,701],"702":[100006,703],"703":[100007,704]},
"combinedNodes":{"641":[642,643,644,645,646,647,648,649,650,651,652,653,654],"2":[3,6,7,4],"265":[263,268,269],"12":[13,14],"396":[394,399,400],"271":[273,274,275,276,277,278,279,280,281,282],"18":[19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139],"146":[144,149,150],"402":[404,405,406,407,408,409,410,411],"659":[660],"533":[534,535],"664":[677,678],"152":[154,155,156,157],"539":[541,542,543,544,545,546,547,548,549,550,551,553,554],"286":[284,289,290],"415":[413,418,419,420,421],"672":[670],"161":[159,164,165],"292":[294,295,296,297,298,299,300,301,302],"167":[169,170,171,172,173,174],"423":[425,426,427,428,429],"682":[683],"558":[559,560],"432":[431,435,436],"433":[437,438],"690":[689],"562":[564],"178":[176,181,182,183,184,185,186],"306":[304,309,310],"693":[694],"312":[314,315,316,317,318,319,320,321,322,323],"440":[442,443,444,445,446,447,448,449,450,451,452],"569":[568],"572":[573],"577":[578,579,580,581,582,583,584,585,586,587,588,589,590,591],"193":[191,196,197],"709":[710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,698,699],"199":[201,202,203,204],"327":[325,330,331],"456":[454,459,460],"333":[335,336,337,338],"463":[464,465,466,467,468,469,470,471,472,473,474,475,476],"208":[206,211,212],"593":[595,596,597,598],"214":[216,217,218,219,220,221],"342":[340,345,346],"600":[604,605,606,607,608,609,610,611,612,613,614,615],"602":[616,617],"348":[350,351,352,353,354,355,356],"480":[481,482,483,484,485,486],"225":[223,228,229,230,231,232,233,234,235,236,237,238],"360":[358,363,364],"490":[491],"621":[622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637],"366":[368,369,370,371,372],"497":[498,499,500,501,502,503,504],"245":[243,248,249],"376":[374,379,380],"251":[253,254,255,256,257,258,259,260,261],"382":[384,385,386,387,388,389,390,391,392],"511":[512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527]},
"combinedNodesLabels":{"641":"641 _Bool any_change;\n642 struct list_head *pos0;\n643 struct list_head *pos1;\n644 int val0;\n645 int tmp;\n646 int val1;\n647 int tmp___0;\n648 struct list_head *__cil_tmp8;\n649 unsigned int __cil_tmp9;\n650 unsigned int __cil_tmp10;\n651 any_change = 0;\n652 __cil_tmp8 = &gl_list;\n653 pos0 = *((struct list_head **)__cil_tmp8);\n654 while","2":"2 4UL;\n3 \n6 __assert_fail(\"0\", \"bubble_sort-2.c\", 3, \"__PRETTY_FUNCTION__\");\n7 \n4 default return","265":"265 \n263 Goto: while_7_break\n268 Label: while_7_break\n269 while","12":"12 abort();\n13 __assert_fail(\"0\", \"test-0180.c\", 11, \"__PRETTY_FUNCTION__\");\n14 Goto: ERROR","396":"396 \n394 Goto: while_14_break\n399 Label: while_14_break\n400 while","271":"271 Label: while_8_continue\n273 __cil_tmp43 = (unsigned int)node;\n274 __cil_tmp44 = __cil_tmp43 + 12;\n275 __cil_tmp45 = (const struct list_head *)__cil_tmp44;\n276 __cil_tmp46 = (unsigned int)__cil_tmp45;\n277 __cil_tmp47 = 16;\n278 __cil_tmp48 = (unsigned int)node;\n279 __cil_tmp49 = __cil_tmp48 + __cil_tmp47;\n280 __cil_tmp50 = *((struct list_head * const *)__cil_tmp49);\n281 __cil_tmp51 = (unsigned int)__cil_tmp50;\n282 __cil_tmp52 = __cil_tmp51 == __cil_tmp46;","18":"18 const struct node *node;\n19 unsigned int __cil_tmp3;\n20 struct list_head *__cil_tmp4;\n21 unsigned int __cil_tmp5;\n22 int __cil_tmp6;\n23 unsigned int __cil_tmp7;\n24 unsigned int __cil_tmp8;\n25 unsigned int __cil_tmp9;\n26 struct list_head *__cil_tmp10;\n27 unsigned int __cil_tmp11;\n28 int __cil_tmp12;\n29 unsigned int __cil_tmp13;\n30 unsigned int __cil_tmp14;\n31 struct list_head *__cil_tmp15;\n32 unsigned int __cil_tmp16;\n33 struct list_head *__cil_tmp17;\n34 unsigned int __cil_tmp18;\n35 int __cil_tmp19;\n36 unsigned int __cil_tmp20;\n37 unsigned int __cil_tmp21;\n38 unsigned int __cil_tmp22;\n39 struct list_head *__cil_tmp23;\n40 unsigned int __cil_tmp24;\n41 int __cil_tmp25;\n42 struct node *__cil_tmp26;\n43 unsigned int __cil_tmp27;\n44 unsigned int __cil_tmp28;\n45 struct list_head *__cil_tmp29;\n46 unsigned long __cil_tmp30;\n47 char *__cil_tmp31;\n48 char *__cil_tmp32;\n49 struct node *__cil_tmp33;\n50 unsigned int __cil_tmp34;\n51 unsigned int __cil_tmp35;\n52 const struct list_head *__cil_tmp36;\n53 unsigned int __cil_tmp37;\n54 unsigned int __cil_tmp38;\n55 unsigned int __cil_tmp39;\n56 struct list_head *__cil_tmp40;\n57 unsigned int __cil_tmp41;\n58 int __cil_tmp42;\n59 unsigned int __cil_tmp43;\n60 unsigned int __cil_tmp44;\n61 const struct list_head *__cil_tmp45;\n62 unsigned int __cil_tmp46;\n63 unsigned int __cil_tmp47;\n64 unsigned int __cil_tmp48;\n65 unsigned int __cil_tmp49;\n66 struct list_head *__cil_tmp50;\n67 unsigned int __cil_tmp51;\n68 int __cil_tmp52;\n69 unsigned int __cil_tmp53;\n70 unsigned int __cil_tmp54;\n71 const struct list_head *__cil_tmp55;\n72 unsigned int __cil_tmp56;\n73 unsigned int __cil_tmp57;\n74 unsigned int __cil_tmp58;\n75 struct list_head *__cil_tmp59;\n76 unsigned int __cil_tmp60;\n77 int __cil_tmp61;\n78 unsigned int __cil_tmp62;\n79 unsigned int __cil_tmp63;\n80 const struct list_head *__cil_tmp64;\n81 unsigned int __cil_tmp65;\n82 unsigned int __cil_tmp66;\n83 unsigned int __cil_tmp67;\n84 unsigned int __cil_tmp68;\n85 struct list_head *__cil_tmp69;\n86 unsigned int __cil_tmp70;\n87 int __cil_tmp71;\n88 const struct node *__cil_tmp72;\n89 unsigned int __cil_tmp73;\n90 unsigned int __cil_tmp74;\n91 int __cil_tmp75;\n92 unsigned int __cil_tmp76;\n93 unsigned int __cil_tmp77;\n94 const struct list_head *__cil_tmp78;\n95 const struct node *__cil_tmp79;\n96 unsigned int __cil_tmp80;\n97 unsigned int __cil_tmp81;\n98 int __cil_tmp82;\n99 const int *__cil_tmp83;\n100 const struct node *__cil_tmp84;\n101 unsigned int __cil_tmp85;\n102 unsigned int __cil_tmp86;\n103 int __cil_tmp87;\n104 unsigned int __cil_tmp88;\n105 unsigned int __cil_tmp89;\n106 struct list_head *__cil_tmp90;\n107 unsigned int __cil_tmp91;\n108 unsigned int __cil_tmp92;\n109 struct list_head *__cil_tmp93;\n110 unsigned int __cil_tmp94;\n111 unsigned int __cil_tmp95;\n112 int __cil_tmp96;\n113 unsigned int __cil_tmp97;\n114 unsigned int __cil_tmp98;\n115 unsigned int __cil_tmp99;\n116 struct list_head *__cil_tmp100;\n117 struct list_head *__cil_tmp101;\n118 unsigned int __cil_tmp102;\n119 unsigned int __cil_tmp103;\n120 int __cil_tmp104;\n121 struct list_head *__cil_tmp105;\n122 unsigned int __cil_tmp106;\n123 unsigned int __cil_tmp107;\n124 unsigned int __cil_tmp108;\n125 const struct list_head *__cil_tmp109;\n126 unsigned int __cil_tmp110;\n127 struct list_head *__cil_tmp111;\n128 unsigned int __cil_tmp112;\n129 struct node *__cil_tmp113;\n130 unsigned int __cil_tmp114;\n131 unsigned int __cil_tmp115;\n132 struct list_head *__cil_tmp116;\n133 unsigned long __cil_tmp117;\n134 char *__cil_tmp118;\n135 char *__cil_tmp119;\n136 struct node *__cil_tmp120;\n137 unsigned int __cil_tmp121;\n138 int __cil_tmp122;\n139 while","146":"146 \n144 Goto: while_0_break\n149 Label: while_0_break\n150 while","402":"402 Label: while_15_continue\n404 __cil_tmp97 = 8;\n405 __cil_tmp98 = (unsigned int)node;\n406 __cil_tmp99 = __cil_tmp98 + __cil_tmp97;\n407 __cil_tmp100 = *((struct list_head * const *)__cil_tmp99);\n408 __cil_tmp101 = *((struct list_head **)__cil_tmp100);\n409 __cil_tmp102 = (unsigned int)__cil_tmp101;\n410 __cil_tmp103 = (unsigned int)head;\n411 __cil_tmp104 = __cil_tmp103 == __cil_tmp102;","659":"659 __cil_tmp9 = (unsigned int)pos1;\n660 __cil_tmp10 = (unsigned int)(&gl_list);","533":"533 __cil_tmp5 = (unsigned int)node;\n534 __cil_tmp6 = __cil_tmp5 + 4;\n535 __cil_tmp7 = (struct list_head *)__cil_tmp6;","664":"664 Goto: while_21_break\n677 Label: while_21_break\n678 return any_change;","152":"152 Label: while_1_continue\n154 __cil_tmp3 = (unsigned int)head;\n155 __cil_tmp4 = *((struct list_head * const *)head);\n156 __cil_tmp5 = (unsigned int)__cil_tmp4;\n157 __cil_tmp6 = __cil_tmp5 != __cil_tmp3;","539":"539 Label: while_18_continue\n541 __cil_tmp8 = (unsigned int)node;\n542 __cil_tmp9 = __cil_tmp8 + 12;\n543 __cil_tmp10 = (unsigned int)node;\n544 __cil_tmp11 = __cil_tmp10 + 12;\n545 *((struct list_head **)__cil_tmp9) = (struct list_head *)__cil_tmp11;\n546 __cil_tmp12 = (unsigned int)node;\n547 __cil_tmp13 = __cil_tmp12 + 12;\n548 __cil_tmp14 = (unsigned int)node;\n549 __cil_tmp15 = __cil_tmp14 + 12;\n550 *((struct list_head **)__cil_tmp13) = (struct list_head *)__cil_tmp15;\n551 Goto: while_18_break\n553 Label: while_18_break\n554 return;","286":"286 \n284 Goto: while_8_break\n289 Label: while_8_break\n290 while","415":"415 \n413 Goto: while_15_break\n418 Label: while_15_break\n419 __cil_tmp105 = *((struct list_head * const *)head);\n420 head = (const struct list_head *)__cil_tmp105;\n421 while","672":"672 \n670 any_change = 1;","161":"161 \n159 Goto: while_1_break\n164 Label: while_1_break\n165 while","292":"292 Label: while_9_continue\n294 __cil_tmp53 = (unsigned int)node;\n295 __cil_tmp54 = __cil_tmp53 + 4;\n296 __cil_tmp55 = (const struct list_head *)__cil_tmp54;\n297 __cil_tmp56 = (unsigned int)__cil_tmp55;\n298 __cil_tmp57 = (unsigned int)node;\n299 __cil_tmp58 = __cil_tmp57 + 12;\n300 __cil_tmp59 = *((struct list_head * const *)__cil_tmp58);\n301 __cil_tmp60 = (unsigned int)__cil_tmp59;\n302 __cil_tmp61 = __cil_tmp60 != __cil_tmp56;","167":"167 Label: while_2_continue\n169 __cil_tmp7 = (unsigned int)head;\n170 __cil_tmp8 = (unsigned int)head;\n171 __cil_tmp9 = __cil_tmp8 + 4;\n172 __cil_tmp10 = *((struct list_head * const *)__cil_tmp9);\n173 __cil_tmp11 = (unsigned int)__cil_tmp10;\n174 __cil_tmp12 = __cil_tmp11 != __cil_tmp7;","423":"423 Label: while_16_continue\n425 __cil_tmp106 = (unsigned int)head;\n426 __cil_tmp107 = (unsigned int)node;\n427 __cil_tmp108 = __cil_tmp107 + 4;\n428 __cil_tmp109 = (const struct list_head *)__cil_tmp108;\n429 __cil_tmp110 = (unsigned int)__cil_tmp109;","682":"682 _Bool tmp;\n683 while","558":"558 int tmp;\n559 int tmp___0;\n560 while","432":"432 \n431 __cil_tmp111 = *((struct list_head * const *)head);\n435 head = (const struct list_head *)__cil_tmp111;\n436 ","433":"433 Goto: while_16_break\n437 Label: while_16_break\n438 while","690":"690 \n689 ","562":"562 Label: while_19_continue\n564 tmp = __VERIFIER_nondet_int();","178":"178 \n176 Goto: while_2_break\n181 Label: while_2_break\n182 __cil_tmp13 = (unsigned int)head;\n183 __cil_tmp14 = __cil_tmp13 + 4;\n184 __cil_tmp15 = *((struct list_head * const *)__cil_tmp14);\n185 head = (const struct list_head *)__cil_tmp15;\n186 while","306":"306 \n304 Goto: while_9_break\n309 Label: while_9_break\n310 while","693":"693 Label: while_22_break\n694 return;","312":"312 Label: while_10_continue\n314 __cil_tmp62 = (unsigned int)node;\n315 __cil_tmp63 = __cil_tmp62 + 4;\n316 __cil_tmp64 = (const struct list_head *)__cil_tmp63;\n317 __cil_tmp65 = (unsigned int)__cil_tmp64;\n318 __cil_tmp66 = 16;\n319 __cil_tmp67 = (unsigned int)node;\n320 __cil_tmp68 = __cil_tmp67 + __cil_tmp66;\n321 __cil_tmp69 = *((struct list_head * const *)__cil_tmp68);\n322 __cil_tmp70 = (unsigned int)__cil_tmp69;\n323 __cil_tmp71 = __cil_tmp70 != __cil_tmp65;","440":"440 Label: while_17_continue\n442 __cil_tmp112 = (unsigned int)node;\n443 __cil_tmp113 = (struct node *)0;\n444 __cil_tmp114 = (unsigned int)__cil_tmp113;\n445 __cil_tmp115 = __cil_tmp114 + 4;\n446 __cil_tmp116 = (struct list_head *)__cil_tmp115;\n447 __cil_tmp117 = (unsigned long)__cil_tmp116;\n448 __cil_tmp118 = (char *)head;\n449 __cil_tmp119 = __cil_tmp118 - __cil_tmp117;\n450 __cil_tmp120 = (struct node *)__cil_tmp119;\n451 __cil_tmp121 = (unsigned int)__cil_tmp120;\n452 __cil_tmp122 = __cil_tmp121 == __cil_tmp112;","569":"569 \n568 ","572":"572 Label: while_19_break\n573 return;","577":"577 struct list_head *next;\n578 struct list_head *__cil_tmp2;\n579 unsigned int __cil_tmp3;\n580 unsigned int __cil_tmp4;\n581 struct list_head *__cil_tmp5;\n582 struct node *__cil_tmp6;\n583 unsigned int __cil_tmp7;\n584 unsigned int __cil_tmp8;\n585 struct list_head *__cil_tmp9;\n586 unsigned long __cil_tmp10;\n587 char *__cil_tmp11;\n588 char *__cil_tmp12;\n589 struct node *__cil_tmp13;\n590 void *__cil_tmp14;\n591 while","193":"193 \n191 Goto: while_3_break\n196 Label: while_3_break\n197 while","709":"709 void abort();\n710 void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function);\n711 void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function);\n712 void __assert(const char *__assertion, const char *__file, int __line);\n713 void reach_error();\n714 typedef unsigned int size_t;\n715 struct list_head {\n  struct list_head *next;\n  struct list_head *prev;\n} ;\n716 struct node {\n  int value;\n  struct list_head linkage;\n  struct list_head nested;\n} ;\n717 void *malloc(size_t __size);\n718 void free(void *__ptr);\n719 int __VERIFIER_nondet_int();\n720 void fail();\n721 struct list_head gl_list = { &gl_list, &gl_list };\n722 void inspect(const struct list_head *head);\n723 void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);\n724 void __list_del(struct list_head *prev, struct list_head *next);\n725 void list_add(struct list_head *new, struct list_head *head);\n726 void list_move(struct list_head *list, struct list_head *head);\n727 void gl_insert(int value);\n728 void gl_read();\n729 void gl_destroy();\n730 int val_from_node(struct list_head *head);\n731 _Bool gl_sort_pass();\n732 void gl_sort();\n733 int main();\n734 Function start dummy edge\n698 const struct list_head *__cil_tmp1;\n699 const struct list_head *__cil_tmp2;","199":"199 Label: while_4_continue\n201 __cil_tmp16 = (unsigned int)head;\n202 __cil_tmp17 = *((struct list_head * const *)head);\n203 __cil_tmp18 = (unsigned int)__cil_tmp17;\n204 __cil_tmp19 = __cil_tmp18 != __cil_tmp16;","327":"327 \n325 Goto: while_10_break\n330 Label: while_10_break\n331 while","456":"456 \n454 Goto: while_17_break\n459 Label: while_17_break\n460 return;","333":"333 Label: while_11_continue\n335 __cil_tmp72 = (const struct node *)head;\n336 __cil_tmp73 = (unsigned int)__cil_tmp72;\n337 __cil_tmp74 = (unsigned int)node;\n338 __cil_tmp75 = __cil_tmp74 != __cil_tmp73;","463":"463 Function start dummy edge\n464 unsigned int __cil_tmp4;\n465 unsigned int __cil_tmp5;\n466 unsigned int __cil_tmp6;\n467 unsigned int __cil_tmp7;\n468 __cil_tmp4 = (unsigned int)next;\n469 __cil_tmp5 = __cil_tmp4 + 4;\n470 *((struct list_head **)__cil_tmp5) = new;\n471 *((struct list_head **)new) = next;\n472 __cil_tmp6 = (unsigned int)new;\n473 __cil_tmp7 = __cil_tmp6 + 4;\n474 *((struct list_head **)__cil_tmp7) = prev;\n475 *((struct list_head **)prev) = new;\n476 return;","208":"208 \n206 Goto: while_4_break\n211 Label: while_4_break\n212 while","593":"593 Label: while_20_continue\n595 __cil_tmp2 = &gl_list;\n596 next = *((struct list_head **)__cil_tmp2);\n597 __cil_tmp3 = (unsigned int)next;\n598 __cil_tmp4 = (unsigned int)(&gl_list);","214":"214 Label: while_5_continue\n216 __cil_tmp20 = (unsigned int)head;\n217 __cil_tmp21 = (unsigned int)head;\n218 __cil_tmp22 = __cil_tmp21 + 4;\n219 __cil_tmp23 = *((struct list_head * const *)__cil_tmp22);\n220 __cil_tmp24 = (unsigned int)__cil_tmp23;\n221 __cil_tmp25 = __cil_tmp24 != __cil_tmp20;","342":"342 \n340 Goto: while_11_break\n345 Label: while_11_break\n346 while","600":"600 __cil_tmp5 = &gl_list;\n604 *((struct list_head **)__cil_tmp5) = *((struct list_head **)next);\n605 __cil_tmp6 = (struct node *)0;\n606 __cil_tmp7 = (unsigned int)__cil_tmp6;\n607 __cil_tmp8 = __cil_tmp7 + 4;\n608 __cil_tmp9 = (struct list_head *)__cil_tmp8;\n609 __cil_tmp10 = (unsigned long)__cil_tmp9;\n610 __cil_tmp11 = (char *)next;\n611 __cil_tmp12 = __cil_tmp11 - __cil_tmp10;\n612 __cil_tmp13 = (struct node *)__cil_tmp12;\n613 __cil_tmp14 = (void *)__cil_tmp13;\n614 free(__cil_tmp14);\n615 ","602":"602 Goto: while_20_break\n616 Label: while_20_break\n617 return;","348":"348 Label: while_12_continue\n350 __cil_tmp76 = (unsigned int)node;\n351 __cil_tmp77 = __cil_tmp76 + 4;\n352 __cil_tmp78 = (const struct list_head *)__cil_tmp77;\n353 __cil_tmp79 = (const struct node *)__cil_tmp78;\n354 __cil_tmp80 = (unsigned int)__cil_tmp79;\n355 __cil_tmp81 = (unsigned int)node;\n356 __cil_tmp82 = __cil_tmp81 != __cil_tmp80;","480":"480 unsigned int __cil_tmp3;\n481 unsigned int __cil_tmp4;\n482 __cil_tmp3 = (unsigned int)next;\n483 __cil_tmp4 = __cil_tmp3 + 4;\n484 *((struct list_head **)__cil_tmp4) = prev;\n485 *((struct list_head **)prev) = next;\n486 return;","225":"225 \n223 Goto: while_5_break\n228 Label: while_5_break\n229 __cil_tmp26 = (struct node *)0;\n230 __cil_tmp27 = (unsigned int)__cil_tmp26;\n231 __cil_tmp28 = __cil_tmp27 + 4;\n232 __cil_tmp29 = (struct list_head *)__cil_tmp28;\n233 __cil_tmp30 = (unsigned long)__cil_tmp29;\n234 __cil_tmp31 = (char *)head;\n235 __cil_tmp32 = __cil_tmp31 - __cil_tmp30;\n236 __cil_tmp33 = (struct node *)__cil_tmp32;\n237 node = (const struct node *)__cil_tmp33;\n238 while","360":"360 \n358 Goto: while_12_break\n363 Label: while_12_break\n364 while","490":"490 struct list_head *__cil_tmp3;\n491 __cil_tmp3 = *((struct list_head **)head);","621":"621 struct node *entry;\n622 struct node *__cil_tmp3;\n623 unsigned int __cil_tmp4;\n624 unsigned int __cil_tmp5;\n625 struct list_head *__cil_tmp6;\n626 unsigned long __cil_tmp7;\n627 char *__cil_tmp8;\n628 char *__cil_tmp9;\n629 __cil_tmp3 = (struct node *)0;\n630 __cil_tmp4 = (unsigned int)__cil_tmp3;\n631 __cil_tmp5 = __cil_tmp4 + 4;\n632 __cil_tmp6 = (struct list_head *)__cil_tmp5;\n633 __cil_tmp7 = (unsigned long)__cil_tmp6;\n634 __cil_tmp8 = (char *)head;\n635 __cil_tmp9 = __cil_tmp8 - __cil_tmp7;\n636 entry = (struct node *)__cil_tmp9;\n637 return *((int *)entry);","366":"366 Label: while_13_continue\n368 __cil_tmp83 = (const int *)node;\n369 __cil_tmp84 = (const struct node *)__cil_tmp83;\n370 __cil_tmp85 = (unsigned int)__cil_tmp84;\n371 __cil_tmp86 = (unsigned int)node;\n372 __cil_tmp87 = __cil_tmp86 == __cil_tmp85;","497":"497 unsigned int __cil_tmp3;\n498 unsigned int __cil_tmp4;\n499 struct list_head *__cil_tmp5;\n500 struct list_head *__cil_tmp6;\n501 __cil_tmp3 = (unsigned int)list;\n502 __cil_tmp4 = __cil_tmp3 + 4;\n503 __cil_tmp5 = *((struct list_head **)__cil_tmp4);\n504 __cil_tmp6 = *((struct list_head **)list);","245":"245 \n243 Goto: while_6_break\n248 Label: while_6_break\n249 while","376":"376 \n374 Goto: while_13_break\n379 Label: while_13_break\n380 while","251":"251 Label: while_7_continue\n253 __cil_tmp34 = (unsigned int)node;\n254 __cil_tmp35 = __cil_tmp34 + 12;\n255 __cil_tmp36 = (const struct list_head *)__cil_tmp35;\n256 __cil_tmp37 = (unsigned int)__cil_tmp36;\n257 __cil_tmp38 = (unsigned int)node;\n258 __cil_tmp39 = __cil_tmp38 + 12;\n259 __cil_tmp40 = *((struct list_head * const *)__cil_tmp39);\n260 __cil_tmp41 = (unsigned int)__cil_tmp40;\n261 __cil_tmp42 = __cil_tmp41 == __cil_tmp37;","382":"382 Label: while_14_continue\n384 __cil_tmp88 = (unsigned int)node;\n385 __cil_tmp89 = __cil_tmp88 + 4;\n386 __cil_tmp90 = *((struct list_head * const *)__cil_tmp89);\n387 __cil_tmp91 = (unsigned int)__cil_tmp90;\n388 __cil_tmp92 = __cil_tmp91 + 4;\n389 __cil_tmp93 = *((struct list_head **)__cil_tmp92);\n390 __cil_tmp94 = (unsigned int)__cil_tmp93;\n391 __cil_tmp95 = (unsigned int)head;\n392 __cil_tmp96 = __cil_tmp95 == __cil_tmp94;","511":"511 struct node *node;\n512 void *tmp;\n513 unsigned int __cil_tmp4;\n514 unsigned int __cil_tmp5;\n515 unsigned int __cil_tmp6;\n516 struct list_head *__cil_tmp7;\n517 unsigned int __cil_tmp8;\n518 unsigned int __cil_tmp9;\n519 unsigned int __cil_tmp10;\n520 unsigned int __cil_tmp11;\n521 unsigned int __cil_tmp12;\n522 unsigned int __cil_tmp13;\n523 unsigned int __cil_tmp14;\n524 unsigned int __cil_tmp15;\n525 __cil_tmp4 = 20U;\n526 tmp = malloc(__cil_tmp4);\n527 node = (struct node *)tmp;"},
"mergedNodes":[464,465,466,467,468,469,470,471,472,473,474,475,476,3,6,7,4,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,683,689,694,642,643,644,645,646,647,648,649,650,651,652,653,654,660,677,678,670,481,482,483,484,485,486,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,698,699,559,560,564,568,573,578,579,580,581,582,583,584,585,586,587,588,589,590,591,595,596,597,598,616,617,604,605,606,607,608,609,610,611,612,613,614,615,13,14,498,499,500,501,502,503,504,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,144,149,150,154,155,156,157,159,164,165,169,170,171,172,173,174,176,181,182,183,184,185,186,191,196,197,201,202,203,204,206,211,212,216,217,218,219,220,221,223,228,229,230,231,232,233,234,235,236,237,238,243,248,249,253,254,255,256,257,258,259,260,261,263,268,269,273,274,275,276,277,278,279,280,281,282,284,289,290,294,295,296,297,298,299,300,301,302,304,309,310,314,315,316,317,318,319,320,321,322,323,325,330,331,335,336,337,338,340,345,346,350,351,352,353,354,355,356,358,363,364,368,369,370,371,372,374,379,380,384,385,386,387,388,389,390,391,392,394,399,400,404,405,406,407,408,409,410,411,413,418,419,420,421,425,426,427,428,429,437,438,442,443,444,445,446,447,448,449,450,451,452,454,459,460,431,435,436,491,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,534,535,541,542,543,544,545,546,547,548,549,550,551,553,554],
"errorPath":[{"val":"","file":"<none>","importance":0,"line":0,"additional":"","argelem":0,"source":697,"faults":[],"target":709,"desc":"INIT GLOBAL VARS"},{"val":"","file":"test\/bs2.i","importance":0,"line":1,"additional":"","argelem":52,"source":709,"faults":[],"target":710,"desc":"void abort();"},{"val":"","file":"test\/bs2.i","importance":0,"line":3,"additional":"","source":710,"faults":[],"target":711,"desc":"void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function);"},{"val":"","file":"test\/bs2.i","importance":0,"line":6,"additional":"","source":711,"faults":[],"target":712,"desc":"void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function);"},{"val":"","file":"test\/bs2.i","importance":0,"line":9,"additional":"","source":712,"faults":[],"target":713,"desc":"void __assert(const char *__assertion, const char *__file, int __line);"},{"val":"","file":"test\/bs2.i","importance":0,"line":12,"additional":"","source":713,"faults":[],"target":714,"desc":"void reach_error();"},{"val":"","file":"test\/bs2.i","importance":0,"line":25,"additional":"","source":714,"faults":[],"target":715,"desc":"typedef unsigned int size_t;"},{"val":"","file":"test\/bs2.i","importance":0,"line":30,"additional":"","source":715,"faults":[],"target":716,"desc":"struct list_head {   struct list_head *next;   struct list_head *prev; } ;"},{"val":"","file":"test\/bs2.i","importance":0,"line":34,"additional":"","source":716,"faults":[],"target":717,"desc":"struct node {   int value;   struct list_head linkage;   struct list_head nested; } ;"},{"val":"","file":"test\/bs2.i","importance":0,"line":39,"additional":"","source":717,"faults":[],"target":718,"desc":"void *malloc(size_t __size);"},{"val":"","file":"test\/bs2.i","importance":0,"line":40,"additional":"","source":718,"faults":[],"target":719,"desc":"void free(void *__ptr);"},{"val":"","file":"test\/bs2.i","importance":0,"line":42,"additional":"","source":719,"faults":[],"target":720,"desc":"int __VERIFIER_nondet_int();"},{"val":"","file":"test\/bs2.i","importance":0,"line":43,"additional":"","source":720,"faults":[],"target":721,"desc":"void fail();"},{"val":"(&gl_list) == 4LL;\n","file":"test\/bs2.i","importance":1,"line":52,"additional":"","source":721,"faults":[],"target":722,"desc":"struct list_head gl_list = { &gl_list, &gl_list };"},{"val":"","file":"test\/bs2.i","importance":0,"line":54,"additional":"","source":722,"faults":[],"target":723,"desc":"void inspect(const struct list_head *head);"},{"val":"","file":"test\/bs2.i","importance":0,"line":566,"additional":"","source":723,"faults":[],"target":724,"desc":"void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);"},{"val":"","file":"test\/bs2.i","importance":0,"line":583,"additional":"","source":724,"faults":[],"target":725,"desc":"void __list_del(struct list_head *prev, struct list_head *next);"},{"val":"","file":"test\/bs2.i","importance":0,"line":594,"additional":"","source":725,"faults":[],"target":726,"desc":"void list_add(struct list_head *new, struct list_head *head);"},{"val":"","file":"test\/bs2.i","importance":0,"line":604,"additional":"","source":726,"faults":[],"target":727,"desc":"void list_move(struct list_head *list, struct list_head *head);"},{"val":"","file":"test\/bs2.i","importance":0,"line":621,"additional":"","source":727,"faults":[],"target":728,"desc":"void gl_insert(int value);"},{"val":"","file":"test\/bs2.i","importance":0,"line":675,"additional":"","source":728,"faults":[],"target":729,"desc":"void gl_read();"},{"val":"","file":"test\/bs2.i","importance":0,"line":697,"additional":"","source":729,"faults":[],"target":730,"desc":"void gl_destroy();"},{"val":"","file":"test\/bs2.i","importance":0,"line":746,"additional":"","source":730,"faults":[],"target":731,"desc":"int val_from_node(struct list_head *head);"},{"val":"","file":"test\/bs2.i","importance":0,"line":767,"additional":"","source":731,"faults":[],"target":732,"desc":"_Bool gl_sort_pass();"},{"val":"","file":"test\/bs2.i","importance":0,"line":815,"additional":"","source":732,"faults":[],"target":733,"desc":"void gl_sort();"},{"val":"","file":"test\/bs2.i","importance":0,"line":834,"additional":"","source":733,"faults":[],"target":734,"desc":"int main();"},{"val":"","file":"<none>","importance":0,"line":0,"additional":"","source":734,"faults":[],"target":698,"desc":"Function start dummy edge"},{"val":"","file":"test\/bs2.i","importance":0,"line":835,"additional":"","source":698,"faults":[],"target":699,"desc":"const struct list_head *__cil_tmp1;"},{"val":"","file":"test\/bs2.i","importance":0,"line":836,"additional":"","source":699,"faults":[],"target":700,"desc":"const struct list_head *__cil_tmp2;"},{"val":"","file":"test\/bs2.i","importance":1,"line":839,"additional":"","argelem":53,"source":700,"faults":[],"target":557,"desc":"gl_read()"},{"val":"","file":"<none>","importance":0,"line":0,"additional":"","argelem":54,"source":557,"faults":[],"target":558,"desc":"Function start dummy edge"},{"val":"","file":"test\/bs2.i","importance":0,"line":676,"additional":"","source":558,"faults":[],"target":559,"desc":"int tmp;"},{"val":"","file":"test\/bs2.i","importance":0,"line":677,"additional":"","source":559,"faults":[],"target":560,"desc":"int tmp___0;"},{"val":"","file":"test\/bs2.i","importance":1,"line":680,"additional":"","argelem":55,"source":560,"faults":[],"target":561,"desc":"while"},{"val":"","file":"test\/bs2.i","importance":0,"line":680,"additional":"","argelem":104,"source":561,"faults":[],"target":562,"desc":""},{"val":"","file":"test\/bs2.i","importance":0,"line":681,"additional":"","argelem":105,"source":562,"faults":[],"target":564,"desc":"Label: while_19_continue"},{"val":"tmp == 3;\n","file":"test\/bs2.i","importance":0,"line":683,"additional":"","argelem":106,"source":564,"faults":[],"target":565,"desc":"tmp = __VERIFIER_nondet_int();"},{"val":"","file":"test\/bs2.i","importance":1,"line":684,"additional":"","argelem":107,"source":565,"faults":[],"target":510,"desc":"gl_insert(tmp)"},{"val":"value == 3;\n","file":"<none>","importance":0,"line":0,"additional":"","argelem":108,"source":510,"faults":[],"target":511,"desc":"Function start dummy edge"},{"val":"value == 3;\n","file":"test\/bs2.i","importance":0,"line":622,"additional":"","source":511,"faults":[],"target":512,"desc":"struct node *node;"},{"val":"","file":"test\/bs2.i","importance":0,"line":623,"additional":"","source":512,"faults":[],"target":513,"desc":"void *tmp;"},{"val":"","file":"test\/bs2.i","importance":0,"line":624,"additional":"","source":513,"faults":[],"target":514,"desc":"unsigned int __cil_tmp4;"},{"val":"","file":"test\/bs2.i","importance":0,"line":625,"additional":"","source":514,"faults":[],"target":515,"desc":"unsigned int __cil_tmp5;"},{"val":"","file":"test\/bs2.i","importance":0,"line":626,"additional":"","source":515,"faults":[],"target":516,"desc":"unsigned int __cil_tmp6;"},{"val":"","file":"test\/bs2.i","importance":0,"line":627,"additional":"","source":516,"faults":[],"target":517,"desc":"struct list_head *__cil_tmp7;"},{"val":"","file":"test\/bs2.i","importance":0,"line":628,"additional":"","source":517,"faults":[],"target":518,"desc":"unsigned int __cil_tmp8;"},{"val":"","file":"test\/bs2.i","importance":0,"line":629,"additional":"","source":518,"faults":[],"target":519,"desc":"unsigned int __cil_tmp9;"},{"val":"","file":"test\/bs2.i","importance":0,"line":630,"additional":"","source":519,"faults":[],"target":520,"desc":"unsigned int __cil_tmp10;"},{"val":"","file":"test\/bs2.i","importance":0,"line":631,"additional":"","source":520,"faults":[],"target":521,"desc":"unsigned int __cil_tmp11;"},{"val":"","file":"test\/bs2.i","importance":0,"line":632,"additional":"","source":521,"faults":[],"target":522,"desc":"unsigned int __cil_tmp12;"},{"val":"","file":"test\/bs2.i","importance":0,"line":633,"additional":"","source":522,"faults":[],"target":523,"desc":"unsigned int __cil_tmp13;"},{"val":"","file":"test\/bs2.i","importance":0,"line":634,"additional":"","source":523,"faults":[],"target":524,"desc":"unsigned int __cil_tmp14;"},{"val":"","file":"test\/bs2.i","importance":0,"line":635,"additional":"","source":524,"faults":[],"target":525,"desc":"unsigned int __cil_tmp15;"},{"val":"__cil_tmp4 == 20U;\n","file":"test\/bs2.i","importance":0,"line":638,"additional":"","source":525,"faults":[],"target":526,"desc":"__cil_tmp4 = 20U;"},{"val":"tmp == 28LL;\n","file":"test\/bs2.i","importance":1,"line":639,"additional":"","source":526,"faults":[],"target":527,"desc":"tmp = malloc(__cil_tmp4);"},{"val":"value == 3;\nnode == 28LL;\n(&(node->linkage)) == 32LL;\n(&(node->nested)) == 40LL;\ntmp == 28LL;\n__cil_tmp4 == 20U;\n","file":"test\/bs2.i","importance":1,"line":640,"additional":"","source":527,"faults":[],"target":528,"desc":"node = (struct node *)tmp;"},{"val":"node == 28LL;\n(&(node->linkage)) == 32LL;\n(&(node->nested)) == 40LL;\nnode == 28LL;\n(&(node->linkage)) == 32LL;\n(&(node->nested)) == 40LL;","file":"test\/bs2.i","importance":1,"line":642,"additional":"","argelem":109,"source":528,"faults":[],"target":531,"desc":"[!(node == 0)]"},{"val":"","file":"<none>","importance":0,"line":0,"additional":"","argelem":111,"source":531,"faults":[],"target":529,"desc":""},{"val":"(*((int *)node)) == 3;\n","file":"test\/bs2.i","importance":0,"line":649,"additional":"","argelem":112,"source":529,"faults":[],"target":533,"desc":"*((int *)node) = value;"},{"val":"__cil_tmp5 == 28U;\n","file":"test\/bs2.i","importance":0,"line":650,"additional":"","source":533,"faults":[],"target":534,"desc":"__cil_tmp5 = (unsigned int)node;"},{"val":"__cil_tmp6 == 32U;\n","file":"test\/bs2.i","importance":0,"line":651,"additional":"","source":534,"faults":[],"target":535,"desc":"__cil_tmp6 = __cil_tmp5 + 4;"},{"val":"(*((int *)node)) == 3;\n__cil_tmp5 == 28U;\n__cil_tmp6 == 32U;\n__cil_tmp7 == 32LL;\n","file":"test\/bs2.i","importance":0,"line":652,"additional":"","source":535,"faults":[],"target":536,"desc":"__cil_tmp7 = (struct list_head *)__cil_tmp6;"},{"val":"","file":"test\/bs2.i","importance":1,"line":653,"additional":"","argelem":113,"source":536,"faults":[],"target":489,"desc":"list_add(__cil_tmp7, &gl_list)"},{"val":"new == 32LL;\nhead == 4LL;\n","file":"<none>","importance":0,"line":0,"additional":"","argelem":114,"source":489,"faults":[],"target":490,"desc":"Function start dummy edge"},{"val":"new == 32LL;\nhead == 4LL;\n","file":"test\/bs2.i","importance":0,"line":595,"additional":"","source":490,"faults":[],"target":491,"desc":"struct list_head *__cil_tmp3;"},{"val":"new == 32LL;\nhead == 4LL;\n(head->prev) == 4LL;\n__cil_tmp3 == 0LL;\n","file":"test\/bs2.i","importance":0,"line":598,"additional":"","source":491,"faults":[],"target":492,"desc":"__cil_tmp3 = *((struct list_head **)head);"},{"val":"","file":"test\/bs2.i","importance":1,"line":599,"additional":"","argelem":115,"source":492,"faults":[],"target":463,"desc":"__list_add(new, head, __cil_tmp3)"},{"val":"new == 32LL;\nprev == 4LL;\n(prev->prev) == 4LL;\nnext == 0LL;\n","file":"<none>","importance":0,"line":0,"additional":"","argelem":116,"source":463,"faults":[],"target":464,"desc":"Function start dummy edge"},{"val":"new == 32LL;\nprev == 4LL;\n(prev->prev) == 4LL;\nnext == 0LL;\n","file":"test\/bs2.i","importance":0,"line":567,"additional":"","source":464,"faults":[],"target":465,"desc":"unsigned int __cil_tmp4;"},{"val":"","file":"test\/bs2.i","importance":0,"line":568,"additional":"","source":465,"faults":[],"target":466,"desc":"unsigned int __cil_tmp5;"},{"val":"","file":"test\/bs2.i","importance":0,"line":569,"additional":"","source":466,"faults":[],"target":467,"desc":"unsigned int __cil_tmp6;"},{"val":"","file":"test\/bs2.i","importance":0,"line":570,"additional":"","source":467,"faults":[],"target":468,"desc":"unsigned int __cil_tmp7;"},{"val":"__cil_tmp4 == 0U;\n","file":"test\/bs2.i","importance":0,"line":572,"additional":"","source":468,"faults":[],"target":469,"desc":"__cil_tmp4 = (unsigned int)next;"},{"val":"__cil_tmp5 == 4U;\n","file":"test\/bs2.i","importance":0,"line":573,"additional":"","source":469,"faults":[],"target":470,"desc":"__cil_tmp5 = __cil_tmp4 + 4;"},{"val":"(*((struct list_head **)__cil_tmp5)) == 32LL;\n","file":"test\/bs2.i","importance":0,"line":574,"additional":"","source":470,"faults":[],"target":471,"desc":"*((struct list_head **)__cil_tmp5) = new;"},{"val":"(*((struct list_head **)new)) == 0LL;\n((*((struct list_head **)new))->prev) == 32LL;\n((*((struct list_head **)new))->prev->next) == 0LL;\n","file":"test\/bs2.i","importance":0,"line":575,"additional":"","source":471,"faults":[],"target":472,"desc":"*((struct list_head **)new) = next;"},{"val":"__cil_tmp6 == 32U;\n","file":"test\/bs2.i","importance":0,"line":576,"additional":"","source":472,"faults":[],"target":473,"desc":"__cil_tmp6 = (unsigned int)new;"},{"val":"__cil_tmp7 == 36U;\n","file":"test\/bs2.i","importance":0,"line":577,"additional":"","source":473,"faults":[],"target":474,"desc":"__cil_tmp7 = __cil_tmp6 + 4;"},{"val":"(*((struct list_head **)__cil_tmp7)) == 4LL;\n((*((struct list_head **)__cil_tmp7))->next) == 32LL;\n((*((struct list_head **)__cil_tmp7))->next->next) == 0LL;\n((*((struct list_head **)__cil_tmp7))->next->prev) == 4LL;\n((*((struct list_head **)__cil_tmp7))->prev) == 4LL;\n","file":"test\/bs2.i","importance":0,"line":578,"additional":"","source":474,"faults":[],"target":475,"desc":"*((struct list_head **)__cil_tmp7) = prev;"},{"val":"new == 32LL;\n(new->next) == 0LL;\n(new->next->prev) == 32LL;\n(new->prev) == 4LL;\n(new->prev->prev) == 4LL;\nprev == 4LL;\n(prev->next) == 32LL;\n(prev->next->next) == 0LL;\n(prev->next->prev) == 4LL;\n(prev->prev) == 4LL;\nnext == 0LL;\n(next->prev) == 32LL;\n(next->prev->next) == 0LL;\n(next->prev->prev) == 4LL;\n(next->prev->prev->prev) == 4LL;\n__cil_tmp4 == 0U;\n__cil_tmp5 == 4U;\n__cil_tmp6 == 32U;\n__cil_tmp7 == 36U;\n(*((struct list_head **)__cil_tmp5)) == 32LL;\n((*((struct list_head **)__cil_tmp5))->next) == 0LL;\n((*((struct list_head **)__cil_tmp5))->next->prev) == 32LL;\n((*((struct list_head **)__cil_tmp5))->prev) == 4LL;\n((*((struct list_head **)__cil_tmp5))->prev->prev) == 4LL;\n(*((struct list_head **)new)) == 0LL;\n((*((struct list_head **)new))->prev) == 32LL;\n((*((struct list_head **)new))->prev->next) == 0LL;\n((*((struct list_head **)new))->prev->prev) == 4LL;\n((*((struct list_head **)new))->prev->prev->prev) == 4LL;\n(*((struct list_head **)__cil_tmp7)) == 4LL;\n((*((struct list_head **)__cil_tmp7))->next) == 32LL;\n((*((struct list_head **)__cil_tmp7))->next->next) == 0LL;\n((*((struct list_head **)__cil_tmp7))->next->prev) == 4LL;\n((*((struct list_head **)__cil_tmp7))->prev) == 4LL;\n(*((struct list_head **)prev)) == 32LL;\n((*((struct list_head **)prev))->next) == 0LL;\n((*((struct list_head **)prev))->next->prev) == 32LL;\n((*((struct list_head **)prev))->prev) == 4LL;\n((*((struct list_head **)prev))->prev->prev) == 4LL;\n","file":"test\/bs2.i","importance":0,"line":579,"additional":"","source":475,"faults":[],"target":476,"desc":"*((struct list_head **)prev) = new;"},{"val":"","file":"test\/bs2.i","importance":0,"line":580,"additional":"","argelem":117,"source":476,"faults":[],"target":462,"desc":"return;"},{"val":"","file":"test\/bs2.i","importance":0,"line":599,"additional":"","argelem":118,"source":462,"faults":[],"target":493,"desc":"Return edge from __list_add to list_add: __list_add(new, head, __cil_tmp3);"},{"val":"","file":"test\/bs2.i","importance":0,"line":601,"additional":"","argelem":119,"source":493,"faults":[],"target":488,"desc":"return;"},{"val":"","file":"test\/bs2.i","importance":0,"line":653,"additional":"","argelem":120,"source":488,"faults":[],"target":537,"desc":"Return edge from list_add to gl_insert: list_add(__cil_tmp7, &gl_list);"},{"val":"","file":"test\/bs2.i","importance":1,"line":656,"additional":"","argelem":121,"source":537,"faults":[],"target":538,"desc":"while"},{"val":"","file":"test\/bs2.i","importance":0,"line":656,"additional":"","source":538,"faults":[],"target":539,"desc":""},{"val":"","file":"test\/bs2.i","importance":0,"line":657,"additional":"","argelem":122,"source":539,"faults":[],"target":541,"desc":"Label: while_18_continue"},{"val":"__cil_tmp8 == 28U;\n","file":"test\/bs2.i","importance":0,"line":658,"additional":"","argelem":123,"source":541,"faults":[],"target":542,"desc":"__cil_tmp8 = (unsigned int)node;"},{"val":"__cil_tmp9 == 40U;\n","file":"test\/bs2.i","importance":0,"line":659,"additional":"","source":542,"faults":[],"target":543,"desc":"__cil_tmp9 = __cil_tmp8 + 12;"},{"val":"__cil_tmp10 == 28U;\n","file":"test\/bs2.i","importance":0,"line":660,"additional":"","source":543,"faults":[],"target":544,"desc":"__cil_tmp10 = (unsigned int)node;"},{"val":"__cil_tmp11 == 40U;\n","file":"test\/bs2.i","importance":0,"line":661,"additional":"","source":544,"faults":[],"target":545,"desc":"__cil_tmp11 = __cil_tmp10 + 12;"},{"val":"(*((struct list_head **)__cil_tmp9)) == 40LL;\n((*((struct list_head **)__cil_tmp9))->next) == 40LL;\n","file":"test\/bs2.i","importance":0,"line":662,"additional":"","source":545,"faults":[],"target":546,"desc":"*((struct list_head **)__cil_tmp9) = (struct list_head *)__cil_tmp11;"},{"val":"__cil_tmp12 == 28U;\n","file":"test\/bs2.i","importance":0,"line":663,"additional":"","source":546,"faults":[],"target":547,"desc":"__cil_tmp12 = (unsigned int)node;"},{"val":"__cil_tmp13 == 40U;\n","file":"test\/bs2.i","importance":0,"line":664,"additional":"","source":547,"faults":[],"target":548,"desc":"__cil_tmp13 = __cil_tmp12 + 12;"},{"val":"__cil_tmp14 == 28U;\n","file":"test\/bs2.i","importance":0,"line":665,"additional":"","source":548,"faults":[],"target":549,"desc":"__cil_tmp14 = (unsigned int)node;"},{"val":"__cil_tmp15 == 40U;\n","file":"test\/bs2.i","importance":0,"line":666,"additional":"","source":549,"faults":[],"target":550,"desc":"__cil_tmp15 = __cil_tmp14 + 12;"},{"val":"__cil_tmp8 == 28U;\n__cil_tmp9 == 40U;\n__cil_tmp10 == 28U;\n__cil_tmp11 == 40U;\n(*((struct list_head **)__cil_tmp9)) == 40LL;\n((*((struct list_head **)__cil_tmp9))->next) == 40LL;\n__cil_tmp12 == 28U;\n__cil_tmp13 == 40U;\n__cil_tmp14 == 28U;\n__cil_tmp15 == 40U;\n(*((struct list_head **)__cil_tmp13)) == 40LL;\n((*((struct list_head **)__cil_tmp13))->next) == 40LL;\n","file":"test\/bs2.i","importance":0,"line":667,"additional":"","source":550,"faults":[],"target":551,"desc":"*((struct list_head **)__cil_tmp13) = (struct list_head *)__cil_tmp15;"},{"val":"","file":"test\/bs2.i","importance":0,"line":668,"additional":"","argelem":124,"source":551,"faults":[],"target":553,"desc":"Goto: while_18_break"},{"val":"","file":"test\/bs2.i","importance":0,"line":670,"additional":"","argelem":125,"source":553,"faults":[],"target":554,"desc":"Label: while_18_break"},{"val":"","file":"test\/bs2.i","importance":0,"line":672,"additional":"","argelem":126,"source":554,"faults":[],"target":509,"desc":"return;"},{"val":"","file":"test\/bs2.i","importance":0,"line":684,"additional":"","argelem":127,"source":509,"faults":[],"target":566,"desc":"Return edge from gl_insert to gl_read: gl_insert(tmp);"},{"val":"tmp___0 == 0;\n","file":"test\/bs2.i","importance":1,"line":685,"additional":"","argelem":128,"source":566,"faults":[],"target":567,"desc":"tmp___0 = __VERIFIER_nondet_int();"},{"val":"tmp___0 == 0;\ntmp___0 == 0;","file":"test\/bs2.i","importance":1,"line":687,"additional":"","argelem":129,"source":567,"faults":[],"target":570,"desc":"[tmp___0 == 0]"},{"val":"","file":"test\/bs2.i","importance":0,"line":689,"additional":"","argelem":130,"source":570,"faults":[],"target":572,"desc":"Goto: while_19_break"},{"val":"","file":"test\/bs2.i","importance":0,"line":692,"additional":"","argelem":135,"source":572,"faults":[],"target":573,"desc":"Label: while_19_break"},{"val":"","file":"test\/bs2.i","importance":0,"line":694,"additional":"","argelem":136,"source":573,"faults":[],"target":556,"desc":"return;"},{"val":"","file":"test\/bs2.i","importance":0,"line":839,"additional":"","argelem":137,"source":556,"faults":[],"target":701,"desc":"Return edge from gl_read to main: gl_read();"},{"val":"__cil_tmp1 == 4LL;\n(__cil_tmp1->next) == 32LL;\n(__cil_tmp1->next->next) == 0LL;\n(__cil_tmp1->next->prev) == 4LL;\n(__cil_tmp1->next->prev->prev) == 4LL;\n","file":"test\/bs2.i","importance":1,"line":840,"additional":"<br><br><strong>Additional information provided:<\/strong><br>Error suspected on line(s): <strong>840<\/strong><br><br> Relevant lines:\n<ul class=\"fault-lines\">\n<li><span class=\"line-number\">840<\/span><span class=\"line-content\">__cil_tmp1 = (const struct list_head *)(&gl_list);<\/span><\/li><\/ul>\nFound <strong>1<\/strong> possible bug-fix:<br><ul id=\"fix-list\"><li>Try to change the assigned value of \"__cil_tmp1\" in \"__cil_tmp1 = (const struct list_head *)(&gl_list);\" to another value.<\/li><\/ul><br>","argelem":138,"source":701,"faults":[0],"target":702,"desc":"__cil_tmp1 = (const struct list_head *)(&gl_list);"},{"val":"","file":"test\/bs2.i","importance":1,"line":841,"additional":"<br><br><strong>Additional information provided:<\/strong><br>Error suspected on line(s): <strong>841<\/strong><br><br> Relevant lines:\n<ul class=\"fault-lines\">\n<li><span class=\"line-number\">841<\/span><span class=\"line-content\">inspect(__cil_tmp1)<\/span><\/li><\/ul>\nFound <strong>1<\/strong> possible bug-fix:<br><ul id=\"fix-list\"><li>The function call \"inspect(__cil_tmp1)\" may have unwanted side effects or a wrong return value.<\/li><\/ul><br>","argelem":139,"source":702,"faults":[0],"target":17,"desc":"inspect(__cil_tmp1)"},{"val":"head == 4LL;\n(head->next) == 32LL;\n(head->next->next) == 0LL;\n(head->next->prev) == 4LL;\n(head->next->prev->prev) == 4LL;\n","file":"<none>","importance":0,"line":0,"additional":"","argelem":140,"source":17,"faults":[],"target":18,"desc":"Function start dummy edge"},{"val":"head == 4LL;\n(head->next) == 32LL;\n(head->next->next) == 0LL;\n(head->next->prev) == 4LL;\n(head->next->prev->prev) == 4LL;\n","file":"test\/bs2.i","importance":0,"line":55,"additional":"","source":18,"faults":[],"target":19,"desc":"const struct node *node;"},{"val":"","file":"test\/bs2.i","importance":0,"line":56,"additional":"","source":19,"faults":[],"target":20,"desc":"unsigned int __cil_tmp3;"},{"val":"","file":"test\/bs2.i","importance":0,"line":57,"additional":"","source":20,"faults":[],"target":21,"desc":"struct list_head *__cil_tmp4;"},{"val":"","file":"test\/bs2.i","importance":0,"line":58,"additional":"","source":21,"faults":[],"target":22,"desc":"unsigned int __cil_tmp5;"},{"val":"","file":"test\/bs2.i","importance":0,"line":59,"additional":"","source":22,"faults":[],"target":23,"desc":"int __cil_tmp6;"},{"val":"","file":"test\/bs2.i","importance":0,"line":60,"additional":"","source":23,"faults":[],"target":24,"desc":"unsigned int __cil_tmp7;"},{"val":"","file":"test\/bs2.i","importance":0,"line":61,"additional":"","source":24,"faults":[],"target":25,"desc":"unsigned int __cil_tmp8;"},{"val":"","file":"test\/bs2.i","importance":0,"line":62,"additional":"","source":25,"faults":[],"target":26,"desc":"unsigned int __cil_tmp9;"},{"val":"","file":"test\/bs2.i","importance":0,"line":63,"additional":"","source":26,"faults":[],"target":27,"desc":"struct list_head *__cil_tmp10;"},{"val":"","file":"test\/bs2.i","importance":0,"line":64,"additional":"","source":27,"faults":[],"target":28,"desc":"unsigned int __cil_tmp11;"},{"val":"","file":"test\/bs2.i","importance":0,"line":65,"additional":"","source":28,"faults":[],"target":29,"desc":"int __cil_tmp12;"},{"val":"","file":"test\/bs2.i","importance":0,"line":66,"additional":"","source":29,"faults":[],"target":30,"desc":"unsigned int __cil_tmp13;"},{"val":"","file":"test\/bs2.i","importance":0,"line":67,"additional":"","source":30,"faults":[],"target":31,"desc":"unsigned int __cil_tmp14;"},{"val":"","file":"test\/bs2.i","importance":0,"line":68,"additional":"","source":31,"faults":[],"target":32,"desc":"struct list_head *__cil_tmp15;"},{"val":"","file":"test\/bs2.i","importance":0,"line":69,"additional":"","source":32,"faults":[],"target":33,"desc":"unsigned int __cil_tmp16;"},{"val":"","file":"test\/bs2.i","importance":0,"line":70,"additional":"","source":33,"faults":[],"target":34,"desc":"struct list_head *__cil_tmp17;"},{"val":"","file":"test\/bs2.i","importance":0,"line":71,"additional":"","source":34,"faults":[],"target":35,"desc":"unsigned int __cil_tmp18;"},{"val":"","file":"test\/bs2.i","importance":0,"line":72,"additional":"","source":35,"faults":[],"target":36,"desc":"int __cil_tmp19;"},{"val":"","file":"test\/bs2.i","importance":0,"line":73,"additional":"","source":36,"faults":[],"target":37,"desc":"unsigned int __cil_tmp20;"},{"val":"","file":"test\/bs2.i","importance":0,"line":74,"additional":"","source":37,"faults":[],"target":38,"desc":"unsigned int __cil_tmp21;"},{"val":"","file":"test\/bs2.i","importance":0,"line":75,"additional":"","source":38,"faults":[],"target":39,"desc":"unsigned int __cil_tmp22;"},{"val":"","file":"test\/bs2.i","importance":0,"line":76,"additional":"","source":39,"faults":[],"target":40,"desc":"struct list_head *__cil_tmp23;"},{"val":"","file":"test\/bs2.i","importance":0,"line":77,"additional":"","source":40,"faults":[],"target":41,"desc":"unsigned int __cil_tmp24;"},{"val":"","file":"test\/bs2.i","importance":0,"line":78,"additional":"","source":41,"faults":[],"target":42,"desc":"int __cil_tmp25;"},{"val":"","file":"test\/bs2.i","importance":0,"line":79,"additional":"","source":42,"faults":[],"target":43,"desc":"struct node *__cil_tmp26;"},{"val":"","file":"test\/bs2.i","importance":0,"line":80,"additional":"","source":43,"faults":[],"target":44,"desc":"unsigned int __cil_tmp27;"},{"val":"","file":"test\/bs2.i","importance":0,"line":81,"additional":"","source":44,"faults":[],"target":45,"desc":"unsigned int __cil_tmp28;"},{"val":"","file":"test\/bs2.i","importance":0,"line":82,"additional":"","source":45,"faults":[],"target":46,"desc":"struct list_head *__cil_tmp29;"},{"val":"","file":"test\/bs2.i","importance":0,"line":83,"additional":"","source":46,"faults":[],"target":47,"desc":"unsigned long __cil_tmp30;"},{"val":"","file":"test\/bs2.i","importance":0,"line":84,"additional":"","source":47,"faults":[],"target":48,"desc":"char *__cil_tmp31;"},{"val":"","file":"test\/bs2.i","importance":0,"line":85,"additional":"","source":48,"faults":[],"target":49,"desc":"char *__cil_tmp32;"},{"val":"","file":"test\/bs2.i","importance":0,"line":86,"additional":"","source":49,"faults":[],"target":50,"desc":"struct node *__cil_tmp33;"},{"val":"","file":"test\/bs2.i","importance":0,"line":87,"additional":"","source":50,"faults":[],"target":51,"desc":"unsigned int __cil_tmp34;"},{"val":"","file":"test\/bs2.i","importance":0,"line":88,"additional":"","source":51,"faults":[],"target":52,"desc":"unsigned int __cil_tmp35;"},{"val":"","file":"test\/bs2.i","importance":0,"line":89,"additional":"","source":52,"faults":[],"target":53,"desc":"const struct list_head *__cil_tmp36;"},{"val":"","file":"test\/bs2.i","importance":0,"line":90,"additional":"","source":53,"faults":[],"target":54,"desc":"unsigned int __cil_tmp37;"},{"val":"","file":"test\/bs2.i","importance":0,"line":91,"additional":"","source":54,"faults":[],"target":55,"desc":"unsigned int __cil_tmp38;"},{"val":"","file":"test\/bs2.i","importance":0,"line":92,"additional":"","source":55,"faults":[],"target":56,"desc":"unsigned int __cil_tmp39;"},{"val":"","file":"test\/bs2.i","importance":0,"line":93,"additional":"","source":56,"faults":[],"target":57,"desc":"struct list_head *__cil_tmp40;"},{"val":"","file":"test\/bs2.i","importance":0,"line":94,"additional":"","source":57,"faults":[],"target":58,"desc":"unsigned int __cil_tmp41;"},{"val":"","file":"test\/bs2.i","importance":0,"line":95,"additional":"","source":58,"faults":[],"target":59,"desc":"int __cil_tmp42;"},{"val":"","file":"test\/bs2.i","importance":0,"line":96,"additional":"","source":59,"faults":[],"target":60,"desc":"unsigned int __cil_tmp43;"},{"val":"","file":"test\/bs2.i","importance":0,"line":97,"additional":"","source":60,"faults":[],"target":61,"desc":"unsigned int __cil_tmp44;"},{"val":"","file":"test\/bs2.i","importance":0,"line":98,"additional":"","source":61,"faults":[],"target":62,"desc":"const struct list_head *__cil_tmp45;"},{"val":"","file":"test\/bs2.i","importance":0,"line":99,"additional":"","source":62,"faults":[],"target":63,"desc":"unsigned int __cil_tmp46;"},{"val":"","file":"test\/bs2.i","importance":0,"line":100,"additional":"","source":63,"faults":[],"target":64,"desc":"unsigned int __cil_tmp47;"},{"val":"","file":"test\/bs2.i","importance":0,"line":101,"additional":"","source":64,"faults":[],"target":65,"desc":"unsigned int __cil_tmp48;"},{"val":"","file":"test\/bs2.i","importance":0,"line":102,"additional":"","source":65,"faults":[],"target":66,"desc":"unsigned int __cil_tmp49;"},{"val":"","file":"test\/bs2.i","importance":0,"line":103,"additional":"","source":66,"faults":[],"target":67,"desc":"struct list_head *__cil_tmp50;"},{"val":"","file":"test\/bs2.i","importance":0,"line":104,"additional":"","source":67,"faults":[],"target":68,"desc":"unsigned int __cil_tmp51;"},{"val":"","file":"test\/bs2.i","importance":0,"line":105,"additional":"","source":68,"faults":[],"target":69,"desc":"int __cil_tmp52;"},{"val":"","file":"test\/bs2.i","importance":0,"line":106,"additional":"","source":69,"faults":[],"target":70,"desc":"unsigned int __cil_tmp53;"},{"val":"","file":"test\/bs2.i","importance":0,"line":107,"additional":"","source":70,"faults":[],"target":71,"desc":"unsigned int __cil_tmp54;"},{"val":"","file":"test\/bs2.i","importance":0,"line":108,"additional":"","source":71,"faults":[],"target":72,"desc":"const struct list_head *__cil_tmp55;"},{"val":"","file":"test\/bs2.i","importance":0,"line":109,"additional":"","source":72,"faults":[],"target":73,"desc":"unsigned int __cil_tmp56;"},{"val":"","file":"test\/bs2.i","importance":0,"line":110,"additional":"","source":73,"faults":[],"target":74,"desc":"unsigned int __cil_tmp57;"},{"val":"","file":"test\/bs2.i","importance":0,"line":111,"additional":"","source":74,"faults":[],"target":75,"desc":"unsigned int __cil_tmp58;"},{"val":"","file":"test\/bs2.i","importance":0,"line":112,"additional":"","source":75,"faults":[],"target":76,"desc":"struct list_head *__cil_tmp59;"},{"val":"","file":"test\/bs2.i","importance":0,"line":113,"additional":"","source":76,"faults":[],"target":77,"desc":"unsigned int __cil_tmp60;"},{"val":"","file":"test\/bs2.i","importance":0,"line":114,"additional":"","source":77,"faults":[],"target":78,"desc":"int __cil_tmp61;"},{"val":"","file":"test\/bs2.i","importance":0,"line":115,"additional":"","source":78,"faults":[],"target":79,"desc":"unsigned int __cil_tmp62;"},{"val":"","file":"test\/bs2.i","importance":0,"line":116,"additional":"","source":79,"faults":[],"target":80,"desc":"unsigned int __cil_tmp63;"},{"val":"","file":"test\/bs2.i","importance":0,"line":117,"additional":"","source":80,"faults":[],"target":81,"desc":"const struct list_head *__cil_tmp64;"},{"val":"","file":"test\/bs2.i","importance":0,"line":118,"additional":"","source":81,"faults":[],"target":82,"desc":"unsigned int __cil_tmp65;"},{"val":"","file":"test\/bs2.i","importance":0,"line":119,"additional":"","source":82,"faults":[],"target":83,"desc":"unsigned int __cil_tmp66;"},{"val":"","file":"test\/bs2.i","importance":0,"line":120,"additional":"","source":83,"faults":[],"target":84,"desc":"unsigned int __cil_tmp67;"},{"val":"","file":"test\/bs2.i","importance":0,"line":121,"additional":"","source":84,"faults":[],"target":85,"desc":"unsigned int __cil_tmp68;"},{"val":"","file":"test\/bs2.i","importance":0,"line":122,"additional":"","source":85,"faults":[],"target":86,"desc":"struct list_head *__cil_tmp69;"},{"val":"","file":"test\/bs2.i","importance":0,"line":123,"additional":"","source":86,"faults":[],"target":87,"desc":"unsigned int __cil_tmp70;"},{"val":"","file":"test\/bs2.i","importance":0,"line":124,"additional":"","source":87,"faults":[],"target":88,"desc":"int __cil_tmp71;"},{"val":"","file":"test\/bs2.i","importance":0,"line":125,"additional":"","source":88,"faults":[],"target":89,"desc":"const struct node *__cil_tmp72;"},{"val":"","file":"test\/bs2.i","importance":0,"line":126,"additional":"","source":89,"faults":[],"target":90,"desc":"unsigned int __cil_tmp73;"},{"val":"","file":"test\/bs2.i","importance":0,"line":127,"additional":"","source":90,"faults":[],"target":91,"desc":"unsigned int __cil_tmp74;"},{"val":"","file":"test\/bs2.i","importance":0,"line":128,"additional":"","source":91,"faults":[],"target":92,"desc":"int __cil_tmp75;"},{"val":"","file":"test\/bs2.i","importance":0,"line":129,"additional":"","source":92,"faults":[],"target":93,"desc":"unsigned int __cil_tmp76;"},{"val":"","file":"test\/bs2.i","importance":0,"line":130,"additional":"","source":93,"faults":[],"target":94,"desc":"unsigned int __cil_tmp77;"},{"val":"","file":"test\/bs2.i","importance":0,"line":131,"additional":"","source":94,"faults":[],"target":95,"desc":"const struct list_head *__cil_tmp78;"},{"val":"","file":"test\/bs2.i","importance":0,"line":132,"additional":"","source":95,"faults":[],"target":96,"desc":"const struct node *__cil_tmp79;"},{"val":"","file":"test\/bs2.i","importance":0,"line":133,"additional":"","source":96,"faults":[],"target":97,"desc":"unsigned int __cil_tmp80;"},{"val":"","file":"test\/bs2.i","importance":0,"line":134,"additional":"","source":97,"faults":[],"target":98,"desc":"unsigned int __cil_tmp81;"},{"val":"","file":"test\/bs2.i","importance":0,"line":135,"additional":"","source":98,"faults":[],"target":99,"desc":"int __cil_tmp82;"},{"val":"","file":"test\/bs2.i","importance":0,"line":136,"additional":"","source":99,"faults":[],"target":100,"desc":"const int *__cil_tmp83;"},{"val":"","file":"test\/bs2.i","importance":0,"line":137,"additional":"","source":100,"faults":[],"target":101,"desc":"const struct node *__cil_tmp84;"},{"val":"","file":"test\/bs2.i","importance":0,"line":138,"additional":"","source":101,"faults":[],"target":102,"desc":"unsigned int __cil_tmp85;"},{"val":"","file":"test\/bs2.i","importance":0,"line":139,"additional":"","source":102,"faults":[],"target":103,"desc":"unsigned int __cil_tmp86;"},{"val":"","file":"test\/bs2.i","importance":0,"line":140,"additional":"","source":103,"faults":[],"target":104,"desc":"int __cil_tmp87;"},{"val":"","file":"test\/bs2.i","importance":0,"line":141,"additional":"","source":104,"faults":[],"target":105,"desc":"unsigned int __cil_tmp88;"},{"val":"","file":"test\/bs2.i","importance":0,"line":142,"additional":"","source":105,"faults":[],"target":106,"desc":"unsigned int __cil_tmp89;"},{"val":"","file":"test\/bs2.i","importance":0,"line":143,"additional":"","source":106,"faults":[],"target":107,"desc":"struct list_head *__cil_tmp90;"},{"val":"","file":"test\/bs2.i","importance":0,"line":144,"additional":"","source":107,"faults":[],"target":108,"desc":"unsigned int __cil_tmp91;"},{"val":"","file":"test\/bs2.i","importance":0,"line":145,"additional":"","source":108,"faults":[],"target":109,"desc":"unsigned int __cil_tmp92;"},{"val":"","file":"test\/bs2.i","importance":0,"line":146,"additional":"","source":109,"faults":[],"target":110,"desc":"struct list_head *__cil_tmp93;"},{"val":"","file":"test\/bs2.i","importance":0,"line":147,"additional":"","source":110,"faults":[],"target":111,"desc":"unsigned int __cil_tmp94;"},{"val":"","file":"test\/bs2.i","importance":0,"line":148,"additional":"","source":111,"faults":[],"target":112,"desc":"unsigned int __cil_tmp95;"},{"val":"","file":"test\/bs2.i","importance":0,"line":149,"additional":"","source":112,"faults":[],"target":113,"desc":"int __cil_tmp96;"},{"val":"","file":"test\/bs2.i","importance":0,"line":150,"additional":"","source":113,"faults":[],"target":114,"desc":"unsigned int __cil_tmp97;"},{"val":"","file":"test\/bs2.i","importance":0,"line":151,"additional":"","source":114,"faults":[],"target":115,"desc":"unsigned int __cil_tmp98;"},{"val":"","file":"test\/bs2.i","importance":0,"line":152,"additional":"","source":115,"faults":[],"target":116,"desc":"unsigned int __cil_tmp99;"},{"val":"","file":"test\/bs2.i","importance":0,"line":153,"additional":"","source":116,"faults":[],"target":117,"desc":"struct list_head *__cil_tmp100;"},{"val":"","file":"test\/bs2.i","importance":0,"line":154,"additional":"","source":117,"faults":[],"target":118,"desc":"struct list_head *__cil_tmp101;"},{"val":"","file":"test\/bs2.i","importance":0,"line":155,"additional":"","source":118,"faults":[],"target":119,"desc":"unsigned int __cil_tmp102;"},{"val":"","file":"test\/bs2.i","importance":0,"line":156,"additional":"","source":119,"faults":[],"target":120,"desc":"unsigned int __cil_tmp103;"},{"val":"","file":"test\/bs2.i","importance":0,"line":157,"additional":"","source":120,"faults":[],"target":121,"desc":"int __cil_tmp104;"},{"val":"","file":"test\/bs2.i","importance":0,"line":158,"additional":"","source":121,"faults":[],"target":122,"desc":"struct list_head *__cil_tmp105;"},{"val":"","file":"test\/bs2.i","importance":0,"line":159,"additional":"","source":122,"faults":[],"target":123,"desc":"unsigned int __cil_tmp106;"},{"val":"","file":"test\/bs2.i","importance":0,"line":160,"additional":"","source":123,"faults":[],"target":124,"desc":"unsigned int __cil_tmp107;"},{"val":"","file":"test\/bs2.i","importance":0,"line":161,"additional":"","source":124,"faults":[],"target":125,"desc":"unsigned int __cil_tmp108;"},{"val":"","file":"test\/bs2.i","importance":0,"line":162,"additional":"","source":125,"faults":[],"target":126,"desc":"const struct list_head *__cil_tmp109;"},{"val":"","file":"test\/bs2.i","importance":0,"line":163,"additional":"","source":126,"faults":[],"target":127,"desc":"unsigned int __cil_tmp110;"},{"val":"","file":"test\/bs2.i","importance":0,"line":164,"additional":"","source":127,"faults":[],"target":128,"desc":"struct list_head *__cil_tmp111;"},{"val":"","file":"test\/bs2.i","importance":0,"line":165,"additional":"","source":128,"faults":[],"target":129,"desc":"unsigned int __cil_tmp112;"},{"val":"","file":"test\/bs2.i","importance":0,"line":166,"additional":"","source":129,"faults":[],"target":130,"desc":"struct node *__cil_tmp113;"},{"val":"","file":"test\/bs2.i","importance":0,"line":167,"additional":"","source":130,"faults":[],"target":131,"desc":"unsigned int __cil_tmp114;"},{"val":"","file":"test\/bs2.i","importance":0,"line":168,"additional":"","source":131,"faults":[],"target":132,"desc":"unsigned int __cil_tmp115;"},{"val":"","file":"test\/bs2.i","importance":0,"line":169,"additional":"","source":132,"faults":[],"target":133,"desc":"struct list_head *__cil_tmp116;"},{"val":"","file":"test\/bs2.i","importance":0,"line":170,"additional":"","source":133,"faults":[],"target":134,"desc":"unsigned long __cil_tmp117;"},{"val":"","file":"test\/bs2.i","importance":0,"line":171,"additional":"","source":134,"faults":[],"target":135,"desc":"char *__cil_tmp118;"},{"val":"","file":"test\/bs2.i","importance":0,"line":172,"additional":"","source":135,"faults":[],"target":136,"desc":"char *__cil_tmp119;"},{"val":"","file":"test\/bs2.i","importance":0,"line":173,"additional":"","source":136,"faults":[],"target":137,"desc":"struct node *__cil_tmp120;"},{"val":"","file":"test\/bs2.i","importance":0,"line":174,"additional":"","source":137,"faults":[],"target":138,"desc":"unsigned int __cil_tmp121;"},{"val":"","file":"test\/bs2.i","importance":0,"line":175,"additional":"","source":138,"faults":[],"target":139,"desc":"int __cil_tmp122;"},{"val":"","file":"test\/bs2.i","importance":1,"line":179,"additional":"","source":139,"faults":[],"target":140,"desc":"while"},{"val":"head == 4LL;\n(head->next) == 32LL;\n(head->next->next) == 0LL;\n(head->next->prev) == 4LL;\n(head->next->prev->prev) == 4LL;\n","file":"test\/bs2.i","importance":0,"line":179,"additional":"","source":140,"faults":[],"target":141,"desc":""},{"val":"","file":"test\/bs2.i","importance":0,"line":180,"additional":"","argelem":141,"source":141,"faults":[],"target":143,"desc":"Label: while_0_continue"},{"val":"head == 4LL;\n(head->next) == 32LL;\n(head->next->next) == 0LL;\n(head->next->prev) == 4LL;\n(head->next->prev->prev) == 4LL;\nhead == 4LL;\n(head->next) == 32LL;\n(head->next->next) == 0LL;\n(head->next->prev) == 4LL;\n(head->next->prev->prev) == 4LL;","file":"test\/bs2.i","importance":1,"line":181,"additional":"","argelem":142,"source":143,"faults":[],"target":146,"desc":"[!(head == 0)]"},{"val":"","file":"<none>","importance":0,"line":0,"additional":"","argelem":144,"source":146,"faults":[],"target":144,"desc":""},{"val":"","file":"test\/bs2.i","importance":0,"line":187,"additional":"","argelem":145,"source":144,"faults":[],"target":149,"desc":"Goto: while_0_break"},{"val":"","file":"test\/bs2.i","importance":0,"line":189,"additional":"","argelem":149,"source":149,"faults":[],"target":150,"desc":"Label: while_0_break"},{"val":"","file":"test\/bs2.i","importance":1,"line":192,"additional":"","source":150,"faults":[],"target":151,"desc":"while"},{"val":"","file":"test\/bs2.i","importance":0,"line":192,"additional":"","source":151,"faults":[],"target":152,"desc":""},{"val":"","file":"test\/bs2.i","importance":0,"line":193,"additional":"","argelem":150,"source":152,"faults":[],"target":154,"desc":"Label: while_1_continue"},{"val":"__cil_tmp3 == 4U;\n","file":"test\/bs2.i","importance":1,"line":195,"additional":"","argelem":151,"source":154,"faults":[],"target":155,"desc":"__cil_tmp3 = (unsigned int)head;"},{"val":"__cil_tmp4 == 32LL;\n(__cil_tmp4->next) == 0LL;\n(__cil_tmp4->next->prev) == 32LL;\n(__cil_tmp4->prev) == 4LL;\n(__cil_tmp4->prev->prev) == 4LL;\n","file":"test\/bs2.i","importance":1,"line":196,"additional":"","source":155,"faults":[],"target":156,"desc":"__cil_tmp4 = *((struct list_head * const *)head);"},{"val":"__cil_tmp5 == 32U;\n","file":"test\/bs2.i","importance":1,"line":197,"additional":"","source":156,"faults":[],"target":157,"desc":"__cil_tmp5 = (unsigned int)__cil_tmp4;"},{"val":"__cil_tmp3 == 4U;\n__cil_tmp4 == 32LL;\n(__cil_tmp4->next) == 0LL;\n(__cil_tmp4->next->prev) == 32LL;\n(__cil_tmp4->prev) == 4LL;\n(__cil_tmp4->prev->prev) == 4LL;\n__cil_tmp5 == 32U;\n__cil_tmp6 == 1;\n","file":"test\/bs2.i","importance":1,"line":198,"additional":"","source":157,"faults":[],"target":158,"desc":"__cil_tmp6 = __cil_tmp5 != __cil_tmp3;"},{"val":"__cil_tmp6 == 1;\n__cil_tmp6 == 1;","file":"test\/bs2.i","importance":1,"line":199,"additional":"","argelem":152,"source":158,"faults":[],"target":161,"desc":"[!(__cil_tmp6 == 0)]"},{"val":"","file":"<none>","importance":0,"line":0,"additional":"","argelem":154,"source":161,"faults":[],"target":159,"desc":""},{"val":"","file":"test\/bs2.i","importance":0,"line":206,"additional":"","argelem":155,"source":159,"faults":[],"target":164,"desc":"Goto: while_1_break"},{"val":"","file":"test\/bs2.i","importance":0,"line":208,"additional":"","argelem":159,"source":164,"faults":[],"target":165,"desc":"Label: while_1_break"},{"val":"","file":"test\/bs2.i","importance":1,"line":211,"additional":"","source":165,"faults":[],"target":166,"desc":"while"},{"val":"","file":"test\/bs2.i","importance":0,"line":211,"additional":"","source":166,"faults":[],"target":167,"desc":""},{"val":"","file":"test\/bs2.i","importance":0,"line":212,"additional":"","argelem":160,"source":167,"faults":[],"target":169,"desc":"Label: while_2_continue"},{"val":"__cil_tmp7 == 4U;\n","file":"test\/bs2.i","importance":1,"line":214,"additional":"<br><br><strong>Additional information provided:<\/strong><br>Error suspected on line(s): <strong>214<\/strong><br><br> Relevant lines:\n<ul class=\"fault-lines\">\n<li><span class=\"line-number\">214<\/span><span class=\"line-content\">__cil_tmp7 = (unsigned int)head;<\/span><\/li><\/ul>\nFound <strong>1<\/strong> possible bug-fix:<br><ul id=\"fix-list\"><li>Try to change the assigned value of \"__cil_tmp7\" in \"__cil_tmp7 = (unsigned int)head;\" to another value.<\/li><\/ul><br>","argelem":161,"source":169,"faults":[0],"target":170,"desc":"__cil_tmp7 = (unsigned int)head;"},{"val":"__cil_tmp8 == 4U;\n","file":"test\/bs2.i","importance":0,"line":215,"additional":"<br><br><strong>Additional information provided:<\/strong><br>Error suspected on line(s): <strong>215<\/strong><br><br> Relevant lines:\n<ul class=\"fault-lines\">\n<li><span class=\"line-number\">215<\/span><span class=\"line-content\">__cil_tmp8 = (unsigned int)head;<\/span><\/li><\/ul>\nFound <strong>1<\/strong> possible bug-fix:<br><ul id=\"fix-list\"><li>Try to change the assigned value of \"__cil_tmp8\" in \"__cil_tmp8 = (unsigned int)head;\" to another value.<\/li><\/ul><br>","source":170,"faults":[0],"target":171,"desc":"__cil_tmp8 = (unsigned int)head;"},{"val":"__cil_tmp9 == 8U;\n","file":"test\/bs2.i","importance":0,"line":216,"additional":"<br><br><strong>Additional information provided:<\/strong><br>Error suspected on line(s): <strong>216<\/strong><br><br> Relevant lines:\n<ul class=\"fault-lines\">\n<li><span class=\"line-number\">216<\/span><span class=\"line-content\">__cil_tmp9 = __cil_tmp8 + 4;<\/span><\/li><\/ul>\nFound <strong>1<\/strong> possible bug-fix:<br><ul id=\"fix-list\"><li>Try to change the assigned value of \"__cil_tmp9\" in \"__cil_tmp9 = __cil_tmp8 + 4;\" to another value.<\/li><\/ul><br>","source":171,"faults":[0],"target":172,"desc":"__cil_tmp9 = __cil_tmp8 + 4;"},{"val":"__cil_tmp10 == 4LL;\n(__cil_tmp10->next) == 32LL;\n(__cil_tmp10->next->next) == 0LL;\n(__cil_tmp10->next->prev) == 4LL;\n(__cil_tmp10->prev) == 4LL;\n","file":"test\/bs2.i","importance":1,"line":217,"additional":"<br><br><strong>Additional information provided:<\/strong><br>Error suspected on line(s): <strong>217<\/strong><br><br> Relevant lines:\n<ul class=\"fault-lines\">\n<li><span class=\"line-number\">217<\/span><span class=\"line-content\">__cil_tmp10 = *((struct list_head * const *)__cil_tmp9);<\/span><\/li><\/ul>\nFound <strong>1<\/strong> possible bug-fix:<br><ul id=\"fix-list\"><li>Try to change the assigned value of \"__cil_tmp10\" in \"__cil_tmp10 = *((struct list_head * const *)__cil_tmp9);\" to another value.<\/li><\/ul><br>","source":172,"faults":[0],"target":173,"desc":"__cil_tmp10 = *((struct list_head * const *)__cil_tmp9);"},{"val":"__cil_tmp11 == 4U;\n","file":"test\/bs2.i","importance":1,"line":218,"additional":"<br><br><strong>Additional information provided:<\/strong><br>Error suspected on line(s): <strong>218<\/strong><br><br> Relevant lines:\n<ul class=\"fault-lines\">\n<li><span class=\"line-number\">218<\/span><span class=\"line-content\">__cil_tmp11 = (unsigned int)__cil_tmp10;<\/span><\/li><\/ul>\nFound <strong>1<\/strong> possible bug-fix:<br><ul id=\"fix-list\"><li>Try to change the assigned value of \"__cil_tmp11\" in \"__cil_tmp11 = (unsigned int)__cil_tmp10;\" to another value.<\/li><\/ul><br>","source":173,"faults":[0],"target":174,"desc":"__cil_tmp11 = (unsigned int)__cil_tmp10;"},{"val":"__cil_tmp7 == 4U;\n__cil_tmp8 == 4U;\n__cil_tmp9 == 8U;\n__cil_tmp10 == 4LL;\n(__cil_tmp10->next) == 32LL;\n(__cil_tmp10->next->next) == 0LL;\n(__cil_tmp10->next->prev) == 4LL;\n(__cil_tmp10->prev) == 4LL;\n__cil_tmp11 == 4U;\n__cil_tmp12 == 0;\n","file":"test\/bs2.i","importance":1,"line":219,"additional":"<br><br><strong>Additional information provided:<\/strong><br>Error suspected on line(s): <strong>219<\/strong><br><br> Relevant lines:\n<ul class=\"fault-lines\">\n<li><span class=\"line-number\">219<\/span><span class=\"line-content\">__cil_tmp12 = __cil_tmp11 != __cil_tmp7;<\/span><\/li><\/ul>\nFound <strong>1<\/strong> possible bug-fix:<br><ul id=\"fix-list\"><li>Try to change the assigned value of \"__cil_tmp12\" in \"__cil_tmp12 = __cil_tmp11 != __cil_tmp7;\" to another value.<\/li><\/ul><br>","source":174,"faults":[0],"target":175,"desc":"__cil_tmp12 = __cil_tmp11 != __cil_tmp7;"},{"val":"__cil_tmp12 == 0;\n__cil_tmp12 == 0;","file":"test\/bs2.i","importance":1,"line":220,"additional":"","argelem":162,"source":175,"faults":[],"target":177,"desc":"[__cil_tmp12 == 0]"},{"val":"","file":"test\/bs2.i","importance":1,"line":222,"additional":"","argelem":163,"source":177,"faults":[],"target":9,"desc":"fail()"},{"val":"","file":"<none>","importance":0,"line":0,"additional":"","argelem":166,"source":9,"faults":[],"target":10,"desc":"Function start dummy edge"},{"val":"","file":"test\/bs2.i","importance":1,"line":46,"additional":"","argelem":167,"source":10,"faults":[],"target":11,"desc":"Label: ERROR"}],
"faults":[{"score":100,"reason":"Error suspected on line(s): <strong>214, 215, 216, 217, 218, 219, 840 and 841<\/strong><br><br> Relevant lines:\n<ul class=\"fault-lines\">\n<li><span class=\"line-number\">214<\/span><span class=\"line-content\">__cil_tmp7 = (unsigned int)head;<\/span><\/li><li><span class=\"line-number\">215<\/span><span class=\"line-content\">__cil_tmp8 = (unsigned int)head;<\/span><\/li><li><span class=\"line-number\">216<\/span><span class=\"line-content\">__cil_tmp9 = __cil_tmp8 + 4;<\/span><\/li><li><span class=\"line-number\">217<\/span><span class=\"line-content\">__cil_tmp10 = *((struct list_head * const *)__cil_tmp9);<\/span><\/li><li><span class=\"line-number\">218<\/span><span class=\"line-content\">__cil_tmp11 = (unsigned int)__cil_tmp10;<\/span><\/li><li><span class=\"line-number\">219<\/span><span class=\"line-content\">__cil_tmp12 = __cil_tmp11 != __cil_tmp7;<\/span><\/li><li><span class=\"line-number\">840<\/span><span class=\"line-content\">__cil_tmp1 = (const struct list_head *)(&gl_list);<\/span><\/li><li><span class=\"line-number\">841<\/span><span class=\"line-content\">inspect(__cil_tmp1)<\/span><\/li><\/ul>\nFound <strong>3<\/strong> possible bug-fixes:<br><ul id=\"fix-list\"><li>Try to change the assigned value of \"__cil_tmp12\" in \"__cil_tmp12 = __cil_tmp11 != __cil_tmp7;\" to another value.<\/li><li>Try to change the assigned value of \"__cil_tmp1\" in \"__cil_tmp1 = (const struct list_head *)(&gl_list);\" to another value.<\/li><li>The function call \"inspect(__cil_tmp1)\" may have unwanted side effects or a wrong return value.<\/li><\/ul><br>","rank":1}],
"precondition":{"fl-precondition":"( ( __VERIFIER_nondet_int!3@ == 0 ) && ( ( "},
"nodes":[{"func":"reach_error","loop":false,"index":0,"rpid":0,"type":"exit"},{"func":"reach_error","loop":false,"index":1,"rpid":6,"type":"entry"},{"func":"reach_error","loop":false,"index":2,"rpid":5,"type":""},{"func":"reach_error","loop":false,"index":3,"rpid":4,"type":""},{"func":"reach_error","loop":false,"index":4,"rpid":1,"type":""},{"func":"reach_error","loop":false,"index":6,"rpid":3,"type":""},{"func":"reach_error","loop":false,"index":7,"rpid":2,"type":""},{"func":"fail","loop":false,"index":9,"rpid":5,"type":"entry"},{"func":"fail","loop":false,"index":10,"rpid":4,"type":""},{"func":"fail","loop":true,"index":11,"rpid":3,"type":""},{"func":"fail","loop":false,"index":12,"rpid":2,"type":""},{"func":"fail","loop":false,"index":13,"rpid":1,"type":""},{"func":"fail","loop":false,"index":14,"rpid":0,"type":""},{"func":"inspect","loop":false,"index":16,"rpid":4,"type":"exit"},{"func":"inspect","loop":false,"index":17,"rpid":408,"type":"entry"},{"func":"inspect","loop":false,"index":18,"rpid":407,"type":""},{"func":"inspect","loop":false,"index":19,"rpid":406,"type":""},{"func":"inspect","loop":false,"index":20,"rpid":405,"type":""},{"func":"inspect","loop":false,"index":21,"rpid":404,"type":""},{"func":"inspect","loop":false,"index":22,"rpid":403,"type":""},{"func":"inspect","loop":false,"index":23,"rpid":402,"type":""},{"func":"inspect","loop":false,"index":24,"rpid":401,"type":""},{"func":"inspect","loop":false,"index":25,"rpid":400,"type":""},{"func":"inspect","loop":false,"index":26,"rpid":399,"type":""},{"func":"inspect","loop":false,"index":27,"rpid":398,"type":""},{"func":"inspect","loop":false,"index":28,"rpid":397,"type":""},{"func":"inspect","loop":false,"index":29,"rpid":396,"type":""},{"func":"inspect","loop":false,"index":30,"rpid":395,"type":""},{"func":"inspect","loop":false,"index":31,"rpid":394,"type":""},{"func":"inspect","loop":false,"index":32,"rpid":393,"type":""},{"func":"inspect","loop":false,"index":33,"rpid":392,"type":""},{"func":"inspect","loop":false,"index":34,"rpid":391,"type":""},{"func":"inspect","loop":false,"index":35,"rpid":390,"type":""},{"func":"inspect","loop":false,"index":36,"rpid":389,"type":""},{"func":"inspect","loop":false,"index":37,"rpid":388,"type":""},{"func":"inspect","loop":false,"index":38,"rpid":387,"type":""},{"func":"inspect","loop":false,"index":39,"rpid":386,"type":""},{"func":"inspect","loop":false,"index":40,"rpid":385,"type":""},{"func":"inspect","loop":false,"index":41,"rpid":384,"type":""},{"func":"inspect","loop":false,"index":42,"rpid":383,"type":""},{"func":"inspect","loop":false,"index":43,"rpid":382,"type":""},{"func":"inspect","loop":false,"index":44,"rpid":381,"type":""},{"func":"inspect","loop":false,"index":45,"rpid":380,"type":""},{"func":"inspect","loop":false,"index":46,"rpid":379,"type":""},{"func":"inspect","loop":false,"index":47,"rpid":378,"type":""},{"func":"inspect","loop":false,"index":48,"rpid":377,"type":""},{"func":"inspect","loop":false,"index":49,"rpid":376,"type":""},{"func":"inspect","loop":false,"index":50,"rpid":375,"type":""},{"func":"inspect","loop":false,"index":51,"rpid":374,"type":""},{"func":"inspect","loop":false,"index":52,"rpid":373,"type":""},{"func":"inspect","loop":false,"index":53,"rpid":372,"type":""},{"func":"inspect","loop":false,"index":54,"rpid":371,"type":""},{"func":"inspect","loop":false,"index":55,"rpid":370,"type":""},{"func":"inspect","loop":false,"index":56,"rpid":369,"type":""},{"func":"inspect","loop":false,"index":57,"rpid":368,"type":""},{"func":"inspect","loop":false,"index":58,"rpid":367,"type":""},{"func":"inspect","loop":false,"index":59,"rpid":366,"type":""},{"func":"inspect","loop":false,"index":60,"rpid":365,"type":""},{"func":"inspect","loop":false,"index":61,"rpid":364,"type":""},{"func":"inspect","loop":false,"index":62,"rpid":363,"type":""},{"func":"inspect","loop":false,"index":63,"rpid":362,"type":""},{"func":"inspect","loop":false,"index":64,"rpid":361,"type":""},{"func":"inspect","loop":false,"index":65,"rpid":360,"type":""},{"func":"inspect","loop":false,"index":66,"rpid":359,"type":""},{"func":"inspect","loop":false,"index":67,"rpid":358,"type":""},{"func":"inspect","loop":false,"index":68,"rpid":357,"type":""},{"func":"inspect","loop":false,"index":69,"rpid":356,"type":""},{"func":"inspect","loop":false,"index":70,"rpid":355,"type":""},{"func":"inspect","loop":false,"index":71,"rpid":354,"type":""},{"func":"inspect","loop":false,"index":72,"rpid":353,"type":""},{"func":"inspect","loop":false,"index":73,"rpid":352,"type":""},{"func":"inspect","loop":false,"index":74,"rpid":351,"type":""},{"func":"inspect","loop":false,"index":75,"rpid":350,"type":""},{"func":"inspect","loop":false,"index":76,"rpid":349,"type":""},{"func":"inspect","loop":false,"index":77,"rpid":348,"type":""},{"func":"inspect","loop":false,"index":78,"rpid":347,"type":""},{"func":"inspect","loop":false,"index":79,"rpid":346,"type":""},{"func":"inspect","loop":false,"index":80,"rpid":345,"type":""},{"func":"inspect","loop":false,"index":81,"rpid":344,"type":""},{"func":"inspect","loop":false,"index":82,"rpid":343,"type":""},{"func":"inspect","loop":false,"index":83,"rpid":342,"type":""},{"func":"inspect","loop":false,"index":84,"rpid":341,"type":""},{"func":"inspect","loop":false,"index":85,"rpid":340,"type":""},{"func":"inspect","loop":false,"index":86,"rpid":339,"type":""},{"func":"inspect","loop":false,"index":87,"rpid":338,"type":""},{"func":"inspect","loop":false,"index":88,"rpid":337,"type":""},{"func":"inspect","loop":false,"index":89,"rpid":336,"type":""},{"func":"inspect","loop":false,"index":90,"rpid":335,"type":""},{"func":"inspect","loop":false,"index":91,"rpid":334,"type":""},{"func":"inspect","loop":false,"index":92,"rpid":333,"type":""},{"func":"inspect","loop":false,"index":93,"rpid":332,"type":""},{"func":"inspect","loop":false,"index":94,"rpid":331,"type":""},{"func":"inspect","loop":false,"index":95,"rpid":330,"type":""},{"func":"inspect","loop":false,"index":96,"rpid":329,"type":""},{"func":"inspect","loop":false,"index":97,"rpid":328,"type":""},{"func":"inspect","loop":false,"index":98,"rpid":327,"type":""},{"func":"inspect","loop":false,"index":99,"rpid":326,"type":""},{"func":"inspect","loop":false,"index":100,"rpid":325,"type":""},{"func":"inspect","loop":false,"index":101,"rpid":324,"type":""},{"func":"inspect","loop":false,"index":102,"rpid":323,"type":""},{"func":"inspect","loop":false,"index":103,"rpid":322,"type":""},{"func":"inspect","loop":false,"index":104,"rpid":321,"type":""},{"func":"inspect","loop":false,"index":105,"rpid":320,"type":""},{"func":"inspect","loop":false,"index":106,"rpid":319,"type":""},{"func":"inspect","loop":false,"index":107,"rpid":318,"type":""},{"func":"inspect","loop":false,"index":108,"rpid":317,"type":""},{"func":"inspect","loop":false,"index":109,"rpid":316,"type":""},{"func":"inspect","loop":false,"index":110,"rpid":315,"type":""},{"func":"inspect","loop":false,"index":111,"rpid":314,"type":""},{"func":"inspect","loop":false,"index":112,"rpid":313,"type":""},{"func":"inspect","loop":false,"index":113,"rpid":312,"type":""},{"func":"inspect","loop":false,"index":114,"rpid":311,"type":""},{"func":"inspect","loop":false,"index":115,"rpid":310,"type":""},{"func":"inspect","loop":false,"index":116,"rpid":309,"type":""},{"func":"inspect","loop":false,"index":117,"rpid":308,"type":""},{"func":"inspect","loop":false,"index":118,"rpid":307,"type":""},{"func":"inspect","loop":false,"index":119,"rpid":306,"type":""},{"func":"inspect","loop":false,"index":120,"rpid":305,"type":""},{"func":"inspect","loop":false,"index":121,"rpid":304,"type":""},{"func":"inspect","loop":false,"index":122,"rpid":303,"type":""},{"func":"inspect","loop":false,"index":123,"rpid":302,"type":""},{"func":"inspect","loop":false,"index":124,"rpid":301,"type":""},{"func":"inspect","loop":false,"index":125,"rpid":300,"type":""},{"func":"inspect","loop":false,"index":126,"rpid":299,"type":""},{"func":"inspect","loop":false,"index":127,"rpid":298,"type":""},{"func":"inspect","loop":false,"index":128,"rpid":297,"type":""},{"func":"inspect","loop":false,"index":129,"rpid":296,"type":""},{"func":"inspect","loop":false,"index":130,"rpid":295,"type":""},{"func":"inspect","loop":false,"index":131,"rpid":294,"type":""},{"func":"inspect","loop":false,"index":132,"rpid":293,"type":""},{"func":"inspect","loop":false,"index":133,"rpid":292,"type":""},{"func":"inspect","loop":false,"index":134,"rpid":291,"type":""},{"func":"inspect","loop":false,"index":135,"rpid":290,"type":""},{"func":"inspect","loop":false,"index":136,"rpid":289,"type":""},{"func":"inspect","loop":false,"index":137,"rpid":288,"type":""},{"func":"inspect","loop":false,"index":138,"rpid":287,"type":""},{"func":"inspect","loop":false,"index":139,"rpid":286,"type":""},{"func":"inspect","loop":true,"index":140,"rpid":285,"type":""},{"func":"inspect","loop":false,"index":141,"rpid":284,"type":""},{"func":"inspect","loop":false,"index":143,"rpid":283,"type":""},{"func":"inspect","loop":false,"index":144,"rpid":279,"type":""},{"func":"inspect","loop":false,"index":145,"rpid":281,"type":""},{"func":"inspect","loop":false,"index":146,"rpid":282,"type":""},{"func":"inspect","loop":false,"index":147,"rpid":280,"type":""},{"func":"inspect","loop":false,"index":149,"rpid":278,"type":""},{"func":"inspect","loop":false,"index":150,"rpid":277,"type":""},{"func":"inspect","loop":true,"index":151,"rpid":276,"type":""},{"func":"inspect","loop":false,"index":152,"rpid":275,"type":""},{"func":"inspect","loop":false,"index":154,"rpid":274,"type":""},{"func":"inspect","loop":false,"index":155,"rpid":273,"type":""},{"func":"inspect","loop":false,"index":156,"rpid":272,"type":""},{"func":"inspect","loop":false,"index":157,"rpid":271,"type":""},{"func":"inspect","loop":false,"index":158,"rpid":270,"type":""},{"func":"inspect","loop":false,"index":159,"rpid":266,"type":""},{"func":"inspect","loop":false,"index":160,"rpid":268,"type":""},{"func":"inspect","loop":false,"index":161,"rpid":269,"type":""},{"func":"inspect","loop":false,"index":162,"rpid":267,"type":""},{"func":"inspect","loop":false,"index":164,"rpid":265,"type":""},{"func":"inspect","loop":false,"index":165,"rpid":264,"type":""},{"func":"inspect","loop":true,"index":166,"rpid":263,"type":""},{"func":"inspect","loop":false,"index":167,"rpid":262,"type":""},{"func":"inspect","loop":false,"index":169,"rpid":261,"type":""},{"func":"inspect","loop":false,"index":170,"rpid":260,"type":""},{"func":"inspect","loop":false,"index":171,"rpid":259,"type":""},{"func":"inspect","loop":false,"index":172,"rpid":258,"type":""},{"func":"inspect","loop":false,"index":173,"rpid":257,"type":""},{"func":"inspect","loop":false,"index":174,"rpid":256,"type":""},{"func":"inspect","loop":false,"index":175,"rpid":255,"type":""},{"func":"inspect","loop":false,"index":176,"rpid":251,"type":""},{"func":"inspect","loop":false,"index":177,"rpid":253,"type":""},{"func":"inspect","loop":false,"index":178,"rpid":254,"type":""},{"func":"inspect","loop":false,"index":179,"rpid":252,"type":""},{"func":"inspect","loop":false,"index":181,"rpid":250,"type":""},{"func":"inspect","loop":false,"index":182,"rpid":249,"type":""},{"func":"inspect","loop":false,"index":183,"rpid":248,"type":""},{"func":"inspect","loop":false,"index":184,"rpid":247,"type":""},{"func":"inspect","loop":false,"index":185,"rpid":246,"type":""},{"func":"inspect","loop":false,"index":186,"rpid":245,"type":""},{"func":"inspect","loop":true,"index":187,"rpid":244,"type":""},{"func":"inspect","loop":false,"index":188,"rpid":243,"type":""},{"func":"inspect","loop":false,"index":190,"rpid":242,"type":""},{"func":"inspect","loop":false,"index":191,"rpid":238,"type":""},{"func":"inspect","loop":false,"index":192,"rpid":240,"type":""},{"func":"inspect","loop":false,"index":193,"rpid":241,"type":""},{"func":"inspect","loop":false,"index":194,"rpid":239,"type":""},{"func":"inspect","loop":false,"index":196,"rpid":237,"type":""},{"func":"inspect","loop":false,"index":197,"rpid":236,"type":""},{"func":"inspect","loop":true,"index":198,"rpid":235,"type":""},{"func":"inspect","loop":false,"index":199,"rpid":234,"type":""},{"func":"inspect","loop":false,"index":201,"rpid":233,"type":""},{"func":"inspect","loop":false,"index":202,"rpid":232,"type":""},{"func":"inspect","loop":false,"index":203,"rpid":231,"type":""},{"func":"inspect","loop":false,"index":204,"rpid":230,"type":""},{"func":"inspect","loop":false,"index":205,"rpid":229,"type":""},{"func":"inspect","loop":false,"index":206,"rpid":225,"type":""},{"func":"inspect","loop":false,"index":207,"rpid":227,"type":""},{"func":"inspect","loop":false,"index":208,"rpid":228,"type":""},{"func":"inspect","loop":false,"index":209,"rpid":226,"type":""},{"func":"inspect","loop":false,"index":211,"rpid":224,"type":""},{"func":"inspect","loop":false,"index":212,"rpid":223,"type":""},{"func":"inspect","loop":true,"index":213,"rpid":222,"type":""},{"func":"inspect","loop":false,"index":214,"rpid":221,"type":""},{"func":"inspect","loop":false,"index":216,"rpid":220,"type":""},{"func":"inspect","loop":false,"index":217,"rpid":219,"type":""},{"func":"inspect","loop":false,"index":218,"rpid":218,"type":""},{"func":"inspect","loop":false,"index":219,"rpid":217,"type":""},{"func":"inspect","loop":false,"index":220,"rpid":216,"type":""},{"func":"inspect","loop":false,"index":221,"rpid":215,"type":""},{"func":"inspect","loop":false,"index":222,"rpid":214,"type":""},{"func":"inspect","loop":false,"index":223,"rpid":210,"type":""},{"func":"inspect","loop":false,"index":224,"rpid":212,"type":""},{"func":"inspect","loop":false,"index":225,"rpid":213,"type":""},{"func":"inspect","loop":false,"index":226,"rpid":211,"type":""},{"func":"inspect","loop":false,"index":228,"rpid":209,"type":""},{"func":"inspect","loop":false,"index":229,"rpid":208,"type":""},{"func":"inspect","loop":false,"index":230,"rpid":207,"type":""},{"func":"inspect","loop":false,"index":231,"rpid":206,"type":""},{"func":"inspect","loop":false,"index":232,"rpid":205,"type":""},{"func":"inspect","loop":false,"index":233,"rpid":204,"type":""},{"func":"inspect","loop":false,"index":234,"rpid":203,"type":""},{"func":"inspect","loop":false,"index":235,"rpid":202,"type":""},{"func":"inspect","loop":false,"index":236,"rpid":201,"type":""},{"func":"inspect","loop":false,"index":237,"rpid":200,"type":""},{"func":"inspect","loop":false,"index":238,"rpid":199,"type":""},{"func":"inspect","loop":true,"index":239,"rpid":198,"type":""},{"func":"inspect","loop":false,"index":240,"rpid":197,"type":""},{"func":"inspect","loop":false,"index":242,"rpid":196,"type":""},{"func":"inspect","loop":false,"index":243,"rpid":192,"type":""},{"func":"inspect","loop":false,"index":244,"rpid":194,"type":""},{"func":"inspect","loop":false,"index":245,"rpid":195,"type":""},{"func":"inspect","loop":false,"index":246,"rpid":193,"type":""},{"func":"inspect","loop":false,"index":248,"rpid":191,"type":""},{"func":"inspect","loop":false,"index":249,"rpid":190,"type":""},{"func":"inspect","loop":true,"index":250,"rpid":189,"type":""},{"func":"inspect","loop":false,"index":251,"rpid":188,"type":""},{"func":"inspect","loop":false,"index":253,"rpid":187,"type":""},{"func":"inspect","loop":false,"index":254,"rpid":186,"type":""},{"func":"inspect","loop":false,"index":255,"rpid":185,"type":""},{"func":"inspect","loop":false,"index":256,"rpid":184,"type":""},{"func":"inspect","loop":false,"index":257,"rpid":183,"type":""},{"func":"inspect","loop":false,"index":258,"rpid":182,"type":""},{"func":"inspect","loop":false,"index":259,"rpid":181,"type":""},{"func":"inspect","loop":false,"index":260,"rpid":180,"type":""},{"func":"inspect","loop":false,"index":261,"rpid":179,"type":""},{"func":"inspect","loop":false,"index":262,"rpid":178,"type":""},{"func":"inspect","loop":false,"index":263,"rpid":174,"type":""},{"func":"inspect","loop":false,"index":264,"rpid":176,"type":""},{"func":"inspect","loop":false,"index":265,"rpid":177,"type":""},{"func":"inspect","loop":false,"index":266,"rpid":175,"type":""},{"func":"inspect","loop":false,"index":268,"rpid":173,"type":""},{"func":"inspect","loop":false,"index":269,"rpid":172,"type":""},{"func":"inspect","loop":true,"index":270,"rpid":171,"type":""},{"func":"inspect","loop":false,"index":271,"rpid":170,"type":""},{"func":"inspect","loop":false,"index":273,"rpid":169,"type":""},{"func":"inspect","loop":false,"index":274,"rpid":168,"type":""},{"func":"inspect","loop":false,"index":275,"rpid":167,"type":""},{"func":"inspect","loop":false,"index":276,"rpid":166,"type":""},{"func":"inspect","loop":false,"index":277,"rpid":165,"type":""},{"func":"inspect","loop":false,"index":278,"rpid":164,"type":""},{"func":"inspect","loop":false,"index":279,"rpid":163,"type":""},{"func":"inspect","loop":false,"index":280,"rpid":162,"type":""},{"func":"inspect","loop":false,"index":281,"rpid":161,"type":""},{"func":"inspect","loop":false,"index":282,"rpid":160,"type":""},{"func":"inspect","loop":false,"index":283,"rpid":159,"type":""},{"func":"inspect","loop":false,"index":284,"rpid":155,"type":""},{"func":"inspect","loop":false,"index":285,"rpid":157,"type":""},{"func":"inspect","loop":false,"index":286,"rpid":158,"type":""},{"func":"inspect","loop":false,"index":287,"rpid":156,"type":""},{"func":"inspect","loop":false,"index":289,"rpid":154,"type":""},{"func":"inspect","loop":false,"index":290,"rpid":153,"type":""},{"func":"inspect","loop":true,"index":291,"rpid":152,"type":""},{"func":"inspect","loop":false,"index":292,"rpid":151,"type":""},{"func":"inspect","loop":false,"index":294,"rpid":150,"type":""},{"func":"inspect","loop":false,"index":295,"rpid":149,"type":""},{"func":"inspect","loop":false,"index":296,"rpid":148,"type":""},{"func":"inspect","loop":false,"index":297,"rpid":147,"type":""},{"func":"inspect","loop":false,"index":298,"rpid":146,"type":""},{"func":"inspect","loop":false,"index":299,"rpid":145,"type":""},{"func":"inspect","loop":false,"index":300,"rpid":144,"type":""},{"func":"inspect","loop":false,"index":301,"rpid":143,"type":""},{"func":"inspect","loop":false,"index":302,"rpid":142,"type":""},{"func":"inspect","loop":false,"index":303,"rpid":141,"type":""},{"func":"inspect","loop":false,"index":304,"rpid":137,"type":""},{"func":"inspect","loop":false,"index":305,"rpid":139,"type":""},{"func":"inspect","loop":false,"index":306,"rpid":140,"type":""},{"func":"inspect","loop":false,"index":307,"rpid":138,"type":""},{"func":"inspect","loop":false,"index":309,"rpid":136,"type":""},{"func":"inspect","loop":false,"index":310,"rpid":135,"type":""},{"func":"inspect","loop":true,"index":311,"rpid":134,"type":""},{"func":"inspect","loop":false,"index":312,"rpid":133,"type":""},{"func":"inspect","loop":false,"index":314,"rpid":132,"type":""},{"func":"inspect","loop":false,"index":315,"rpid":131,"type":""},{"func":"inspect","loop":false,"index":316,"rpid":130,"type":""},{"func":"inspect","loop":false,"index":317,"rpid":129,"type":""},{"func":"inspect","loop":false,"index":318,"rpid":128,"type":""},{"func":"inspect","loop":false,"index":319,"rpid":127,"type":""},{"func":"inspect","loop":false,"index":320,"rpid":126,"type":""},{"func":"inspect","loop":false,"index":321,"rpid":125,"type":""},{"func":"inspect","loop":false,"index":322,"rpid":124,"type":""},{"func":"inspect","loop":false,"index":323,"rpid":123,"type":""},{"func":"inspect","loop":false,"index":324,"rpid":122,"type":""},{"func":"inspect","loop":false,"index":325,"rpid":118,"type":""},{"func":"inspect","loop":false,"index":326,"rpid":120,"type":""},{"func":"inspect","loop":false,"index":327,"rpid":121,"type":""},{"func":"inspect","loop":false,"index":328,"rpid":119,"type":""},{"func":"inspect","loop":false,"index":330,"rpid":117,"type":""},{"func":"inspect","loop":false,"index":331,"rpid":116,"type":""},{"func":"inspect","loop":true,"index":332,"rpid":115,"type":""},{"func":"inspect","loop":false,"index":333,"rpid":114,"type":""},{"func":"inspect","loop":false,"index":335,"rpid":113,"type":""},{"func":"inspect","loop":false,"index":336,"rpid":112,"type":""},{"func":"inspect","loop":false,"index":337,"rpid":111,"type":""},{"func":"inspect","loop":false,"index":338,"rpid":110,"type":""},{"func":"inspect","loop":false,"index":339,"rpid":109,"type":""},{"func":"inspect","loop":false,"index":340,"rpid":105,"type":""},{"func":"inspect","loop":false,"index":341,"rpid":107,"type":""},{"func":"inspect","loop":false,"index":342,"rpid":108,"type":""},{"func":"inspect","loop":false,"index":343,"rpid":106,"type":""},{"func":"inspect","loop":false,"index":345,"rpid":104,"type":""},{"func":"inspect","loop":false,"index":346,"rpid":103,"type":""},{"func":"inspect","loop":true,"index":347,"rpid":102,"type":""},{"func":"inspect","loop":false,"index":348,"rpid":101,"type":""},{"func":"inspect","loop":false,"index":350,"rpid":100,"type":""},{"func":"inspect","loop":false,"index":351,"rpid":99,"type":""},{"func":"inspect","loop":false,"index":352,"rpid":98,"type":""},{"func":"inspect","loop":false,"index":353,"rpid":97,"type":""},{"func":"inspect","loop":false,"index":354,"rpid":96,"type":""},{"func":"inspect","loop":false,"index":355,"rpid":95,"type":""},{"func":"inspect","loop":false,"index":356,"rpid":94,"type":""},{"func":"inspect","loop":false,"index":357,"rpid":93,"type":""},{"func":"inspect","loop":false,"index":358,"rpid":89,"type":""},{"func":"inspect","loop":false,"index":359,"rpid":91,"type":""},{"func":"inspect","loop":false,"index":360,"rpid":92,"type":""},{"func":"inspect","loop":false,"index":361,"rpid":90,"type":""},{"func":"inspect","loop":false,"index":363,"rpid":88,"type":""},{"func":"inspect","loop":false,"index":364,"rpid":87,"type":""},{"func":"inspect","loop":true,"index":365,"rpid":86,"type":""},{"func":"inspect","loop":false,"index":366,"rpid":85,"type":""},{"func":"inspect","loop":false,"index":368,"rpid":84,"type":""},{"func":"inspect","loop":false,"index":369,"rpid":83,"type":""},{"func":"inspect","loop":false,"index":370,"rpid":82,"type":""},{"func":"inspect","loop":false,"index":371,"rpid":81,"type":""},{"func":"inspect","loop":false,"index":372,"rpid":80,"type":""},{"func":"inspect","loop":false,"index":373,"rpid":79,"type":""},{"func":"inspect","loop":false,"index":374,"rpid":75,"type":""},{"func":"inspect","loop":false,"index":375,"rpid":77,"type":""},{"func":"inspect","loop":false,"index":376,"rpid":78,"type":""},{"func":"inspect","loop":false,"index":377,"rpid":76,"type":""},{"func":"inspect","loop":false,"index":379,"rpid":74,"type":""},{"func":"inspect","loop":false,"index":380,"rpid":73,"type":""},{"func":"inspect","loop":true,"index":381,"rpid":72,"type":""},{"func":"inspect","loop":false,"index":382,"rpid":71,"type":""},{"func":"inspect","loop":false,"index":384,"rpid":70,"type":""},{"func":"inspect","loop":false,"index":385,"rpid":69,"type":""},{"func":"inspect","loop":false,"index":386,"rpid":68,"type":""},{"func":"inspect","loop":false,"index":387,"rpid":67,"type":""},{"func":"inspect","loop":false,"index":388,"rpid":66,"type":""},{"func":"inspect","loop":false,"index":389,"rpid":65,"type":""},{"func":"inspect","loop":false,"index":390,"rpid":64,"type":""},{"func":"inspect","loop":false,"index":391,"rpid":63,"type":""},{"func":"inspect","loop":false,"index":392,"rpid":62,"type":""},{"func":"inspect","loop":false,"index":393,"rpid":61,"type":""},{"func":"inspect","loop":false,"index":394,"rpid":57,"type":""},{"func":"inspect","loop":false,"index":395,"rpid":59,"type":""},{"func":"inspect","loop":false,"index":396,"rpid":60,"type":""},{"func":"inspect","loop":false,"index":397,"rpid":58,"type":""},{"func":"inspect","loop":false,"index":399,"rpid":56,"type":""},{"func":"inspect","loop":false,"index":400,"rpid":55,"type":""},{"func":"inspect","loop":true,"index":401,"rpid":54,"type":""},{"func":"inspect","loop":false,"index":402,"rpid":53,"type":""},{"func":"inspect","loop":false,"index":404,"rpid":52,"type":""},{"func":"inspect","loop":false,"index":405,"rpid":51,"type":""},{"func":"inspect","loop":false,"index":406,"rpid":50,"type":""},{"func":"inspect","loop":false,"index":407,"rpid":49,"type":""},{"func":"inspect","loop":false,"index":408,"rpid":48,"type":""},{"func":"inspect","loop":false,"index":409,"rpid":47,"type":""},{"func":"inspect","loop":false,"index":410,"rpid":46,"type":""},{"func":"inspect","loop":false,"index":411,"rpid":45,"type":""},{"func":"inspect","loop":false,"index":412,"rpid":44,"type":""},{"func":"inspect","loop":false,"index":413,"rpid":40,"type":""},{"func":"inspect","loop":false,"index":414,"rpid":42,"type":""},{"func":"inspect","loop":false,"index":415,"rpid":43,"type":""},{"func":"inspect","loop":false,"index":416,"rpid":41,"type":""},{"func":"inspect","loop":false,"index":418,"rpid":39,"type":""},{"func":"inspect","loop":false,"index":419,"rpid":38,"type":""},{"func":"inspect","loop":false,"index":420,"rpid":37,"type":""},{"func":"inspect","loop":false,"index":421,"rpid":36,"type":""},{"func":"inspect","loop":true,"index":422,"rpid":35,"type":""},{"func":"inspect","loop":false,"index":423,"rpid":34,"type":""},{"func":"inspect","loop":false,"index":425,"rpid":33,"type":""},{"func":"inspect","loop":false,"index":426,"rpid":32,"type":""},{"func":"inspect","loop":false,"index":427,"rpid":31,"type":""},{"func":"inspect","loop":false,"index":428,"rpid":30,"type":""},{"func":"inspect","loop":false,"index":429,"rpid":29,"type":""},{"func":"inspect","loop":false,"index":430,"rpid":28,"type":""},{"func":"inspect","loop":false,"index":431,"rpid":2,"type":""},{"func":"inspect","loop":false,"index":432,"rpid":3,"type":""},{"func":"inspect","loop":false,"index":433,"rpid":27,"type":""},{"func":"inspect","loop":false,"index":435,"rpid":1,"type":""},{"func":"inspect","loop":false,"index":436,"rpid":0,"type":""},{"func":"inspect","loop":false,"index":437,"rpid":26,"type":""},{"func":"inspect","loop":false,"index":438,"rpid":25,"type":""},{"func":"inspect","loop":true,"index":439,"rpid":24,"type":""},{"func":"inspect","loop":false,"index":440,"rpid":23,"type":""},{"func":"inspect","loop":false,"index":442,"rpid":22,"type":""},{"func":"inspect","loop":false,"index":443,"rpid":21,"type":""},{"func":"inspect","loop":false,"index":444,"rpid":20,"type":""},{"func":"inspect","loop":false,"index":445,"rpid":19,"type":""},{"func":"inspect","loop":false,"index":446,"rpid":18,"type":""},{"func":"inspect","loop":false,"index":447,"rpid":17,"type":""},{"func":"inspect","loop":false,"index":448,"rpid":16,"type":""},{"func":"inspect","loop":false,"index":449,"rpid":15,"type":""},{"func":"inspect","loop":false,"index":450,"rpid":14,"type":""},{"func":"inspect","loop":false,"index":451,"rpid":13,"type":""},{"func":"inspect","loop":false,"index":452,"rpid":12,"type":""},{"func":"inspect","loop":false,"index":453,"rpid":11,"type":""},{"func":"inspect","loop":false,"index":454,"rpid":7,"type":""},{"func":"inspect","loop":false,"index":455,"rpid":9,"type":""},{"func":"inspect","loop":false,"index":456,"rpid":10,"type":""},{"func":"inspect","loop":false,"index":457,"rpid":8,"type":""},{"func":"inspect","loop":false,"index":459,"rpid":6,"type":""},{"func":"inspect","loop":false,"index":460,"rpid":5,"type":""},{"func":"__list_add","loop":false,"index":462,"rpid":0,"type":"exit"},{"func":"__list_add","loop":false,"index":463,"rpid":14,"type":"entry"},{"func":"__list_add","loop":false,"index":464,"rpid":13,"type":""},{"func":"__list_add","loop":false,"index":465,"rpid":12,"type":""},{"func":"__list_add","loop":false,"index":466,"rpid":11,"type":""},{"func":"__list_add","loop":false,"index":467,"rpid":10,"type":""},{"func":"__list_add","loop":false,"index":468,"rpid":9,"type":""},{"func":"__list_add","loop":false,"index":469,"rpid":8,"type":""},{"func":"__list_add","loop":false,"index":470,"rpid":7,"type":""},{"func":"__list_add","loop":false,"index":471,"rpid":6,"type":""},{"func":"__list_add","loop":false,"index":472,"rpid":5,"type":""},{"func":"__list_add","loop":false,"index":473,"rpid":4,"type":""},{"func":"__list_add","loop":false,"index":474,"rpid":3,"type":""},{"func":"__list_add","loop":false,"index":475,"rpid":2,"type":""},{"func":"__list_add","loop":false,"index":476,"rpid":1,"type":""},{"func":"__list_del","loop":false,"index":478,"rpid":0,"type":"exit"},{"func":"__list_del","loop":false,"index":479,"rpid":8,"type":"entry"},{"func":"__list_del","loop":false,"index":480,"rpid":7,"type":""},{"func":"__list_del","loop":false,"index":481,"rpid":6,"type":""},{"func":"__list_del","loop":false,"index":482,"rpid":5,"type":""},{"func":"__list_del","loop":false,"index":483,"rpid":4,"type":""},{"func":"__list_del","loop":false,"index":484,"rpid":3,"type":""},{"func":"__list_del","loop":false,"index":485,"rpid":2,"type":""},{"func":"__list_del","loop":false,"index":486,"rpid":1,"type":""},{"func":"list_add","loop":false,"index":488,"rpid":0,"type":"exit"},{"func":"list_add","loop":false,"index":489,"rpid":5,"type":"entry"},{"func":"list_add","loop":false,"index":490,"rpid":4,"type":""},{"func":"list_add","loop":false,"index":491,"rpid":3,"type":""},{"func":"list_add","loop":false,"index":492,"rpid":2,"type":""},{"func":"list_add","loop":false,"index":493,"rpid":1,"type":""},{"func":"list_move","loop":false,"index":495,"rpid":0,"type":"exit"},{"func":"list_move","loop":false,"index":496,"rpid":12,"type":"entry"},{"func":"list_move","loop":false,"index":497,"rpid":11,"type":""},{"func":"list_move","loop":false,"index":498,"rpid":10,"type":""},{"func":"list_move","loop":false,"index":499,"rpid":9,"type":""},{"func":"list_move","loop":false,"index":500,"rpid":8,"type":""},{"func":"list_move","loop":false,"index":501,"rpid":7,"type":""},{"func":"list_move","loop":false,"index":502,"rpid":6,"type":""},{"func":"list_move","loop":false,"index":503,"rpid":5,"type":""},{"func":"list_move","loop":false,"index":504,"rpid":4,"type":""},{"func":"list_move","loop":false,"index":505,"rpid":3,"type":""},{"func":"list_move","loop":false,"index":506,"rpid":2,"type":""},{"func":"list_move","loop":false,"index":507,"rpid":1,"type":""},{"func":"gl_insert","loop":false,"index":509,"rpid":0,"type":"exit"},{"func":"gl_insert","loop":false,"index":510,"rpid":43,"type":"entry"},{"func":"gl_insert","loop":false,"index":511,"rpid":42,"type":""},{"func":"gl_insert","loop":false,"index":512,"rpid":41,"type":""},{"func":"gl_insert","loop":false,"index":513,"rpid":40,"type":""},{"func":"gl_insert","loop":false,"index":514,"rpid":39,"type":""},{"func":"gl_insert","loop":false,"index":515,"rpid":38,"type":""},{"func":"gl_insert","loop":false,"index":516,"rpid":37,"type":""},{"func":"gl_insert","loop":false,"index":517,"rpid":36,"type":""},{"func":"gl_insert","loop":false,"index":518,"rpid":35,"type":""},{"func":"gl_insert","loop":false,"index":519,"rpid":34,"type":""},{"func":"gl_insert","loop":false,"index":520,"rpid":33,"type":""},{"func":"gl_insert","loop":false,"index":521,"rpid":32,"type":""},{"func":"gl_insert","loop":false,"index":522,"rpid":31,"type":""},{"func":"gl_insert","loop":false,"index":523,"rpid":30,"type":""},{"func":"gl_insert","loop":false,"index":524,"rpid":29,"type":""},{"func":"gl_insert","loop":false,"index":525,"rpid":28,"type":""},{"func":"gl_insert","loop":false,"index":526,"rpid":27,"type":""},{"func":"gl_insert","loop":false,"index":527,"rpid":26,"type":""},{"func":"gl_insert","loop":false,"index":528,"rpid":25,"type":""},{"func":"gl_insert","loop":false,"index":529,"rpid":21,"type":""},{"func":"gl_insert","loop":false,"index":530,"rpid":23,"type":""},{"func":"gl_insert","loop":false,"index":531,"rpid":24,"type":""},{"func":"gl_insert","loop":false,"index":532,"rpid":22,"type":""},{"func":"gl_insert","loop":false,"index":533,"rpid":20,"type":""},{"func":"gl_insert","loop":false,"index":534,"rpid":19,"type":""},{"func":"gl_insert","loop":false,"index":535,"rpid":18,"type":""},{"func":"gl_insert","loop":false,"index":536,"rpid":17,"type":""},{"func":"gl_insert","loop":false,"index":537,"rpid":16,"type":""},{"func":"gl_insert","loop":true,"index":538,"rpid":15,"type":""},{"func":"gl_insert","loop":false,"index":539,"rpid":14,"type":""},{"func":"gl_insert","loop":false,"index":541,"rpid":13,"type":""},{"func":"gl_insert","loop":false,"index":542,"rpid":12,"type":""},{"func":"gl_insert","loop":false,"index":543,"rpid":11,"type":""},{"func":"gl_insert","loop":false,"index":544,"rpid":10,"type":""},{"func":"gl_insert","loop":false,"index":545,"rpid":9,"type":""},{"func":"gl_insert","loop":false,"index":546,"rpid":8,"type":""},{"func":"gl_insert","loop":false,"index":547,"rpid":7,"type":""},{"func":"gl_insert","loop":false,"index":548,"rpid":6,"type":""},{"func":"gl_insert","loop":false,"index":549,"rpid":5,"type":""},{"func":"gl_insert","loop":false,"index":550,"rpid":4,"type":""},{"func":"gl_insert","loop":false,"index":551,"rpid":3,"type":""},{"func":"gl_insert","loop":false,"index":553,"rpid":2,"type":""},{"func":"gl_insert","loop":false,"index":554,"rpid":1,"type":""},{"func":"gl_read","loop":false,"index":556,"rpid":0,"type":"exit"},{"func":"gl_read","loop":false,"index":557,"rpid":15,"type":"entry"},{"func":"gl_read","loop":false,"index":558,"rpid":14,"type":""},{"func":"gl_read","loop":false,"index":559,"rpid":13,"type":""},{"func":"gl_read","loop":false,"index":560,"rpid":12,"type":""},{"func":"gl_read","loop":true,"index":561,"rpid":11,"type":""},{"func":"gl_read","loop":false,"index":562,"rpid":10,"type":""},{"func":"gl_read","loop":false,"index":564,"rpid":9,"type":""},{"func":"gl_read","loop":false,"index":565,"rpid":8,"type":""},{"func":"gl_read","loop":false,"index":566,"rpid":7,"type":""},{"func":"gl_read","loop":false,"index":567,"rpid":6,"type":""},{"func":"gl_read","loop":false,"index":568,"rpid":4,"type":""},{"func":"gl_read","loop":false,"index":569,"rpid":5,"type":""},{"func":"gl_read","loop":false,"index":570,"rpid":3,"type":""},{"func":"gl_read","loop":false,"index":572,"rpid":2,"type":""},{"func":"gl_read","loop":false,"index":573,"rpid":1,"type":""},{"func":"gl_destroy","loop":false,"index":575,"rpid":14,"type":"exit"},{"func":"gl_destroy","loop":false,"index":576,"rpid":40,"type":"entry"},{"func":"gl_destroy","loop":false,"index":577,"rpid":39,"type":""},{"func":"gl_destroy","loop":false,"index":578,"rpid":38,"type":""},{"func":"gl_destroy","loop":false,"index":579,"rpid":37,"type":""},{"func":"gl_destroy","loop":false,"index":580,"rpid":36,"type":""},{"func":"gl_destroy","loop":false,"index":581,"rpid":35,"type":""},{"func":"gl_destroy","loop":false,"index":582,"rpid":34,"type":""},{"func":"gl_destroy","loop":false,"index":583,"rpid":33,"type":""},{"func":"gl_destroy","loop":false,"index":584,"rpid":32,"type":""},{"func":"gl_destroy","loop":false,"index":585,"rpid":31,"type":""},{"func":"gl_destroy","loop":false,"index":586,"rpid":30,"type":""},{"func":"gl_destroy","loop":false,"index":587,"rpid":29,"type":""},{"func":"gl_destroy","loop":false,"index":588,"rpid":28,"type":""},{"func":"gl_destroy","loop":false,"index":589,"rpid":27,"type":""},{"func":"gl_destroy","loop":false,"index":590,"rpid":26,"type":""},{"func":"gl_destroy","loop":false,"index":591,"rpid":25,"type":""},{"func":"gl_destroy","loop":true,"index":592,"rpid":24,"type":""},{"func":"gl_destroy","loop":false,"index":593,"rpid":23,"type":""},{"func":"gl_destroy","loop":false,"index":595,"rpid":22,"type":""},{"func":"gl_destroy","loop":false,"index":596,"rpid":21,"type":""},{"func":"gl_destroy","loop":false,"index":597,"rpid":20,"type":""},{"func":"gl_destroy","loop":false,"index":598,"rpid":19,"type":""},{"func":"gl_destroy","loop":false,"index":599,"rpid":18,"type":""},{"func":"gl_destroy","loop":false,"index":600,"rpid":12,"type":""},{"func":"gl_destroy","loop":false,"index":601,"rpid":13,"type":""},{"func":"gl_destroy","loop":false,"index":602,"rpid":17,"type":""},{"func":"gl_destroy","loop":false,"index":604,"rpid":11,"type":""},{"func":"gl_destroy","loop":false,"index":605,"rpid":10,"type":""},{"func":"gl_destroy","loop":false,"index":606,"rpid":9,"type":""},{"func":"gl_destroy","loop":false,"index":607,"rpid":8,"type":""},{"func":"gl_destroy","loop":false,"index":608,"rpid":7,"type":""},{"func":"gl_destroy","loop":false,"index":609,"rpid":6,"type":""},{"func":"gl_destroy","loop":false,"index":610,"rpid":5,"type":""},{"func":"gl_destroy","loop":false,"index":611,"rpid":4,"type":""},{"func":"gl_destroy","loop":false,"index":612,"rpid":3,"type":""},{"func":"gl_destroy","loop":false,"index":613,"rpid":2,"type":""},{"func":"gl_destroy","loop":false,"index":614,"rpid":1,"type":""},{"func":"gl_destroy","loop":false,"index":615,"rpid":0,"type":""},{"func":"gl_destroy","loop":false,"index":616,"rpid":16,"type":""},{"func":"gl_destroy","loop":false,"index":617,"rpid":15,"type":""},{"func":"val_from_node","loop":false,"index":619,"rpid":0,"type":"exit"},{"func":"val_from_node","loop":false,"index":620,"rpid":18,"type":"entry"},{"func":"val_from_node","loop":false,"index":621,"rpid":17,"type":""},{"func":"val_from_node","loop":false,"index":622,"rpid":16,"type":""},{"func":"val_from_node","loop":false,"index":623,"rpid":15,"type":""},{"func":"val_from_node","loop":false,"index":624,"rpid":14,"type":""},{"func":"val_from_node","loop":false,"index":625,"rpid":13,"type":""},{"func":"val_from_node","loop":false,"index":626,"rpid":12,"type":""},{"func":"val_from_node","loop":false,"index":627,"rpid":11,"type":""},{"func":"val_from_node","loop":false,"index":628,"rpid":10,"type":""},{"func":"val_from_node","loop":false,"index":629,"rpid":9,"type":""},{"func":"val_from_node","loop":false,"index":630,"rpid":8,"type":""},{"func":"val_from_node","loop":false,"index":631,"rpid":7,"type":""},{"func":"val_from_node","loop":false,"index":632,"rpid":6,"type":""},{"func":"val_from_node","loop":false,"index":633,"rpid":5,"type":""},{"func":"val_from_node","loop":false,"index":634,"rpid":4,"type":""},{"func":"val_from_node","loop":false,"index":635,"rpid":3,"type":""},{"func":"val_from_node","loop":false,"index":636,"rpid":2,"type":""},{"func":"val_from_node","loop":false,"index":637,"rpid":1,"type":""},{"func":"gl_sort_pass","loop":false,"index":639,"rpid":12,"type":"exit"},{"func":"gl_sort_pass","loop":false,"index":640,"rpid":36,"type":"entry"},{"func":"gl_sort_pass","loop":false,"index":641,"rpid":35,"type":""},{"func":"gl_sort_pass","loop":false,"index":642,"rpid":34,"type":""},{"func":"gl_sort_pass","loop":false,"index":643,"rpid":33,"type":""},{"func":"gl_sort_pass","loop":false,"index":644,"rpid":32,"type":""},{"func":"gl_sort_pass","loop":false,"index":645,"rpid":31,"type":""},{"func":"gl_sort_pass","loop":false,"index":646,"rpid":30,"type":""},{"func":"gl_sort_pass","loop":false,"index":647,"rpid":29,"type":""},{"func":"gl_sort_pass","loop":false,"index":648,"rpid":28,"type":""},{"func":"gl_sort_pass","loop":false,"index":649,"rpid":27,"type":""},{"func":"gl_sort_pass","loop":false,"index":650,"rpid":26,"type":""},{"func":"gl_sort_pass","loop":false,"index":651,"rpid":25,"type":""},{"func":"gl_sort_pass","loop":false,"index":652,"rpid":24,"type":""},{"func":"gl_sort_pass","loop":false,"index":653,"rpid":23,"type":""},{"func":"gl_sort_pass","loop":false,"index":654,"rpid":22,"type":""},{"func":"gl_sort_pass","loop":true,"index":655,"rpid":21,"type":""},{"func":"gl_sort_pass","loop":false,"index":656,"rpid":20,"type":""},{"func":"gl_sort_pass","loop":true,"index":658,"rpid":19,"type":""},{"func":"gl_sort_pass","loop":false,"index":659,"rpid":18,"type":""},{"func":"gl_sort_pass","loop":false,"index":660,"rpid":17,"type":""},{"func":"gl_sort_pass","loop":false,"index":661,"rpid":16,"type":""},{"func":"gl_sort_pass","loop":false,"index":662,"rpid":10,"type":""},{"func":"gl_sort_pass","loop":false,"index":663,"rpid":11,"type":""},{"func":"gl_sort_pass","loop":false,"index":664,"rpid":15,"type":""},{"func":"gl_sort_pass","loop":false,"index":666,"rpid":9,"type":""},{"func":"gl_sort_pass","loop":false,"index":667,"rpid":8,"type":""},{"func":"gl_sort_pass","loop":false,"index":668,"rpid":7,"type":""},{"func":"gl_sort_pass","loop":false,"index":669,"rpid":6,"type":""},{"func":"gl_sort_pass","loop":false,"index":670,"rpid":4,"type":""},{"func":"gl_sort_pass","loop":false,"index":671,"rpid":1,"type":""},{"func":"gl_sort_pass","loop":false,"index":672,"rpid":5,"type":""},{"func":"gl_sort_pass","loop":false,"index":673,"rpid":0,"type":""},{"func":"gl_sort_pass","loop":false,"index":675,"rpid":3,"type":""},{"func":"gl_sort_pass","loop":false,"index":676,"rpid":2,"type":""},{"func":"gl_sort_pass","loop":false,"index":677,"rpid":14,"type":""},{"func":"gl_sort_pass","loop":false,"index":678,"rpid":13,"type":""},{"func":"gl_sort","loop":false,"index":680,"rpid":0,"type":"exit"},{"func":"gl_sort","loop":false,"index":681,"rpid":12,"type":"entry"},{"func":"gl_sort","loop":false,"index":682,"rpid":11,"type":""},{"func":"gl_sort","loop":false,"index":683,"rpid":10,"type":""},{"func":"gl_sort","loop":true,"index":684,"rpid":9,"type":""},{"func":"gl_sort","loop":false,"index":685,"rpid":8,"type":""},{"func":"gl_sort","loop":false,"index":687,"rpid":7,"type":""},{"func":"gl_sort","loop":false,"index":688,"rpid":6,"type":""},{"func":"gl_sort","loop":false,"index":689,"rpid":4,"type":""},{"func":"gl_sort","loop":false,"index":690,"rpid":5,"type":""},{"func":"gl_sort","loop":false,"index":691,"rpid":3,"type":""},{"func":"gl_sort","loop":false,"index":693,"rpid":2,"type":""},{"func":"gl_sort","loop":false,"index":694,"rpid":1,"type":""},{"func":"main","loop":false,"index":696,"rpid":0,"type":"exit"},{"func":"main","loop":false,"index":697,"rpid":37,"type":"entry"},{"func":"main","loop":false,"index":698,"rpid":10,"type":""},{"func":"main","loop":false,"index":699,"rpid":9,"type":""},{"func":"main","loop":false,"index":700,"rpid":8,"type":""},{"func":"main","loop":false,"index":701,"rpid":7,"type":""},{"func":"main","loop":false,"index":702,"rpid":6,"type":""},{"func":"main","loop":false,"index":703,"rpid":5,"type":""},{"func":"main","loop":false,"index":704,"rpid":4,"type":""},{"func":"main","loop":false,"index":705,"rpid":3,"type":""},{"func":"main","loop":false,"index":706,"rpid":2,"type":""},{"func":"main","loop":false,"index":707,"rpid":1,"type":""},{"func":"main","loop":false,"index":709,"rpid":36,"type":""},{"func":"main","loop":false,"index":710,"rpid":35,"type":""},{"func":"main","loop":false,"index":711,"rpid":34,"type":""},{"func":"main","loop":false,"index":712,"rpid":33,"type":""},{"func":"main","loop":false,"index":713,"rpid":32,"type":""},{"func":"main","loop":false,"index":714,"rpid":31,"type":""},{"func":"main","loop":false,"index":715,"rpid":30,"type":""},{"func":"main","loop":false,"index":716,"rpid":29,"type":""},{"func":"main","loop":false,"index":717,"rpid":28,"type":""},{"func":"main","loop":false,"index":718,"rpid":27,"type":""},{"func":"main","loop":false,"index":719,"rpid":26,"type":""},{"func":"main","loop":false,"index":720,"rpid":25,"type":""},{"func":"main","loop":false,"index":721,"rpid":24,"type":""},{"func":"main","loop":false,"index":722,"rpid":23,"type":""},{"func":"main","loop":false,"index":723,"rpid":22,"type":""},{"func":"main","loop":false,"index":724,"rpid":21,"type":""},{"func":"main","loop":false,"index":725,"rpid":20,"type":""},{"func":"main","loop":false,"index":726,"rpid":19,"type":""},{"func":"main","loop":false,"index":727,"rpid":18,"type":""},{"func":"main","loop":false,"index":728,"rpid":17,"type":""},{"func":"main","loop":false,"index":729,"rpid":16,"type":""},{"func":"main","loop":false,"index":730,"rpid":15,"type":""},{"func":"main","loop":false,"index":731,"rpid":14,"type":""},{"func":"main","loop":false,"index":732,"rpid":13,"type":""},{"func":"main","loop":false,"index":733,"rpid":12,"type":""},{"func":"main","loop":false,"index":734,"rpid":11,"type":""}],
"edges":[{"file":"test\/bs2.i","line":787,"source":659,"type":"StatementEdge","stmt":"__cil_tmp9 = (unsigned int)pos1;","target":660},{"file":"<none>","line":0,"source":681,"type":"BlankEdge","stmt":"Function start dummy edge","target":682},{"file":"test\/bs2.i","line":672,"source":554,"type":"ReturnStatementEdge","stmt":"return;","target":509},{"file":"test\/bs2.i","line":87,"source":50,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp34;","target":51},{"file":"test\/bs2.i","line":119,"source":82,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp66;","target":83},{"file":"test\/bs2.i","line":393,"source":320,"type":"StatementEdge","stmt":"__cil_tmp68 = __cil_tmp67 + __cil_tmp66;","target":321},{"file":"test\/bs2.i","line":284,"source":223,"type":"BlankEdge","stmt":"Goto: while_5_break","target":228},{"file":"test\/bs2.i","line":413,"source":336,"type":"StatementEdge","stmt":"__cil_tmp73 = (unsigned int)__cil_tmp72;","target":337},{"file":"<none>","line":0,"source":17,"type":"BlankEdge","stmt":"Function start dummy edge","target":18},{"file":"test\/bs2.i","line":644,"source":530,"type":"StatementEdge","stmt":"abort();","target":532},{"file":"test\/bs2.i","line":529,"source":433,"type":"BlankEdge","stmt":"Goto: while_16_break","target":437},{"file":"test\/bs2.i","line":234,"source":185,"type":"StatementEdge","stmt":"head = (const struct list_head *)__cil_tmp15;","target":186},{"file":"test\/bs2.i","line":663,"source":546,"type":"StatementEdge","stmt":"__cil_tmp12 = (unsigned int)node;","target":547},{"file":"test\/bs2.i","line":438,"source":357,"type":"AssumeEdge","stmt":"[!(__cil_tmp82 == 0)]","target":360},{"file":"test\/bs2.i","line":748,"source":622,"type":"DeclarationEdge","stmt":"struct node *__cil_tmp3;","target":623},{"file":"test\/bs2.i","line":465,"source":374,"type":"BlankEdge","stmt":"Goto: while_13_break","target":379},{"file":"test\/bs2.i","line":342,"source":277,"type":"StatementEdge","stmt":"__cil_tmp47 = 16;","target":278},{"file":"test\/bs2.i","line":575,"source":471,"type":"StatementEdge","stmt":"*((struct list_head **)new) = next;","target":472},{"file":"test\/bs2.i","line":146,"source":109,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp93;","target":110},{"file":"test\/bs2.i","line":147,"source":110,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp94;","target":111},{"file":"test\/bs2.i","line":163,"source":126,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp110;","target":127},{"file":"test\/bs2.i","line":705,"source":584,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp8;","target":585},{"file":"test\/bs2.i","line":729,"source":605,"type":"StatementEdge","stmt":"__cil_tmp6 = (struct node *)0;","target":606},{"file":"<none>","line":0,"source":676,"type":"BlankEdge","stmt":"","target":655},{"file":"test\/bs2.i","line":841,"source":702,"type":"CallToReturnEdge","stmt":"inspect(__cil_tmp1);","target":703},{"file":"test\/bs2.i","line":438,"source":357,"type":"AssumeEdge","stmt":"[__cil_tmp82 == 0]","target":359},{"file":"test\/bs2.i","line":687,"source":567,"type":"AssumeEdge","stmt":"[tmp___0 == 0]","target":570},{"file":"test\/bs2.i","line":62,"source":25,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp9;","target":26},{"file":"test\/bs2.i","line":263,"source":206,"type":"BlankEdge","stmt":"Goto: while_4_break","target":211},{"file":"test\/bs2.i","line":525,"source":428,"type":"StatementEdge","stmt":"__cil_tmp109 = (const struct list_head *)__cil_tmp108;","target":429},{"file":"test\/bs2.i","line":668,"source":551,"type":"BlankEdge","stmt":"Goto: while_18_break","target":553},{"file":"test\/bs2.i","line":638,"source":525,"type":"StatementEdge","stmt":"__cil_tmp4 = 20U;","target":526},{"file":"test\/bs2.i","line":559,"source":454,"type":"BlankEdge","stmt":"Goto: while_17_break","target":459},{"file":"test\/bs2.i","line":770,"source":643,"type":"DeclarationEdge","stmt":"struct list_head *pos1;","target":644},{"file":"test\/bs2.i","line":791,"source":664,"type":"BlankEdge","stmt":"Goto: while_21_break","target":677},{"file":"test\/bs2.i","line":367,"source":298,"type":"StatementEdge","stmt":"__cil_tmp57 = (unsigned int)node;","target":299},{"file":"test\/bs2.i","line":25,"source":714,"type":"DeclarationEdge","stmt":"typedef unsigned int size_t;","target":715},{"file":"test\/bs2.i","line":484,"source":395,"type":"CallToReturnEdge","stmt":"fail();","target":397},{"file":"test\/bs2.i","line":649,"source":529,"type":"StatementEdge","stmt":"*((int *)node) = value;","target":533},{"file":"test\/bs2.i","line":548,"source":449,"type":"StatementEdge","stmt":"__cil_tmp119 = __cil_tmp118 - __cil_tmp117;","target":450},{"file":"test\/bs2.i","line":599,"source":492,"type":"CallToReturnEdge","stmt":"__list_add(new, head, __cil_tmp3);","target":493},{"file":"test\/bs2.i","line":847,"source":707,"type":"ReturnStatementEdge","stmt":"return 0;","target":696},{"file":"test\/bs2.i","line":569,"source":466,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp6;","target":467},{"file":"test\/bs2.i","line":94,"source":57,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp41;","target":58},{"file":"test\/bs2.i","line":168,"source":131,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp115;","target":132},{"file":"test\/bs2.i","line":142,"source":105,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp89;","target":106},{"file":"test\/bs2.i","line":788,"source":660,"type":"StatementEdge","stmt":"__cil_tmp10 = (unsigned int)(&gl_list);","target":661},{"file":"test\/bs2.i","line":253,"source":202,"type":"StatementEdge","stmt":"__cil_tmp17 = *((struct list_head * const *)head);","target":203},{"file":"test\/bs2.i","line":783,"source":655,"type":"BlankEdge","stmt":"","target":656},{"file":"test\/bs2.i","line":363,"source":294,"type":"StatementEdge","stmt":"__cil_tmp53 = (unsigned int)node;","target":295},{"file":"test\/bs2.i","line":566,"source":723,"type":"DeclarationEdge","stmt":"void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);","target":724},{"file":"test\/bs2.i","line":614,"source":504,"type":"StatementEdge","stmt":"__cil_tmp6 = *((struct list_head **)list);","target":505},{"file":"test\/bs2.i","line":71,"source":34,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp18;","target":35},{"file":"test\/bs2.i","line":151,"source":114,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp98;","target":115},{"file":"test\/bs2.i","line":692,"source":572,"type":"BlankEdge","stmt":"Label: while_19_break","target":573},{"file":"test\/bs2.i","line":299,"source":240,"type":"BlankEdge","stmt":"Label: while_6_continue","target":242},{"file":"test\/bs2.i","line":409,"source":332,"type":"BlankEdge","stmt":"","target":333},{"file":"test\/bs2.i","line":102,"source":65,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp49;","target":66},{"file":"test\/bs2.i","line":494,"source":400,"type":"BlankEdge","stmt":"while","target":401},{"file":"test\/bs2.i","line":544,"source":445,"type":"StatementEdge","stmt":"__cil_tmp115 = __cil_tmp114 + 4;","target":446},{"file":"test\/bs2.i","line":229,"source":181,"type":"BlankEdge","stmt":"Label: while_2_break","target":182},{"file":"test\/bs2.i","line":624,"source":513,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp4;","target":514},{"file":"test\/bs2.i","line":135,"source":98,"type":"DeclarationEdge","stmt":"int __cil_tmp82;","target":99},{"file":"test\/bs2.i","line":111,"source":74,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp58;","target":75},{"file":"test\/bs2.i","line":335,"source":270,"type":"BlankEdge","stmt":"","target":271},{"file":"test\/bs2.i","line":273,"source":218,"type":"StatementEdge","stmt":"__cil_tmp22 = __cil_tmp21 + 4;","target":219},{"file":"test\/bs2.i","line":505,"source":412,"type":"AssumeEdge","stmt":"[!(__cil_tmp104 == 0)]","target":415},{"file":"test\/bs2.i","line":418,"source":341,"type":"CallToReturnEdge","stmt":"fail();","target":343},{"file":"test\/bs2.i","line":505,"source":412,"type":"AssumeEdge","stmt":"[__cil_tmp104 == 0]","target":414},{"file":"test\/bs2.i","line":46,"source":10,"type":"BlankEdge","stmt":"Label: ERROR","target":11},{"file":"test\/bs2.i","line":175,"source":138,"type":"DeclarationEdge","stmt":"int __cil_tmp122;","target":139},{"file":"test\/bs2.i","line":238,"source":190,"type":"AssumeEdge","stmt":"[head == 0]","target":192},{"file":"test\/bs2.i","line":392,"source":319,"type":"StatementEdge","stmt":"__cil_tmp67 = (unsigned int)node;","target":320},{"file":"test\/bs2.i","line":715,"source":593,"type":"BlankEdge","stmt":"Label: while_20_continue","target":595},{"file":"test\/bs2.i","line":717,"source":596,"type":"StatementEdge","stmt":"next = *((struct list_head **)__cil_tmp2);","target":597},{"file":"test\/bs2.i","line":238,"source":190,"type":"AssumeEdge","stmt":"[!(head == 0)]","target":193},{"file":"test\/bs2.i","line":78,"source":41,"type":"DeclarationEdge","stmt":"int __cil_tmp25;","target":42},{"file":"test\/bs2.i","line":172,"source":135,"type":"DeclarationEdge","stmt":"char *__cil_tmp119;","target":136},{"file":"test\/bs2.i","line":322,"source":261,"type":"StatementEdge","stmt":"__cil_tmp42 = __cil_tmp41 == __cil_tmp37;","target":262},{"file":"<none>","line":0,"source":9,"type":"BlankEdge","stmt":"Function start dummy edge","target":10},{"file":"test\/bs2.i","line":347,"source":282,"type":"StatementEdge","stmt":"__cil_tmp52 = __cil_tmp51 == __cil_tmp46;","target":283},{"file":"test\/bs2.i","line":434,"source":353,"type":"StatementEdge","stmt":"__cil_tmp79 = (const struct node *)__cil_tmp78;","target":354},{"file":"test\/bs2.i","line":820,"source":685,"type":"BlankEdge","stmt":"Label: while_22_continue","target":687},{"file":"test\/bs2.i","line":206,"source":159,"type":"BlankEdge","stmt":"Goto: while_1_break","target":164},{"file":"test\/bs2.i","line":298,"source":239,"type":"BlankEdge","stmt":"","target":240},{"file":"test\/bs2.i","line":519,"source":421,"type":"BlankEdge","stmt":"while","target":422},{"file":"test\/bs2.i","line":338,"source":273,"type":"StatementEdge","stmt":"__cil_tmp43 = (unsigned int)node;","target":274},{"file":"test\/bs2.i","line":824,"source":688,"type":"AssumeEdge","stmt":"[!(tmp == 0)]","target":690},{"file":"test\/bs2.i","line":227,"source":176,"type":"BlankEdge","stmt":"Goto: while_2_break","target":181},{"file":"test\/bs2.i","line":450,"source":365,"type":"BlankEdge","stmt":"","target":366},{"file":"test\/bs2.i","line":824,"source":688,"type":"AssumeEdge","stmt":"[tmp == 0]","target":691},{"file":"test\/bs2.i","line":604,"source":726,"type":"DeclarationEdge","stmt":"void list_move(struct list_head *list, struct list_head *head);","target":727},{"file":"test\/bs2.i","line":55,"source":18,"type":"DeclarationEdge","stmt":"const struct node *node;","target":19},{"file":"test\/bs2.i","line":138,"source":101,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp85;","target":102},{"file":"test\/bs2.i","line":611,"source":501,"type":"StatementEdge","stmt":"__cil_tmp3 = (unsigned int)list;","target":502},{"file":"test\/bs2.i","line":269,"source":214,"type":"BlankEdge","stmt":"Label: while_5_continue","target":216},{"file":"test\/bs2.i","line":291,"source":232,"type":"StatementEdge","stmt":"__cil_tmp29 = (struct list_head *)__cil_tmp28;","target":233},{"file":"test\/bs2.i","line":308,"source":248,"type":"BlankEdge","stmt":"Label: while_6_break","target":249},{"file":"test\/bs2.i","line":357,"source":289,"type":"BlankEdge","stmt":"Label: while_8_break","target":290},{"file":"test\/bs2.i","line":425,"source":345,"type":"BlankEdge","stmt":"Label: while_11_break","target":346},{"file":"test\/bs2.i","line":608,"source":500,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp6;","target":501},{"file":"test\/bs2.i","line":627,"source":516,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp7;","target":517},{"file":"test\/bs2.i","line":136,"source":99,"type":"DeclarationEdge","stmt":"const int *__cil_tmp83;","target":100},{"file":"test\/bs2.i","line":737,"source":613,"type":"StatementEdge","stmt":"__cil_tmp14 = (void *)__cil_tmp13;","target":614},{"file":"test\/bs2.i","line":733,"source":609,"type":"StatementEdge","stmt":"__cil_tmp10 = (unsigned long)__cil_tmp9;","target":610},{"file":"test\/bs2.i","line":758,"source":631,"type":"StatementEdge","stmt":"__cil_tmp5 = __cil_tmp4 + 4;","target":632},{"file":"test\/bs2.i","line":1,"source":709,"type":"DeclarationEdge","stmt":"void abort();","target":710},{"file":"test\/bs2.i","line":95,"source":58,"type":"DeclarationEdge","stmt":"int __cil_tmp42;","target":59},{"file":"test\/bs2.i","line":767,"source":731,"type":"DeclarationEdge","stmt":"_Bool gl_sort_pass();","target":732},{"file":"test\/bs2.i","line":584,"source":480,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp3;","target":481},{"file":"test\/bs2.i","line":12,"source":6,"type":"StatementEdge","stmt":"__assert_fail(\\\"0\\\", \\\"bubble_sort-2.c\\\", 3, \\\"__PRETTY_FUNCTION__\\\");","target":7},{"file":"test\/bs2.i","line":701,"source":580,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp4;","target":581},{"file":"test\/bs2.i","line":522,"source":425,"type":"StatementEdge","stmt":"__cil_tmp106 = (unsigned int)head;","target":426},{"file":"test\/bs2.i","line":779,"source":651,"type":"StatementEdge","stmt":"any_change = 0;","target":652},{"file":"test\/bs2.i","line":773,"source":646,"type":"DeclarationEdge","stmt":"int val1;","target":647},{"file":"test\/bs2.i","line":384,"source":311,"type":"BlankEdge","stmt":"","target":312},{"file":"test\/bs2.i","line":61,"source":24,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp8;","target":25},{"file":"test\/bs2.i","line":738,"source":614,"type":"StatementEdge","stmt":"free(__cil_tmp14);","target":615},{"file":"test\/bs2.i","line":118,"source":81,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp65;","target":82},{"file":"test\/bs2.i","line":6,"source":711,"type":"DeclarationEdge","stmt":"void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function);","target":712},{"file":"test\/bs2.i","line":756,"source":629,"type":"StatementEdge","stmt":"__cil_tmp3 = (struct node *)0;","target":630},{"file":"test\/bs2.i","line":201,"source":160,"type":"CallToReturnEdge","stmt":"fail();","target":162},{"file":"test\/bs2.i","line":171,"source":134,"type":"DeclarationEdge","stmt":"char *__cil_tmp118;","target":135},{"file":"<none>","line":0,"source":463,"type":"BlankEdge","stmt":"Function start dummy edge","target":464},{"file":"<none>","line":0,"source":615,"type":"BlankEdge","stmt":"","target":592},{"file":"<none>","line":0,"source":436,"type":"BlankEdge","stmt":"","target":422},{"file":"<none>","line":0,"source":689,"type":"BlankEdge","stmt":"","target":684},{"file":"test\/bs2.i","line":290,"source":231,"type":"StatementEdge","stmt":"__cil_tmp28 = __cil_tmp27 + 4;","target":232},{"file":"test\/bs2.i","line":680,"source":560,"type":"BlankEdge","stmt":"while","target":561},{"file":"test\/bs2.i","line":651,"source":534,"type":"StatementEdge","stmt":"__cil_tmp6 = __cil_tmp5 + 4;","target":535},{"file":"test\/bs2.i","line":454,"source":369,"type":"StatementEdge","stmt":"__cil_tmp84 = (const struct node *)__cil_tmp83;","target":370},{"file":"test\/bs2.i","line":480,"source":391,"type":"StatementEdge","stmt":"__cil_tmp95 = (unsigned int)head;","target":392},{"file":"test\/bs2.i","line":517,"source":420,"type":"StatementEdge","stmt":"head = (const struct list_head *)__cil_tmp105;","target":421},{"file":"<none>","line":0,"source":161,"type":"BlankEdge","stmt":"","target":159},{"file":"test\/bs2.i","line":181,"source":143,"type":"AssumeEdge","stmt":"[!(head == 0)]","target":146},{"file":"test\/bs2.i","line":250,"source":199,"type":"BlankEdge","stmt":"Label: while_4_continue","target":201},{"file":"test\/bs2.i","line":500,"source":407,"type":"StatementEdge","stmt":"__cil_tmp100 = *((struct list_head * const *)__cil_tmp99);","target":408},{"file":"test\/bs2.i","line":650,"source":533,"type":"StatementEdge","stmt":"__cil_tmp5 = (unsigned int)node;","target":534},{"file":"test\/bs2.i","line":181,"source":143,"type":"AssumeEdge","stmt":"[head == 0]","target":145},{"file":"test\/bs2.i","line":721,"source":599,"type":"AssumeEdge","stmt":"[__cil_tmp4 != __cil_tmp3]","target":601},{"file":"test\/bs2.i","line":721,"source":599,"type":"AssumeEdge","stmt":"[!(__cil_tmp4 != __cil_tmp3)]","target":602},{"file":"test\/bs2.i","line":134,"source":97,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp81;","target":98},{"file":"test\/bs2.i","line":829,"source":693,"type":"BlankEdge","stmt":"Label: while_22_break","target":694},{"file":"test\/bs2.i","line":687,"source":567,"type":"AssumeEdge","stmt":"[!(tmp___0 == 0)]","target":569},{"file":"test\/bs2.i","line":339,"source":274,"type":"StatementEdge","stmt":"__cil_tmp44 = __cil_tmp43 + 12;","target":275},{"file":"test\/bs2.i","line":372,"source":303,"type":"AssumeEdge","stmt":"[__cil_tmp61 == 0]","target":305},{"file":"test\/bs2.i","line":372,"source":303,"type":"AssumeEdge","stmt":"[!(__cil_tmp61 == 0)]","target":306},{"file":"test\/bs2.i","line":659,"source":542,"type":"StatementEdge","stmt":"__cil_tmp9 = __cil_tmp8 + 12;","target":543},{"file":"test\/bs2.i","line":193,"source":152,"type":"BlankEdge","stmt":"Label: while_1_continue","target":154},{"file":"<none>","line":0,"source":265,"type":"BlankEdge","stmt":"","target":263},{"file":"test\/bs2.i","line":676,"source":558,"type":"DeclarationEdge","stmt":"int tmp;","target":559},{"file":"test\/bs2.i","line":819,"source":684,"type":"BlankEdge","stmt":"","target":685},{"file":"<none>","line":0,"source":576,"type":"BlankEdge","stmt":"Function start dummy edge","target":577},{"file":"test\/bs2.i","line":274,"source":219,"type":"StatementEdge","stmt":"__cil_tmp23 = *((struct list_head * const *)__cil_tmp22);","target":220},{"file":"test\/bs2.i","line":391,"source":318,"type":"StatementEdge","stmt":"__cil_tmp66 = 16;","target":319},{"file":"test\/bs2.i","line":774,"source":647,"type":"DeclarationEdge","stmt":"int tmp___0;","target":648},{"file":"test\/bs2.i","line":385,"source":312,"type":"BlankEdge","stmt":"Label: while_10_continue","target":314},{"file":"<none>","line":0,"source":327,"type":"BlankEdge","stmt":"","target":325},{"file":"test\/bs2.i","line":40,"source":718,"type":"DeclarationEdge","stmt":"void free(void *__ptr);","target":719},{"file":"test\/bs2.i","line":212,"source":167,"type":"BlankEdge","stmt":"Label: while_2_continue","target":169},{"file":"<none>","line":0,"source":496,"type":"BlankEdge","stmt":"Function start dummy edge","target":497},{"file":"test\/bs2.i","line":317,"source":256,"type":"StatementEdge","stmt":"__cil_tmp37 = (unsigned int)__cil_tmp36;","target":257},{"file":"test\/bs2.i","line":471,"source":382,"type":"BlankEdge","stmt":"Label: while_14_continue","target":384},{"file":"test\/bs2.i","line":112,"source":75,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp59;","target":76},{"file":"test\/bs2.i","line":552,"source":453,"type":"AssumeEdge","stmt":"[__cil_tmp122 == 0]","target":455},{"file":"test\/bs2.i","line":784,"source":656,"type":"BlankEdge","stmt":"Label: while_21_continue","target":658},{"file":"test\/bs2.i","line":179,"source":139,"type":"BlankEdge","stmt":"while","target":140},{"file":"test\/bs2.i","line":552,"source":453,"type":"AssumeEdge","stmt":"[!(__cil_tmp122 == 0)]","target":456},{"file":"test\/bs2.i","line":101,"source":64,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp48;","target":65},{"file":"test\/bs2.i","line":621,"source":727,"type":"DeclarationEdge","stmt":"void gl_insert(int value);","target":728},{"file":"test\/bs2.i","line":79,"source":42,"type":"DeclarationEdge","stmt":"struct node *__cil_tmp26;","target":43},{"file":"test\/bs2.i","line":211,"source":165,"type":"BlankEdge","stmt":"while","target":166},{"file":"test\/bs2.i","line":639,"source":526,"type":"StatementEdge","stmt":"tmp = malloc(__cil_tmp4);","target":527},{"file":"test\/bs2.i","line":591,"source":486,"type":"ReturnStatementEdge","stmt":"return;","target":478},{"file":"test\/bs2.i","line":489,"source":394,"type":"BlankEdge","stmt":"Goto: while_14_break","target":399},{"file":"test\/bs2.i","line":167,"source":130,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp114;","target":131},{"file":"test\/bs2.i","line":343,"source":278,"type":"StatementEdge","stmt":"__cil_tmp48 = (unsigned int)node;","target":279},{"file":"test\/bs2.i","line":306,"source":243,"type":"BlankEdge","stmt":"Goto: while_6_break","target":248},{"file":"test\/bs2.i","line":573,"source":469,"type":"StatementEdge","stmt":"__cil_tmp5 = __cil_tmp4 + 4;","target":470},{"file":"test\/bs2.i","line":576,"source":472,"type":"StatementEdge","stmt":"__cil_tmp6 = (unsigned int)new;","target":473},{"file":"test\/bs2.i","line":683,"source":564,"type":"StatementEdge","stmt":"tmp = __VERIFIER_nondet_int();","target":565},{"file":"test\/bs2.i","line":412,"source":335,"type":"StatementEdge","stmt":"__cil_tmp72 = (const struct node *)head;","target":336},{"file":"<none>","line":0,"source":7,"type":"BlankEdge","stmt":"","target":4},{"file":"test\/bs2.i","line":369,"source":300,"type":"StatementEdge","stmt":"__cil_tmp59 = *((struct list_head * const *)__cil_tmp58);","target":301},{"file":"test\/bs2.i","line":810,"source":677,"type":"BlankEdge","stmt":"Label: while_21_break","target":678},{"file":"test\/bs2.i","line":547,"source":448,"type":"StatementEdge","stmt":"__cil_tmp118 = (char *)head;","target":449},{"file":"test\/bs2.i","line":109,"source":72,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp56;","target":73},{"file":"test\/bs2.i","line":512,"source":413,"type":"BlankEdge","stmt":"Goto: while_15_break","target":418},{"file":"test\/bs2.i","line":642,"source":528,"type":"AssumeEdge","stmt":"[node == 0]","target":530},{"file":"test\/bs2.i","line":642,"source":528,"type":"AssumeEdge","stmt":"[!(node == 0)]","target":531},{"file":"test\/bs2.i","line":769,"source":642,"type":"DeclarationEdge","stmt":"struct list_head *pos0;","target":643},{"file":"test\/bs2.i","line":346,"source":281,"type":"StatementEdge","stmt":"__cil_tmp51 = (unsigned int)__cil_tmp50;","target":282},{"file":"test\/bs2.i","line":371,"source":302,"type":"StatementEdge","stmt":"__cil_tmp61 = __cil_tmp60 != __cil_tmp56;","target":303},{"file":"test\/bs2.i","line":615,"source":505,"type":"CallToReturnEdge","stmt":"__list_del(__cil_tmp5, __cil_tmp6);","target":506},{"file":"test\/bs2.i","line":236,"source":186,"type":"BlankEdge","stmt":"while","target":187},{"file":"test\/bs2.i","line":743,"source":617,"type":"ReturnStatementEdge","stmt":"return;","target":575},{"file":"test\/bs2.i","line":348,"source":283,"type":"AssumeEdge","stmt":"[__cil_tmp52 == 0]","target":285},{"file":"test\/bs2.i","line":445,"source":358,"type":"BlankEdge","stmt":"Goto: while_12_break","target":363},{"file":"test\/bs2.i","line":348,"source":283,"type":"AssumeEdge","stmt":"[!(__cil_tmp52 == 0)]","target":286},{"file":"test\/bs2.i","line":162,"source":125,"type":"DeclarationEdge","stmt":"const struct list_head *__cil_tmp109;","target":126},{"file":"test\/bs2.i","line":166,"source":129,"type":"DeclarationEdge","stmt":"struct node *__cil_tmp113;","target":130},{"file":"test\/bs2.i","line":277,"source":222,"type":"AssumeEdge","stmt":"[!(__cil_tmp25 == 0)]","target":225},{"file":"test\/bs2.i","line":277,"source":222,"type":"AssumeEdge","stmt":"[__cil_tmp25 == 0]","target":224},{"file":"test\/bs2.i","line":117,"source":80,"type":"DeclarationEdge","stmt":"const struct list_head *__cil_tmp64;","target":81},{"file":"test\/bs2.i","line":550,"source":451,"type":"StatementEdge","stmt":"__cil_tmp121 = (unsigned int)__cil_tmp120;","target":452},{"file":"test\/bs2.i","line":249,"source":198,"type":"BlankEdge","stmt":"","target":199},{"file":"test\/bs2.i","line":504,"source":411,"type":"StatementEdge","stmt":"__cil_tmp104 = __cil_tmp103 == __cil_tmp102;","target":412},{"file":"test\/bs2.i","line":104,"source":67,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp51;","target":68},{"file":"test\/bs2.i","line":666,"source":549,"type":"StatementEdge","stmt":"__cil_tmp15 = __cil_tmp14 + 12;","target":550},{"file":"test\/bs2.i","line":481,"source":392,"type":"StatementEdge","stmt":"__cil_tmp96 = __cil_tmp95 == __cil_tmp94;","target":393},{"file":"test\/bs2.i","line":685,"source":566,"type":"StatementEdge","stmt":"tmp___0 = __VERIFIER_nondet_int();","target":567},{"file":"test\/bs2.i","line":256,"source":205,"type":"AssumeEdge","stmt":"[__cil_tmp19 == 0]","target":207},{"file":"test\/bs2.i","line":501,"source":408,"type":"StatementEdge","stmt":"__cil_tmp101 = *((struct list_head **)__cil_tmp100);","target":409},{"file":"test\/bs2.i","line":256,"source":205,"type":"AssumeEdge","stmt":"[!(__cil_tmp19 == 0)]","target":208},{"file":"test\/bs2.i","line":396,"source":323,"type":"StatementEdge","stmt":"__cil_tmp71 = __cil_tmp70 != __cil_tmp65;","target":324},{"file":"test\/bs2.i","line":60,"source":23,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp7;","target":24},{"file":"test\/bs2.i","line":453,"source":368,"type":"StatementEdge","stmt":"__cil_tmp83 = (const int *)node;","target":369},{"file":"test\/bs2.i","line":677,"source":559,"type":"DeclarationEdge","stmt":"int tmp___0;","target":560},{"file":"test\/bs2.i","line":141,"source":104,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp88;","target":105},{"file":"test\/bs2.i","line":681,"source":562,"type":"BlankEdge","stmt":"Label: while_19_continue","target":564},{"file":"<none>","line":0,"source":245,"type":"BlankEdge","stmt":"","target":243},{"file":"test\/bs2.i","line":545,"source":446,"type":"StatementEdge","stmt":"__cil_tmp116 = (struct list_head *)__cil_tmp115;","target":447},{"file":"test\/bs2.i","line":80,"source":43,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp27;","target":44},{"file":"test\/bs2.i","line":169,"source":132,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp116;","target":133},{"file":"test\/bs2.i","line":711,"source":590,"type":"DeclarationEdge","stmt":"void *__cil_tmp14;","target":591},{"file":"test\/bs2.i","line":478,"source":389,"type":"StatementEdge","stmt":"__cil_tmp93 = *((struct list_head **)__cil_tmp92);","target":390},{"file":"test\/bs2.i","line":54,"source":722,"type":"DeclarationEdge","stmt":"void inspect(const struct list_head *head);","target":723},{"file":"test\/bs2.i","line":656,"source":538,"type":"BlankEdge","stmt":"","target":539},{"file":"test\/bs2.i","line":404,"source":325,"type":"BlankEdge","stmt":"Goto: while_10_break","target":330},{"file":"test\/bs2.i","line":710,"source":589,"type":"DeclarationEdge","stmt":"struct node *__cil_tmp13;","target":590},{"file":"test\/bs2.i","line":730,"source":606,"type":"StatementEdge","stmt":"__cil_tmp7 = (unsigned int)__cil_tmp6;","target":607},{"file":"test\/bs2.i","line":456,"source":371,"type":"StatementEdge","stmt":"__cil_tmp86 = (unsigned int)node;","target":372},{"file":"test\/bs2.i","line":815,"source":732,"type":"DeclarationEdge","stmt":"void gl_sort();","target":733},{"file":"test\/bs2.i","line":124,"source":87,"type":"DeclarationEdge","stmt":"int __cil_tmp71;","target":88},{"file":"test\/bs2.i","line":708,"source":587,"type":"DeclarationEdge","stmt":"char *__cil_tmp11;","target":588},{"file":"test\/bs2.i","line":316,"source":255,"type":"StatementEdge","stmt":"__cil_tmp36 = (const struct list_head *)__cil_tmp35;","target":256},{"file":"test\/bs2.i","line":806,"source":670,"type":"StatementEdge","stmt":"any_change = 1;","target":675},{"file":"test\/bs2.i","line":268,"source":212,"type":"BlankEdge","stmt":"while","target":213},{"file":"test\/bs2.i","line":658,"source":541,"type":"StatementEdge","stmt":"__cil_tmp8 = (unsigned int)node;","target":542},{"file":"test\/bs2.i","line":96,"source":59,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp43;","target":60},{"file":"test\/bs2.i","line":42,"source":719,"type":"DeclarationEdge","stmt":"int __VERIFIER_nondet_int();","target":720},{"file":"test\/bs2.i","line":246,"source":196,"type":"BlankEdge","stmt":"Label: while_3_break","target":197},{"file":"test\/bs2.i","line":89,"source":52,"type":"DeclarationEdge","stmt":"const struct list_head *__cil_tmp36;","target":53},{"file":"test\/bs2.i","line":76,"source":39,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp23;","target":40},{"file":"test\/bs2.i","line":840,"source":701,"type":"StatementEdge","stmt":"__cil_tmp1 = (const struct list_head *)(&gl_list);","target":702},{"file":"test\/bs2.i","line":437,"source":356,"type":"StatementEdge","stmt":"__cil_tmp82 = __cil_tmp81 != __cil_tmp80;","target":357},{"file":"test\/bs2.i","line":587,"source":482,"type":"StatementEdge","stmt":"__cil_tmp3 = (unsigned int)next;","target":483},{"file":"test\/bs2.i","line":816,"source":682,"type":"DeclarationEdge","stmt":"_Bool tmp;","target":683},{"file":"<none>","line":0,"source":396,"type":"BlankEdge","stmt":"","target":394},{"file":"<none>","line":0,"source":193,"type":"BlankEdge","stmt":"","target":191},{"file":"<none>","line":0,"source":415,"type":"BlankEdge","stmt":"","target":413},{"file":"test\/bs2.i","line":747,"source":621,"type":"DeclarationEdge","stmt":"struct node *entry;","target":622},{"file":"test\/bs2.i","line":133,"source":96,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp80;","target":97},{"file":"test\/bs2.i","line":341,"source":276,"type":"StatementEdge","stmt":"__cil_tmp46 = (unsigned int)__cil_tmp45;","target":277},{"file":"test\/bs2.i","line":157,"source":120,"type":"DeclarationEdge","stmt":"int __cil_tmp104;","target":121},{"file":"test\/bs2.i","line":332,"source":268,"type":"BlankEdge","stmt":"Label: while_7_break","target":269},{"file":"test\/bs2.i","line":360,"source":291,"type":"BlankEdge","stmt":"","target":292},{"file":"test\/bs2.i","line":780,"source":652,"type":"StatementEdge","stmt":"__cil_tmp8 = &gl_list;","target":653},{"file":"test\/bs2.i","line":520,"source":423,"type":"BlankEdge","stmt":"Label: while_16_continue","target":425},{"file":"test\/bs2.i","line":653,"source":536,"type":"CallToReturnEdge","stmt":"list_add(__cil_tmp7, &gl_list);","target":537},{"file":"<none>","line":0,"source":479,"type":"BlankEdge","stmt":"Function start dummy edge","target":480},{"file":"test\/bs2.i","line":800,"source":669,"type":"AssumeEdge","stmt":"[!(val0 <= val1)]","target":672},{"file":"test\/bs2.i","line":154,"source":117,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp101;","target":118},{"file":"test\/bs2.i","line":800,"source":669,"type":"AssumeEdge","stmt":"[val0 <= val1]","target":671},{"file":"test\/bs2.i","line":75,"source":38,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp22;","target":39},{"file":"test\/bs2.i","line":179,"source":140,"type":"BlankEdge","stmt":"","target":141},{"file":"test\/bs2.i","line":836,"source":699,"type":"DeclarationEdge","stmt":"const struct list_head *__cil_tmp2;","target":700},{"file":"test\/bs2.i","line":797,"source":667,"type":"CallToReturnEdge","stmt":"tmp___0 = val_from_node(pos1);","target":668},{"file":"test\/bs2.i","line":538,"source":438,"type":"BlankEdge","stmt":"while","target":439},{"file":"<none>","line":0,"source":672,"type":"BlankEdge","stmt":"","target":670},{"file":"test\/bs2.i","line":88,"source":51,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp35;","target":52},{"file":"test\/bs2.i","line":110,"source":73,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp57;","target":74},{"file":"test\/bs2.i","line":336,"source":271,"type":"BlankEdge","stmt":"Label: while_8_continue","target":273},{"file":"test\/bs2.i","line":845,"source":706,"type":"CallToReturnEdge","stmt":"gl_destroy();","target":707},{"file":"test\/bs2.i","line":196,"source":155,"type":"StatementEdge","stmt":"__cil_tmp4 = *((struct list_head * const *)head);","target":156},{"file":"test\/bs2.i","line":473,"source":384,"type":"StatementEdge","stmt":"__cil_tmp88 = (unsigned int)node;","target":385},{"file":"test\/bs2.i","line":580,"source":476,"type":"ReturnStatementEdge","stmt":"return;","target":462},{"file":"test\/bs2.i","line":384,"source":310,"type":"BlankEdge","stmt":"while","target":311},{"file":"test\/bs2.i","line":822,"source":687,"type":"CallToReturnEdge","stmt":"tmp = gl_sort_pass();","target":688},{"file":"test\/bs2.i","line":498,"source":405,"type":"StatementEdge","stmt":"__cil_tmp98 = (unsigned int)node;","target":406},{"file":"test\/bs2.i","line":761,"source":634,"type":"StatementEdge","stmt":"__cil_tmp8 = (char *)head;","target":635},{"file":"test\/bs2.i","line":732,"source":608,"type":"StatementEdge","stmt":"__cil_tmp9 = (struct list_head *)__cil_tmp8;","target":609},{"file":"<none>","line":0,"source":569,"type":"BlankEdge","stmt":"","target":568},{"file":"test\/bs2.i","line":475,"source":386,"type":"StatementEdge","stmt":"__cil_tmp90 = *((struct list_head * const *)__cil_tmp89);","target":387},{"file":"test\/bs2.i","line":159,"source":122,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp106;","target":123},{"file":"test\/bs2.i","line":432,"source":351,"type":"StatementEdge","stmt":"__cil_tmp77 = __cil_tmp76 + 4;","target":352},{"file":"test\/bs2.i","line":783,"source":654,"type":"BlankEdge","stmt":"while","target":655},{"file":"test\/bs2.i","line":735,"source":611,"type":"StatementEdge","stmt":"__cil_tmp12 = __cil_tmp11 - __cil_tmp10;","target":612},{"file":"test\/bs2.i","line":697,"source":729,"type":"DeclarationEdge","stmt":"void gl_destroy();","target":730},{"file":"test\/bs2.i","line":174,"source":137,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp121;","target":138},{"file":"test\/bs2.i","line":451,"source":366,"type":"BlankEdge","stmt":"Label: while_13_continue","target":368},{"file":"<none>","line":0,"source":286,"type":"BlankEdge","stmt":"","target":284},{"file":"test\/bs2.i","line":714,"source":592,"type":"BlankEdge","stmt":"","target":593},{"file":"test\/bs2.i","line":776,"source":649,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp9;","target":650},{"file":"test\/bs2.i","line":139,"source":102,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp86;","target":103},{"file":"test\/bs2.i","line":374,"source":305,"type":"CallToReturnEdge","stmt":"fail();","target":307},{"file":"test\/bs2.i","line":126,"source":89,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp73;","target":90},{"file":"test\/bs2.i","line":275,"source":220,"type":"StatementEdge","stmt":"__cil_tmp24 = (unsigned int)__cil_tmp23;","target":221},{"file":"test\/bs2.i","line":719,"source":597,"type":"StatementEdge","stmt":"__cil_tmp3 = (unsigned int)next;","target":598},{"file":"test\/bs2.i","line":752,"source":626,"type":"DeclarationEdge","stmt":"unsigned long __cil_tmp7;","target":627},{"file":"test\/bs2.i","line":244,"source":191,"type":"BlankEdge","stmt":"Goto: while_3_break","target":196},{"file":"test\/bs2.i","line":103,"source":66,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp50;","target":67},{"file":"test\/bs2.i","line":410,"source":333,"type":"BlankEdge","stmt":"Label: while_11_continue","target":335},{"file":"test\/bs2.i","line":258,"source":207,"type":"CallToReturnEdge","stmt":"fail();","target":209},{"file":"<none>","line":0,"source":531,"type":"BlankEdge","stmt":"","target":529},{"file":"test\/bs2.i","line":125,"source":88,"type":"DeclarationEdge","stmt":"const struct node *__cil_tmp72;","target":89},{"file":"test\/bs2.i","line":272,"source":217,"type":"StatementEdge","stmt":"__cil_tmp21 = (unsigned int)head;","target":218},{"file":"test\/bs2.i","line":294,"source":235,"type":"StatementEdge","stmt":"__cil_tmp32 = __cil_tmp31 - __cil_tmp30;","target":236},{"file":"<none>","line":0,"source":601,"type":"BlankEdge","stmt":"","target":600},{"file":"test\/bs2.i","line":700,"source":579,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp3;","target":580},{"file":"test\/bs2.i","line":578,"source":474,"type":"StatementEdge","stmt":"*((struct list_head **)__cil_tmp7) = prev;","target":475},{"file":"test\/bs2.i","line":613,"source":503,"type":"StatementEdge","stmt":"__cil_tmp5 = *((struct list_head **)__cil_tmp4);","target":504},{"file":"test\/bs2.i","line":59,"source":22,"type":"DeclarationEdge","stmt":"int __cil_tmp6;","target":23},{"file":"test\/bs2.i","line":81,"source":44,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp28;","target":45},{"file":"test\/bs2.i","line":589,"source":484,"type":"StatementEdge","stmt":"*((struct list_head **)__cil_tmp4) = prev;","target":485},{"file":"test\/bs2.i","line":741,"source":616,"type":"BlankEdge","stmt":"Label: while_20_break","target":617},{"file":"test\/bs2.i","line":429,"source":348,"type":"BlankEdge","stmt":"Label: while_12_continue","target":350},{"file":"<none>","line":0,"source":376,"type":"BlankEdge","stmt":"","target":374},{"file":"test\/bs2.i","line":149,"source":112,"type":"DeclarationEdge","stmt":"int __cil_tmp96;","target":113},{"file":"test\/bs2.i","line":388,"source":315,"type":"StatementEdge","stmt":"__cil_tmp63 = __cil_tmp62 + 4;","target":316},{"file":"test\/bs2.i","line":629,"source":518,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp9;","target":519},{"file":"test\/bs2.i","line":771,"source":644,"type":"DeclarationEdge","stmt":"int val0;","target":645},{"file":"<none>","line":0,"source":456,"type":"BlankEdge","stmt":"","target":454},{"file":"test\/bs2.i","line":365,"source":296,"type":"StatementEdge","stmt":"__cil_tmp55 = (const struct list_head *)__cil_tmp54;","target":297},{"file":"test\/bs2.i","line":132,"source":95,"type":"DeclarationEdge","stmt":"const struct node *__cil_tmp79;","target":96},{"file":"test\/bs2.i","line":164,"source":127,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp111;","target":128},{"file":"test\/bs2.i","line":314,"source":253,"type":"StatementEdge","stmt":"__cil_tmp34 = (unsigned int)node;","target":254},{"file":"test\/bs2.i","line":703,"source":582,"type":"DeclarationEdge","stmt":"struct node *__cil_tmp6;","target":583},{"file":"test\/bs2.i","line":632,"source":521,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp12;","target":522},{"file":"test\/bs2.i","line":237,"source":188,"type":"BlankEdge","stmt":"Label: while_3_continue","target":190},{"file":"<none>","line":0,"source":690,"type":"BlankEdge","stmt":"","target":689},{"file":"test\/bs2.i","line":583,"source":724,"type":"DeclarationEdge","stmt":"void __list_del(struct list_head *prev, struct list_head *next);","target":725},{"file":"test\/bs2.i","line":218,"source":173,"type":"StatementEdge","stmt":"__cil_tmp11 = (unsigned int)__cil_tmp10;","target":174},{"file":"test\/bs2.i","line":551,"source":452,"type":"StatementEdge","stmt":"__cil_tmp122 = __cil_tmp121 == __cil_tmp112;","target":453},{"file":"test\/bs2.i","line":572,"source":468,"type":"StatementEdge","stmt":"__cil_tmp4 = (unsigned int)next;","target":469},{"file":"test\/bs2.i","line":684,"source":565,"type":"CallToReturnEdge","stmt":"gl_insert(tmp);","target":566},{"file":"test\/bs2.i","line":144,"source":107,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp91;","target":108},{"file":"test\/bs2.i","line":255,"source":204,"type":"StatementEdge","stmt":"__cil_tmp19 = __cil_tmp18 != __cil_tmp16;","target":205},{"file":"test\/bs2.i","line":344,"source":279,"type":"StatementEdge","stmt":"__cil_tmp49 = __cil_tmp48 + __cil_tmp47;","target":280},{"file":"test\/bs2.i","line":795,"source":662,"type":"CallToReturnEdge","stmt":"tmp = val_from_node(pos0);","target":666},{"file":"test\/bs2.i","line":370,"source":301,"type":"StatementEdge","stmt":"__cil_tmp60 = (unsigned int)__cil_tmp59;","target":302},{"file":"test\/bs2.i","line":390,"source":317,"type":"StatementEdge","stmt":"__cil_tmp65 = (unsigned int)__cil_tmp64;","target":318},{"file":"<none>","line":0,"source":489,"type":"BlankEdge","stmt":"Function start dummy edge","target":490},{"file":"test\/bs2.i","line":595,"source":490,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp3;","target":491},{"file":"test\/bs2.i","line":99,"source":62,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp46;","target":63},{"file":"test\/bs2.i","line":183,"source":145,"type":"CallToReturnEdge","stmt":"fail();","target":147},{"file":"test\/bs2.i","line":616,"source":506,"type":"CallToReturnEdge","stmt":"list_add(list, head);","target":507},{"file":"test\/bs2.i","line":74,"source":37,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp21;","target":38},{"file":"test\/bs2.i","line":300,"source":242,"type":"AssumeEdge","stmt":"[node == 0]","target":244},{"file":"test\/bs2.i","line":300,"source":242,"type":"AssumeEdge","stmt":"[!(node == 0)]","target":245},{"file":"test\/bs2.i","line":319,"source":258,"type":"StatementEdge","stmt":"__cil_tmp39 = __cil_tmp38 + 12;","target":259},{"file":"test\/bs2.i","line":839,"source":700,"type":"CallToReturnEdge","stmt":"gl_read();","target":701},{"file":"test\/bs2.i","line":131,"source":94,"type":"DeclarationEdge","stmt":"const struct list_head *__cil_tmp78;","target":95},{"file":"test\/bs2.i","line":436,"source":355,"type":"StatementEdge","stmt":"__cil_tmp81 = (unsigned int)node;","target":356},{"file":"test\/bs2.i","line":34,"source":716,"type":"DeclarationEdge","stmt":"struct node {   int value;   struct list_head linkage;   struct list_head nested; } ;","target":717},{"file":"test\/bs2.i","line":66,"source":29,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp13;","target":30},{"file":"test\/bs2.i","line":232,"source":183,"type":"StatementEdge","stmt":"__cil_tmp14 = __cil_tmp13 + 4;","target":184},{"file":"test\/bs2.i","line":502,"source":409,"type":"StatementEdge","stmt":"__cil_tmp102 = (unsigned int)__cil_tmp101;","target":410},{"file":"test\/bs2.i","line":165,"source":128,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp112;","target":129},{"file":"test\/bs2.i","line":345,"source":280,"type":"StatementEdge","stmt":"__cil_tmp50 = *((struct list_head * const *)__cil_tmp49);","target":281},{"file":"test\/bs2.i","line":707,"source":586,"type":"DeclarationEdge","stmt":"unsigned long __cil_tmp10;","target":587},{"file":"test\/bs2.i","line":819,"source":683,"type":"BlankEdge","stmt":"while","target":684},{"file":"test\/bs2.i","line":395,"source":322,"type":"StatementEdge","stmt":"__cil_tmp70 = (unsigned int)__cil_tmp69;","target":323},{"file":"test\/bs2.i","line":107,"source":70,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp54;","target":71},{"file":"test\/bs2.i","line":507,"source":414,"type":"CallToReturnEdge","stmt":"fail();","target":416},{"file":"test\/bs2.i","line":622,"source":511,"type":"DeclarationEdge","stmt":"struct node *node;","target":512},{"file":"test\/bs2.i","line":211,"source":166,"type":"BlankEdge","stmt":"","target":167},{"file":"test\/bs2.i","line":46,"source":13,"type":"StatementEdge","stmt":"__assert_fail(\\\"0\\\", \\\"test-0180.c\\\", 11, \\\"__PRETTY_FUNCTION__\\\");","target":14},{"file":"test\/bs2.i","line":720,"source":598,"type":"StatementEdge","stmt":"__cil_tmp4 = (unsigned int)(&gl_list);","target":599},{"file":"<none>","line":0,"source":225,"type":"BlankEdge","stmt":"","target":223},{"file":"test\/bs2.i","line":296,"source":237,"type":"StatementEdge","stmt":"node = (const struct node *)__cil_tmp33;","target":238},{"file":"test\/bs2.i","line":532,"source":431,"type":"StatementEdge","stmt":"__cil_tmp111 = *((struct list_head * const *)head);","target":435},{"file":"test\/bs2.i","line":189,"source":149,"type":"BlankEdge","stmt":"Label: while_0_break","target":150},{"file":"test\/bs2.i","line":330,"source":263,"type":"BlankEdge","stmt":"Goto: while_7_break","target":268},{"file":"<none>","line":0,"source":734,"type":"BlankEdge","stmt":"Function start dummy edge","target":698},{"file":"test\/bs2.i","line":634,"source":523,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp14;","target":524},{"file":"test\/bs2.i","line":440,"source":359,"type":"CallToReturnEdge","stmt":"fail();","target":361},{"file":"test\/bs2.i","line":82,"source":45,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp29;","target":46},{"file":"test\/bs2.i","line":289,"source":230,"type":"StatementEdge","stmt":"__cil_tmp27 = (unsigned int)__cil_tmp26;","target":231},{"file":"test\/bs2.i","line":763,"source":636,"type":"StatementEdge","stmt":"entry = (struct node *)__cil_tmp9;","target":637},{"file":"test\/bs2.i","line":457,"source":372,"type":"StatementEdge","stmt":"__cil_tmp87 = __cil_tmp86 == __cil_tmp85;","target":373},{"file":"test\/bs2.i","line":843,"source":704,"type":"StatementEdge","stmt":"__cil_tmp2 = (const struct list_head *)(&gl_list);","target":705},{"file":"test\/bs2.i","line":567,"source":464,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp4;","target":465},{"file":"test\/bs2.i","line":415,"source":338,"type":"StatementEdge","stmt":"__cil_tmp75 = __cil_tmp74 != __cil_tmp73;","target":339},{"file":"test\/bs2.i","line":91,"source":54,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp38;","target":55},{"file":"test\/bs2.i","line":216,"source":171,"type":"StatementEdge","stmt":"__cil_tmp9 = __cil_tmp8 + 4;","target":172},{"file":"<none>","line":0,"source":360,"type":"BlankEdge","stmt":"","target":358},{"file":"test\/bs2.i","line":698,"source":577,"type":"DeclarationEdge","stmt":"struct list_head *next;","target":578},{"file":"test\/bs2.i","line":236,"source":187,"type":"BlankEdge","stmt":"","target":188},{"file":"test\/bs2.i","line":772,"source":645,"type":"DeclarationEdge","stmt":"int tmp;","target":646},{"file":"<none>","line":0,"source":178,"type":"BlankEdge","stmt":"","target":176},{"file":"test\/bs2.i","line":470,"source":381,"type":"BlankEdge","stmt":"","target":382},{"file":"test\/bs2.i","line":577,"source":473,"type":"StatementEdge","stmt":"__cil_tmp7 = __cil_tmp6 + 4;","target":474},{"file":"test\/bs2.i","line":122,"source":85,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp69;","target":86},{"file":"test\/bs2.i","line":156,"source":119,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp103;","target":120},{"file":"test\/bs2.i","line":180,"source":141,"type":"BlankEdge","stmt":"Label: while_0_continue","target":143},{"file":"test\/bs2.i","line":514,"source":418,"type":"BlankEdge","stmt":"Label: while_15_break","target":419},{"file":"test\/bs2.i","line":661,"source":544,"type":"StatementEdge","stmt":"__cil_tmp11 = __cil_tmp10 + 12;","target":545},{"file":"test\/bs2.i","line":736,"source":612,"type":"StatementEdge","stmt":"__cil_tmp13 = (struct node *)__cil_tmp12;","target":613},{"file":"test\/bs2.i","line":58,"source":21,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp5;","target":22},{"file":"test\/bs2.i","line":67,"source":30,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp14;","target":31},{"file":"test\/bs2.i","line":482,"source":393,"type":"AssumeEdge","stmt":"[__cil_tmp96 == 0]","target":395},{"file":"test\/bs2.i","line":482,"source":393,"type":"AssumeEdge","stmt":"[!(__cil_tmp96 == 0)]","target":396},{"file":"test\/bs2.i","line":590,"source":485,"type":"StatementEdge","stmt":"*((struct list_head **)prev) = next;","target":486},{"file":"<none>","line":0,"source":532,"type":"BlankEdge","stmt":"","target":529},{"file":"test\/bs2.i","line":192,"source":150,"type":"BlankEdge","stmt":"while","target":151},{"file":"test\/bs2.i","line":538,"source":439,"type":"BlankEdge","stmt":"","target":440},{"file":"test\/bs2.i","line":670,"source":553,"type":"BlankEdge","stmt":"Label: while_18_break","target":554},{"file":"test\/bs2.i","line":276,"source":221,"type":"StatementEdge","stmt":"__cil_tmp25 = __cil_tmp24 != __cil_tmp20;","target":222},{"file":"test\/bs2.i","line":750,"source":624,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp5;","target":625},{"file":"test\/bs2.i","line":399,"source":326,"type":"CallToReturnEdge","stmt":"fail();","target":328},{"file":"test\/bs2.i","line":605,"source":497,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp3;","target":498},{"file":"test\/bs2.i","line":65,"source":28,"type":"DeclarationEdge","stmt":"int __cil_tmp12;","target":29},{"file":"test\/bs2.i","line":108,"source":71,"type":"DeclarationEdge","stmt":"const struct list_head *__cil_tmp55;","target":72},{"file":"test\/bs2.i","line":292,"source":233,"type":"StatementEdge","stmt":"__cil_tmp30 = (unsigned long)__cil_tmp29;","target":234},{"file":"test\/bs2.i","line":561,"source":459,"type":"BlankEdge","stmt":"Label: while_17_break","target":460},{"file":"test\/bs2.i","line":220,"source":175,"type":"AssumeEdge","stmt":"[__cil_tmp12 == 0]","target":177},{"file":"test\/bs2.i","line":406,"source":330,"type":"BlankEdge","stmt":"Label: while_10_break","target":331},{"file":"test\/bs2.i","line":220,"source":175,"type":"AssumeEdge","stmt":"[!(__cil_tmp12 == 0)]","target":178},{"file":"test\/bs2.i","line":760,"source":633,"type":"StatementEdge","stmt":"__cil_tmp7 = (unsigned long)__cil_tmp6;","target":634},{"file":"test\/bs2.i","line":428,"source":346,"type":"BlankEdge","stmt":"while","target":347},{"file":"test\/bs2.i","line":130,"source":93,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp77;","target":94},{"file":"test\/bs2.i","line":746,"source":730,"type":"DeclarationEdge","stmt":"int val_from_node(struct list_head *head);","target":731},{"file":"test\/bs2.i","line":542,"source":443,"type":"StatementEdge","stmt":"__cil_tmp113 = (struct node *)0;","target":444},{"file":"test\/bs2.i","line":137,"source":100,"type":"DeclarationEdge","stmt":"const struct node *__cil_tmp84;","target":101},{"file":"test\/bs2.i","line":759,"source":632,"type":"StatementEdge","stmt":"__cil_tmp6 = (struct list_head *)__cil_tmp5;","target":633},{"file":"test\/bs2.i","line":153,"source":116,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp100;","target":117},{"file":"test\/bs2.i","line":775,"source":648,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp8;","target":649},{"file":"test\/bs2.i","line":268,"source":213,"type":"BlankEdge","stmt":"","target":214},{"file":"test\/bs2.i","line":585,"source":481,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp4;","target":482},{"file":"test\/bs2.i","line":495,"source":402,"type":"BlankEdge","stmt":"Label: while_15_continue","target":404},{"file":"test\/bs2.i","line":198,"source":157,"type":"StatementEdge","stmt":"__cil_tmp6 = __cil_tmp5 != __cil_tmp3;","target":158},{"file":"test\/bs2.i","line":105,"source":68,"type":"DeclarationEdge","stmt":"int __cil_tmp52;","target":69},{"file":"test\/bs2.i","line":381,"source":309,"type":"BlankEdge","stmt":"Label: while_9_break","target":310},{"file":"test\/bs2.i","line":286,"source":228,"type":"BlankEdge","stmt":"Label: while_5_break","target":229},{"file":"test\/bs2.i","line":288,"source":229,"type":"StatementEdge","stmt":"__cil_tmp26 = (struct node *)0;","target":230},{"file":"test\/bs2.i","line":312,"source":251,"type":"BlankEdge","stmt":"Label: while_7_continue","target":253},{"file":"<none>","line":0,"source":557,"type":"BlankEdge","stmt":"Function start dummy edge","target":558},{"file":"test\/bs2.i","line":199,"source":158,"type":"AssumeEdge","stmt":"[__cil_tmp6 == 0]","target":160},{"file":"test\/bs2.i","line":73,"source":36,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp20;","target":37},{"file":"test\/bs2.i","line":199,"source":158,"type":"AssumeEdge","stmt":"[!(__cil_tmp6 == 0)]","target":161},{"file":"test\/bs2.i","line":754,"source":628,"type":"DeclarationEdge","stmt":"char *__cil_tmp9;","target":629},{"file":"test\/bs2.i","line":675,"source":728,"type":"DeclarationEdge","stmt":"void gl_read();","target":729},{"file":"test\/bs2.i","line":625,"source":514,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp5;","target":515},{"file":"test\/bs2.i","line":361,"source":292,"type":"BlankEdge","stmt":"Label: while_9_continue","target":294},{"file":"test\/bs2.i","line":618,"source":507,"type":"ReturnStatementEdge","stmt":"return;","target":495},{"file":"test\/bs2.i","line":716,"source":595,"type":"StatementEdge","stmt":"__cil_tmp2 = &gl_list;","target":596},{"file":"test\/bs2.i","line":447,"source":363,"type":"BlankEdge","stmt":"Label: while_12_break","target":364},{"file":"test\/bs2.i","line":47,"source":14,"type":"BlankEdge","stmt":"Goto: ERROR","target":11},{"file":"test\/bs2.i","line":796,"source":666,"type":"StatementEdge","stmt":"val0 = tmp;","target":667},{"file":"test\/bs2.i","line":83,"source":46,"type":"DeclarationEdge","stmt":"unsigned long __cil_tmp30;","target":47},{"file":"test\/bs2.i","line":409,"source":331,"type":"BlankEdge","stmt":"while","target":332},{"file":"test\/bs2.i","line":523,"source":426,"type":"StatementEdge","stmt":"__cil_tmp107 = (unsigned int)node;","target":427},{"file":"test\/bs2.i","line":170,"source":133,"type":"DeclarationEdge","stmt":"unsigned long __cil_tmp117;","target":134},{"file":"<none>","line":0,"source":1,"type":"BlankEdge","stmt":"Function start dummy edge","target":2},{"file":"test\/bs2.i","line":467,"source":379,"type":"BlankEdge","stmt":"Label: while_13_break","target":380},{"file":"test\/bs2.i","line":340,"source":275,"type":"StatementEdge","stmt":"__cil_tmp45 = (const struct list_head *)__cil_tmp44;","target":276},{"file":"test\/bs2.i","line":494,"source":401,"type":"BlankEdge","stmt":"","target":402},{"file":"test\/bs2.i","line":807,"source":675,"type":"CallToReturnEdge","stmt":"list_move(pos0, pos1);","target":676},{"file":"test\/bs2.i","line":477,"source":388,"type":"StatementEdge","stmt":"__cil_tmp92 = __cil_tmp91 + 4;","target":389},{"file":"test\/bs2.i","line":533,"source":435,"type":"StatementEdge","stmt":"head = (const struct list_head *)__cil_tmp111;","target":436},{"file":"test\/bs2.i","line":680,"source":561,"type":"BlankEdge","stmt":"","target":562},{"file":"test\/bs2.i","line":106,"source":69,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp53;","target":70},{"file":"test\/bs2.i","line":665,"source":548,"type":"StatementEdge","stmt":"__cil_tmp14 = (unsigned int)node;","target":549},{"file":"test\/bs2.i","line":842,"source":703,"type":"CallToReturnEdge","stmt":"gl_sort();","target":704},{"file":"test\/bs2.i","line":355,"source":284,"type":"BlankEdge","stmt":"Goto: while_8_break","target":289},{"file":"test\/bs2.i","line":503,"source":410,"type":"StatementEdge","stmt":"__cil_tmp103 = (unsigned int)head;","target":411},{"file":"test\/bs2.i","line":68,"source":31,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp15;","target":32},{"file":"test\/bs2.i","line":458,"source":373,"type":"AssumeEdge","stmt":"[__cil_tmp87 == 0]","target":375},{"file":"test\/bs2.i","line":57,"source":20,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp4;","target":21},{"file":"test\/bs2.i","line":152,"source":115,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp99;","target":116},{"file":"test\/bs2.i","line":458,"source":373,"type":"AssumeEdge","stmt":"[!(__cil_tmp87 == 0)]","target":376},{"file":"test\/bs2.i","line":543,"source":444,"type":"StatementEdge","stmt":"__cil_tmp114 = (unsigned int)__cil_tmp113;","target":445},{"file":"test\/bs2.i","line":689,"source":570,"type":"BlankEdge","stmt":"Goto: while_19_break","target":572},{"file":"test\/bs2.i","line":626,"source":515,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp6;","target":516},{"file":"test\/bs2.i","line":768,"source":641,"type":"DeclarationEdge","stmt":"_Bool any_change;","target":642},{"file":"test\/bs2.i","line":9,"source":712,"type":"DeclarationEdge","stmt":"void __assert(const char *__assertion, const char *__file, int __line);","target":713},{"file":"test\/bs2.i","line":298,"source":238,"type":"BlankEdge","stmt":"while","target":239},{"file":"test\/bs2.i","line":450,"source":364,"type":"BlankEdge","stmt":"while","target":365},{"file":"<none>","line":0,"source":697,"type":"BlankEdge","stmt":"INIT GLOBAL VARS","target":709},{"file":"test\/bs2.i","line":657,"source":539,"type":"BlankEdge","stmt":"Label: while_18_continue","target":541},{"file":"test\/bs2.i","line":706,"source":585,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp9;","target":586},{"file":"test\/bs2.i","line":123,"source":86,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp70;","target":87},{"file":"test\/bs2.i","line":161,"source":124,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp108;","target":125},{"file":"test\/bs2.i","line":311,"source":250,"type":"BlankEdge","stmt":"","target":251},{"file":"test\/bs2.i","line":635,"source":524,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp15;","target":525},{"file":"test\/bs2.i","line":394,"source":321,"type":"StatementEdge","stmt":"__cil_tmp69 = *((struct list_head * const *)__cil_tmp68);","target":322},{"file":"test\/bs2.i","line":777,"source":650,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp10;","target":651},{"file":"test\/bs2.i","line":90,"source":53,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp37;","target":54},{"file":"test\/bs2.i","line":52,"source":721,"type":"DeclarationEdge","stmt":"struct list_head gl_list = { &gl_list, &gl_list };","target":722},{"file":"test\/bs2.i","line":215,"source":170,"type":"StatementEdge","stmt":"__cil_tmp8 = (unsigned int)head;","target":171},{"file":"test\/bs2.i","line":785,"source":658,"type":"StatementEdge","stmt":"pos1 = *((struct list_head **)pos0);","target":659},{"file":"test\/bs2.i","line":56,"source":19,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp3;","target":20},{"file":"test\/bs2.i","line":598,"source":491,"type":"StatementEdge","stmt":"__cil_tmp3 = *((struct list_head **)head);","target":492},{"file":"test\/bs2.i","line":320,"source":259,"type":"StatementEdge","stmt":"__cil_tmp40 = *((struct list_head * const *)__cil_tmp39);","target":260},{"file":"test\/bs2.i","line":323,"source":262,"type":"AssumeEdge","stmt":"[__cil_tmp42 == 0]","target":264},{"file":"test\/bs2.i","line":749,"source":623,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp4;","target":624},{"file":"test\/bs2.i","line":323,"source":262,"type":"AssumeEdge","stmt":"[!(__cil_tmp42 == 0)]","target":265},{"file":"test\/bs2.i","line":43,"source":720,"type":"DeclarationEdge","stmt":"void fail();","target":721},{"file":"<none>","line":0,"source":432,"type":"BlankEdge","stmt":"","target":431},{"file":"test\/bs2.i","line":423,"source":340,"type":"BlankEdge","stmt":"Goto: while_11_break","target":345},{"file":"test\/bs2.i","line":460,"source":375,"type":"CallToReturnEdge","stmt":"fail();","target":377},{"file":"test\/bs2.i","line":607,"source":499,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp5;","target":500},{"file":"test\/bs2.i","line":728,"source":604,"type":"StatementEdge","stmt":"*((struct list_head **)__cil_tmp5) = *((struct list_head **)next);","target":605},{"file":"test\/bs2.i","line":148,"source":111,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp95;","target":112},{"file":"test\/bs2.i","line":143,"source":106,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp90;","target":107},{"file":"test\/bs2.i","line":64,"source":27,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp11;","target":28},{"file":"test\/bs2.i","line":254,"source":203,"type":"StatementEdge","stmt":"__cil_tmp18 = (unsigned int)__cil_tmp17;","target":204},{"file":"test\/bs2.i","line":789,"source":661,"type":"AssumeEdge","stmt":"[__cil_tmp10 != __cil_tmp9]","target":663},{"file":"test\/bs2.i","line":789,"source":661,"type":"AssumeEdge","stmt":"[!(__cil_tmp10 != __cil_tmp9)]","target":664},{"file":"<none>","line":0,"source":146,"type":"BlankEdge","stmt":"","target":144},{"file":"test\/bs2.i","line":233,"source":184,"type":"StatementEdge","stmt":"__cil_tmp15 = *((struct list_head * const *)__cil_tmp14);","target":185},{"file":"test\/bs2.i","line":662,"source":545,"type":"StatementEdge","stmt":"*((struct list_head **)__cil_tmp9) = (struct list_head *)__cil_tmp11;","target":546},{"file":"test\/bs2.i","line":389,"source":316,"type":"StatementEdge","stmt":"__cil_tmp64 = (const struct list_head *)__cil_tmp63;","target":317},{"file":"<none>","line":0,"source":510,"type":"BlankEdge","stmt":"Function start dummy edge","target":511},{"file":"test\/bs2.i","line":77,"source":40,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp24;","target":41},{"file":"test\/bs2.i","line":366,"source":297,"type":"StatementEdge","stmt":"__cil_tmp56 = (unsigned int)__cil_tmp55;","target":298},{"file":"<none>","line":0,"source":663,"type":"BlankEdge","stmt":"","target":662},{"file":"test\/bs2.i","line":84,"source":47,"type":"DeclarationEdge","stmt":"char *__cil_tmp31;","target":48},{"file":"test\/bs2.i","line":802,"source":673,"type":"BlankEdge","stmt":"Goto: while_21_continue","target":658},{"file":"test\/bs2.i","line":318,"source":257,"type":"StatementEdge","stmt":"__cil_tmp38 = (unsigned int)node;","target":258},{"file":"test\/bs2.i","line":563,"source":460,"type":"ReturnStatementEdge","stmt":"return;","target":16},{"file":"test\/bs2.i","line":12,"source":2,"type":"StatementEdge","stmt":"4UL;","target":3},{"file":"test\/bs2.i","line":192,"source":151,"type":"BlankEdge","stmt":"","target":152},{"file":"test\/bs2.i","line":470,"source":380,"type":"BlankEdge","stmt":"while","target":381},{"file":"test\/bs2.i","line":704,"source":583,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp7;","target":584},{"file":"test\/bs2.i","line":435,"source":354,"type":"StatementEdge","stmt":"__cil_tmp80 = (unsigned int)__cil_tmp79;","target":355},{"file":"test\/bs2.i","line":751,"source":625,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp6;","target":626},{"file":"test\/bs2.i","line":660,"source":543,"type":"StatementEdge","stmt":"__cil_tmp10 = (unsigned int)node;","target":544},{"file":"test\/bs2.i","line":387,"source":314,"type":"StatementEdge","stmt":"__cil_tmp62 = (unsigned int)node;","target":315},{"file":"test\/bs2.i","line":72,"source":35,"type":"DeclarationEdge","stmt":"int __cil_tmp19;","target":36},{"file":"<none>","line":0,"source":640,"type":"BlankEdge","stmt":"Function start dummy edge","target":641},{"file":"test\/bs2.i","line":39,"source":717,"type":"DeclarationEdge","stmt":"void *malloc(size_t __size);","target":718},{"file":"test\/bs2.i","line":364,"source":295,"type":"StatementEdge","stmt":"__cil_tmp54 = __cil_tmp53 + 4;","target":296},{"file":"test\/bs2.i","line":526,"source":429,"type":"StatementEdge","stmt":"__cil_tmp110 = (unsigned int)__cil_tmp109;","target":430},{"file":"test\/bs2.i","line":831,"source":694,"type":"ReturnStatementEdge","stmt":"return;","target":680},{"file":"test\/bs2.i","line":97,"source":60,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp44;","target":61},{"file":"test\/bs2.i","line":835,"source":698,"type":"DeclarationEdge","stmt":"const struct list_head *__cil_tmp1;","target":699},{"file":"test\/bs2.i","line":321,"source":260,"type":"StatementEdge","stmt":"__cil_tmp41 = (unsigned int)__cil_tmp40;","target":261},{"file":"test\/bs2.i","line":145,"source":108,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp92;","target":109},{"file":"test\/bs2.i","line":414,"source":337,"type":"StatementEdge","stmt":"__cil_tmp74 = (unsigned int)node;","target":338},{"file":"test\/bs2.i","line":129,"source":92,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp76;","target":93},{"file":"test\/bs2.i","line":12,"source":713,"type":"DeclarationEdge","stmt":"void reach_error();","target":714},{"file":"test\/bs2.i","line":295,"source":236,"type":"StatementEdge","stmt":"__cil_tmp33 = (struct node *)__cil_tmp32;","target":237},{"file":"test\/bs2.i","line":723,"source":602,"type":"BlankEdge","stmt":"Goto: while_20_break","target":616},{"file":"test\/bs2.i","line":46,"source":12,"type":"StatementEdge","stmt":"abort();","target":13},{"file":"test\/bs2.i","line":527,"source":430,"type":"AssumeEdge","stmt":"[!(__cil_tmp110 != __cil_tmp106)]","target":433},{"file":"test\/bs2.i","line":217,"source":172,"type":"StatementEdge","stmt":"__cil_tmp10 = *((struct list_head * const *)__cil_tmp9);","target":173},{"file":"test\/bs2.i","line":699,"source":578,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp2;","target":579},{"file":"test\/bs2.i","line":93,"source":56,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp40;","target":57},{"file":"test\/bs2.i","line":527,"source":430,"type":"AssumeEdge","stmt":"[__cil_tmp110 != __cil_tmp106]","target":432},{"file":"test\/bs2.i","line":757,"source":630,"type":"StatementEdge","stmt":"__cil_tmp4 = (unsigned int)__cil_tmp3;","target":631},{"file":"test\/bs2.i","line":379,"source":304,"type":"BlankEdge","stmt":"Goto: while_9_break","target":309},{"file":"test\/bs2.i","line":350,"source":285,"type":"CallToReturnEdge","stmt":"fail();","target":287},{"file":"test\/bs2.i","line":222,"source":177,"type":"CallToReturnEdge","stmt":"fail();","target":179},{"file":"test\/bs2.i","line":499,"source":406,"type":"StatementEdge","stmt":"__cil_tmp99 = __cil_tmp98 + __cil_tmp97;","target":407},{"file":"test\/bs2.i","line":113,"source":76,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp60;","target":77},{"file":"test\/bs2.i","line":116,"source":79,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp63;","target":80},{"file":"test\/bs2.i","line":727,"source":600,"type":"StatementEdge","stmt":"__cil_tmp5 = &gl_list;","target":604},{"file":"test\/bs2.i","line":150,"source":113,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp97;","target":114},{"file":"test\/bs2.i","line":476,"source":387,"type":"StatementEdge","stmt":"__cil_tmp91 = (unsigned int)__cil_tmp90;","target":388},{"file":"<none>","line":0,"source":568,"type":"BlankEdge","stmt":"","target":561},{"file":"test\/bs2.i","line":554,"source":455,"type":"CallToReturnEdge","stmt":"fail();","target":457},{"file":"test\/bs2.i","line":702,"source":581,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp5;","target":582},{"file":"test\/bs2.i","line":160,"source":123,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp107;","target":124},{"file":"test\/bs2.i","line":428,"source":347,"type":"BlankEdge","stmt":"","target":348},{"file":"test\/bs2.i","line":574,"source":470,"type":"StatementEdge","stmt":"*((struct list_head **)__cil_tmp5) = new;","target":471},{"file":"test\/bs2.i","line":664,"source":547,"type":"StatementEdge","stmt":"__cil_tmp13 = __cil_tmp12 + 12;","target":548},{"file":"test\/bs2.i","line":187,"source":144,"type":"BlankEdge","stmt":"Goto: while_0_break","target":149},{"file":"test\/bs2.i","line":100,"source":63,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp47;","target":64},{"file":"test\/bs2.i","line":69,"source":32,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp16;","target":33},{"file":"test\/bs2.i","line":479,"source":390,"type":"StatementEdge","stmt":"__cil_tmp94 = (unsigned int)__cil_tmp93;","target":391},{"file":"test\/bs2.i","line":570,"source":467,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp7;","target":468},{"file":"test\/bs2.i","line":630,"source":519,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp10;","target":520},{"file":"test\/bs2.i","line":325,"source":264,"type":"CallToReturnEdge","stmt":"fail();","target":266},{"file":"test\/bs2.i","line":197,"source":156,"type":"StatementEdge","stmt":"__cil_tmp5 = (unsigned int)__cil_tmp4;","target":157},{"file":"test\/bs2.i","line":279,"source":224,"type":"CallToReturnEdge","stmt":"fail();","target":226},{"file":"test\/bs2.i","line":431,"source":350,"type":"StatementEdge","stmt":"__cil_tmp76 = (unsigned int)node;","target":351},{"file":"test\/bs2.i","line":524,"source":427,"type":"StatementEdge","stmt":"__cil_tmp108 = __cil_tmp107 + 4;","target":428},{"file":"test\/bs2.i","line":667,"source":550,"type":"StatementEdge","stmt":"*((struct list_head **)__cil_tmp13) = (struct list_head *)__cil_tmp15;","target":551},{"file":"test\/bs2.i","line":753,"source":627,"type":"DeclarationEdge","stmt":"char *__cil_tmp8;","target":628},{"file":"test\/bs2.i","line":764,"source":637,"type":"ReturnStatementEdge","stmt":"return *((int *)entry);","target":619},{"file":"test\/bs2.i","line":3,"source":710,"type":"DeclarationEdge","stmt":"void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function);","target":711},{"file":"test\/bs2.i","line":335,"source":269,"type":"BlankEdge","stmt":"while","target":270},{"file":"test\/bs2.i","line":173,"source":136,"type":"DeclarationEdge","stmt":"struct node *__cil_tmp120;","target":137},{"file":"test\/bs2.i","line":631,"source":520,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp11;","target":521},{"file":"test\/bs2.i","line":98,"source":61,"type":"DeclarationEdge","stmt":"const struct list_head *__cil_tmp45;","target":62},{"file":"test\/bs2.i","line":12,"source":3,"type":"BlankEdge","stmt":"","target":6},{"file":"test\/bs2.i","line":826,"source":691,"type":"BlankEdge","stmt":"Goto: while_22_break","target":693},{"file":"test\/bs2.i","line":798,"source":668,"type":"StatementEdge","stmt":"val1 = tmp___0;","target":669},{"file":"test\/bs2.i","line":812,"source":678,"type":"ReturnStatementEdge","stmt":"return any_change;","target":639},{"file":"test\/bs2.i","line":368,"source":299,"type":"StatementEdge","stmt":"__cil_tmp58 = __cil_tmp57 + 12;","target":300},{"file":"test\/bs2.i","line":497,"source":404,"type":"StatementEdge","stmt":"__cil_tmp97 = 8;","target":405},{"file":"<none>","line":0,"source":306,"type":"BlankEdge","stmt":"","target":304},{"file":"test\/bs2.i","line":594,"source":725,"type":"DeclarationEdge","stmt":"void list_add(struct list_head *new, struct list_head *head);","target":726},{"file":"test\/bs2.i","line":219,"source":174,"type":"StatementEdge","stmt":"__cil_tmp12 = __cil_tmp11 != __cil_tmp7;","target":175},{"file":"test\/bs2.i","line":652,"source":535,"type":"StatementEdge","stmt":"__cil_tmp7 = (struct list_head *)__cil_tmp6;","target":536},{"file":"test\/bs2.i","line":63,"source":26,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp10;","target":27},{"file":"test\/bs2.i","line":541,"source":442,"type":"StatementEdge","stmt":"__cil_tmp112 = (unsigned int)node;","target":443},{"file":"test\/bs2.i","line":801,"source":671,"type":"StatementEdge","stmt":"pos0 = pos1;","target":673},{"file":"test\/bs2.i","line":120,"source":83,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp67;","target":84},{"file":"test\/bs2.i","line":85,"source":48,"type":"DeclarationEdge","stmt":"char *__cil_tmp32;","target":49},{"file":"<none>","line":0,"source":208,"type":"BlankEdge","stmt":"","target":206},{"file":"test\/bs2.i","line":612,"source":502,"type":"StatementEdge","stmt":"__cil_tmp4 = __cil_tmp3 + 4;","target":503},{"file":"test\/bs2.i","line":844,"source":705,"type":"CallToReturnEdge","stmt":"inspect(__cil_tmp2);","target":706},{"file":"test\/bs2.i","line":195,"source":154,"type":"StatementEdge","stmt":"__cil_tmp3 = (unsigned int)head;","target":155},{"file":"test\/bs2.i","line":694,"source":573,"type":"ReturnStatementEdge","stmt":"return;","target":556},{"file":"test\/bs2.i","line":588,"source":483,"type":"StatementEdge","stmt":"__cil_tmp4 = __cil_tmp3 + 4;","target":484},{"file":"test\/bs2.i","line":315,"source":254,"type":"StatementEdge","stmt":"__cil_tmp35 = __cil_tmp34 + 12;","target":255},{"file":"test\/bs2.i","line":128,"source":91,"type":"DeclarationEdge","stmt":"int __cil_tmp75;","target":92},{"file":"test\/bs2.i","line":519,"source":422,"type":"BlankEdge","stmt":"","target":423},{"file":"test\/bs2.i","line":633,"source":522,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp13;","target":523},{"file":"test\/bs2.i","line":265,"source":211,"type":"BlankEdge","stmt":"Label: while_4_break","target":212},{"file":"test\/bs2.i","line":628,"source":517,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp8;","target":518},{"file":"test\/bs2.i","line":115,"source":78,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp62;","target":79},{"file":"test\/bs2.i","line":539,"source":440,"type":"BlankEdge","stmt":"Label: while_17_continue","target":442},{"file":"test\/bs2.i","line":606,"source":498,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp4;","target":499},{"file":"test\/bs2.i","line":240,"source":192,"type":"CallToReturnEdge","stmt":"fail();","target":194},{"file":"test\/bs2.i","line":293,"source":234,"type":"StatementEdge","stmt":"__cil_tmp31 = (char *)head;","target":235},{"file":"test\/bs2.i","line":535,"source":437,"type":"BlankEdge","stmt":"Label: while_16_break","target":438},{"file":"test\/bs2.i","line":656,"source":537,"type":"BlankEdge","stmt":"while","target":538},{"file":"test\/bs2.i","line":311,"source":249,"type":"BlankEdge","stmt":"while","target":250},{"file":"test\/bs2.i","line":734,"source":610,"type":"StatementEdge","stmt":"__cil_tmp11 = (char *)next;","target":611},{"file":"test\/bs2.i","line":214,"source":169,"type":"StatementEdge","stmt":"__cil_tmp7 = (unsigned int)head;","target":170},{"file":"test\/bs2.i","line":92,"source":55,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp39;","target":56},{"file":"test\/bs2.i","line":114,"source":77,"type":"DeclarationEdge","stmt":"int __cil_tmp61;","target":78},{"file":"<none>","line":0,"source":342,"type":"BlankEdge","stmt":"","target":340},{"file":"test\/bs2.i","line":568,"source":465,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp5;","target":466},{"file":"test\/bs2.i","line":714,"source":591,"type":"BlankEdge","stmt":"while","target":592},{"file":"<none>","line":0,"source":620,"type":"BlankEdge","stmt":"Function start dummy edge","target":621},{"file":"test\/bs2.i","line":252,"source":201,"type":"StatementEdge","stmt":"__cil_tmp16 = (unsigned int)head;","target":202},{"file":"test\/bs2.i","line":491,"source":399,"type":"BlankEdge","stmt":"Label: while_14_break","target":400},{"file":"test\/bs2.i","line":579,"source":475,"type":"StatementEdge","stmt":"*((struct list_head **)prev) = new;","target":476},{"file":"test\/bs2.i","line":601,"source":493,"type":"ReturnStatementEdge","stmt":"return;","target":488},{"file":"test\/bs2.i","line":731,"source":607,"type":"StatementEdge","stmt":"__cil_tmp8 = __cil_tmp7 + 4;","target":608},{"file":"test\/bs2.i","line":834,"source":733,"type":"DeclarationEdge","stmt":"int main();","target":734},{"file":"test\/bs2.i","line":231,"source":182,"type":"StatementEdge","stmt":"__cil_tmp13 = (unsigned int)head;","target":183},{"file":"test\/bs2.i","line":140,"source":103,"type":"DeclarationEdge","stmt":"int __cil_tmp87;","target":104},{"file":"test\/bs2.i","line":762,"source":635,"type":"StatementEdge","stmt":"__cil_tmp9 = __cil_tmp8 - __cil_tmp7;","target":636},{"file":"test\/bs2.i","line":46,"source":11,"type":"CallToReturnEdge","stmt":"reach_error();","target":12},{"file":"test\/bs2.i","line":271,"source":216,"type":"StatementEdge","stmt":"__cil_tmp20 = (unsigned int)head;","target":217},{"file":"test\/bs2.i","line":70,"source":33,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp17;","target":34},{"file":"test\/bs2.i","line":127,"source":90,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp74;","target":91},{"file":"test\/bs2.i","line":249,"source":197,"type":"BlankEdge","stmt":"while","target":198},{"file":"test\/bs2.i","line":433,"source":352,"type":"StatementEdge","stmt":"__cil_tmp78 = (const struct list_head *)__cil_tmp77;","target":353},{"file":"test\/bs2.i","line":302,"source":244,"type":"CallToReturnEdge","stmt":"fail();","target":246},{"file":"test\/bs2.i","line":155,"source":118,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp102;","target":119},{"file":"test\/bs2.i","line":455,"source":370,"type":"StatementEdge","stmt":"__cil_tmp85 = (unsigned int)__cil_tmp84;","target":371},{"file":"test\/bs2.i","line":546,"source":447,"type":"StatementEdge","stmt":"__cil_tmp117 = (unsigned long)__cil_tmp116;","target":448},{"file":"test\/bs2.i","line":86,"source":49,"type":"DeclarationEdge","stmt":"struct node *__cil_tmp33;","target":50},{"file":"test\/bs2.i","line":623,"source":512,"type":"DeclarationEdge","stmt":"void *tmp;","target":513},{"file":"test\/bs2.i","line":30,"source":715,"type":"DeclarationEdge","stmt":"struct list_head {   struct list_head *next;   struct list_head *prev; } ;","target":716},{"file":"test\/bs2.i","line":121,"source":84,"type":"DeclarationEdge","stmt":"unsigned int __cil_tmp68;","target":85},{"file":"test\/bs2.i","line":516,"source":419,"type":"StatementEdge","stmt":"__cil_tmp105 = *((struct list_head * const *)head);","target":420},{"file":"test\/bs2.i","line":208,"source":164,"type":"BlankEdge","stmt":"Label: while_1_break","target":165},{"file":"test\/bs2.i","line":360,"source":290,"type":"BlankEdge","stmt":"while","target":291},{"file":"test\/bs2.i","line":474,"source":385,"type":"StatementEdge","stmt":"__cil_tmp89 = __cil_tmp88 + 4;","target":386},{"file":"test\/bs2.i","line":709,"source":588,"type":"DeclarationEdge","stmt":"char *__cil_tmp12;","target":589},{"file":"test\/bs2.i","line":416,"source":339,"type":"AssumeEdge","stmt":"[!(__cil_tmp75 == 0)]","target":342},{"file":"test\/bs2.i","line":416,"source":339,"type":"AssumeEdge","stmt":"[__cil_tmp75 == 0]","target":341},{"file":"<none>","line":0,"source":4,"type":"BlankEdge","stmt":"default return","target":0},{"file":"test\/bs2.i","line":397,"source":324,"type":"AssumeEdge","stmt":"[!(__cil_tmp71 == 0)]","target":327},{"file":"test\/bs2.i","line":158,"source":121,"type":"DeclarationEdge","stmt":"struct list_head *__cil_tmp105;","target":122},{"file":"test\/bs2.i","line":640,"source":527,"type":"StatementEdge","stmt":"node = (struct node *)tmp;","target":528},{"file":"test\/bs2.i","line":397,"source":324,"type":"AssumeEdge","stmt":"[__cil_tmp71 == 0]","target":326},{"file":"test\/bs2.i","line":549,"source":450,"type":"StatementEdge","stmt":"__cil_tmp120 = (struct node *)__cil_tmp119;","target":451},{"file":"test\/bs2.i","line":781,"source":653,"type":"StatementEdge","stmt":"pos0 = *((struct list_head **)__cil_tmp8);","target":654}]
}

// CFA graph variable declarations
var functions = cfaJson.functionNames;
var functionCallEdges = cfaJson.functionCallEdges;
var errorPath;
if (cfaJson.hasOwnProperty("errorPath")) {
	errorPath = cfaJson.errorPath;
}
var relevantEdges;
if (argJson.hasOwnProperty("relevantedges")) {
        relevantEdges = argJson.relevantedges;
}
var reducedEdges;
if (argJson.hasOwnProperty("reducededges")) {
        reducedEdges = argJson.reducededges;
}
var graphSplitThreshold = 700;
var zoomEnabled = false;
// A Dagre D3 Renderer
var render = new dagreD3.render();
const margin = 20;
var cfaWorker, argWorker;
var cfaSplit = false,
	argTabDisabled = false;

function init() {

	// Calculate total count of graphs to display in modal
	var argTotalGraphCount;
	if (argJson.nodes) {
		argTotalGraphCount = Math.ceil(argJson.nodes.length / graphSplitThreshold);
		$("#arg-modal").text("0/" + argTotalGraphCount);
	} else { // No ARG data -> happens if the AbstractStates are not ARGStates
		$("#arg-modal").text("0/0");
		$("#set-tab-2").addClass("disabled-btn");
		argTabDisabled = true;
		angular.element(document).ready(function(){
                  $("#set-tab-2").parent().attr("data-original-title", "ARG not available for this configuration of CPAchecker");
                  $("#set-tab-2").attr("data-toggle", "");
                });
	}
	var cfaTotalGraphCount = 0;
	cfaJson.functionNames.forEach(function (f) {
		var fNodes = cfaJson.nodes.filter(function (n) {
			return n.func === f;
		})
		cfaTotalGraphCount += Math.ceil(fNodes.length / graphSplitThreshold);
	});
	$("#cfa-modal").text("0/" + cfaTotalGraphCount);
	cfaTotalGraphCount = null;

	// Display modal window containing current rendering state
	$("#renderStateModal").modal("show");

	// Setup section widths accordingly
	if (errorPath === undefined) {
		d3.select("#errorpath_section").style("display", "none");
		$("#toggle_button_error_path").hide();
		$("#toggle_button_error_path_placeholder").hide();
	} else {
		d3.select("#externalFiles_section").style("width", "75%");
		d3.select("#cfa-toolbar").style("width", "auto");
	}

	// ======================= Define CFA and ARG Workers logic =======================
	/**
	 * The CFA Worker. Contains the logic for building a single or a multi CFA graph.
	 * The graph(s) is/are returned to the main script once created
	 */
	function cfaWorker_function() {
		self.importScripts("https://www.sosy-lab.org/lib/d3js/5.4.0/d3.min.js", "https://www.sosy-lab.org/lib/dagre-d3/0.5.0/dagre-d3.min.js");
		var json, nodes, mainNodes, edges, functions, combinedNodes, combinedNodesLabels, mergedNodes, functionCallEdges, errorPath;
		var graphSplitThreshold = 700; // default value
		var graphMap = [];
		var graphCounter = 0;

		// The first posted message will include the cfaJson
		self.addEventListener('message', function (m) {
			if (m.data.json !== undefined) {
				json = JSON.parse(m.data.json);
				extractVariables();
				buildGraphsAndPostResults();
			} else if (m.data.renderer !== undefined) {
				if (graphMap[graphCounter] !== undefined) {
					var node = nodes.find(function (n) {
						return n.index === parseInt(graphMap[graphCounter].nodes()[0]);
					});
					self.postMessage({
						"graph": JSON.stringify(graphMap[graphCounter]),
						"id": node.func + graphCounter,
						"func": node.func
					});
					graphCounter++;
				} else {
					self.postMessage({
						"status": "done"
					});
					graphMap = [];
					graphCounter = 0;
				}
			} else if (m.data.split !== undefined) {
				graphSplitThreshold = m.data.split;
				buildGraphsAndPostResults();
			}
		}, false);

		// Extract information from the cfaJson
		function extractVariables() {
			nodes = json.nodes;
			functions = json.functionNames;
			mainNodes = nodes.filter(function (n) {
				return n.func === functions[0];
			});
			edges = json.edges;
			combinedNodes = json.combinedNodes;
			combinedNodesLabels = json.combinedNodesLabels;
			mergedNodes = json.mergedNodes;
			functionCallEdges = json.functionCallEdges;
			if (json.hasOwnProperty("errorPath")) {
				errorPath = [];
				prepareCfaErrorPath();
			}
		}


		// Prepare Error Path array to be used in edge class decider
		function prepareCfaErrorPath() {
			var returnedEdges = {};
			for (var key in functionCallEdges) {
				returnedEdges[functionCallEdges[key][1]] = functionCallEdges[key][0]
			}
			json.errorPath.forEach(function (errPathElem) {
				if (errPathElem.source in functionCallEdges) {
					errPathElem.target = functionCallEdges[errPathElem.source][0];
				}
				if (errPathElem.target in returnedEdges) {
					errorPath.push({
						"source": returnedEdges[errPathElem.target],
						"target": errPathElem.target
					})
				}
				errorPath.push(errPathElem);
			})
		}

		function buildGraphsAndPostResults() {
			if (mainNodes.length > graphSplitThreshold) {
				buildMultipleGraphs(mainNodes, functions[0]);
			} else {
				buildSingleGraph(mainNodes, functions[0]);
			}
			if (functions.length > 1) {
				var functionsToProcess = functions.filter(function (f) {
					return f !== functions[0];
				});
				functionsToProcess.forEach(function (func) {
					var funcNodes = nodes.filter(function (n) {
						return n.func === func;
					});
					if (funcNodes.length > graphSplitThreshold) {
						buildMultipleGraphs(funcNodes, func);
					} else {
						buildSingleGraph(funcNodes, func);
					}
				});
			}
		}

		function buildSingleGraph(nodesToSet, funcName) {
			var g = createGraph();
			setGraphNodes(g, nodesToSet);
			roundNodeCorners(g);
			var nodesIndices = [];
			nodesToSet.forEach(function (n) {
				nodesIndices.push(n.index);
			});
			var edgesToSet = edges.filter(function (e) {
				return nodesIndices.includes(e.source) && nodesIndices.includes(e.target);
			});
			setGraphEdges(g, edgesToSet, false);
			if (funcName === functions[0]) {
				self.postMessage({
					"graph": JSON.stringify(g),
					"id": funcName + graphCounter,
					"func": funcName
				});
				graphMap.push(g);
			} else {
				graphMap.push(g);
			}
		}

		function buildMultipleGraphs(nodesToSet, funcName) {
			var requiredGraphs = Math.ceil(nodesToSet.length / graphSplitThreshold);
			var firstGraphBuild = false;
			var nodesPerGraph = [];
			for (var i = 1; i <= requiredGraphs; i++) {
				if (!firstGraphBuild) {
					nodesPerGraph = nodesToSet.slice(0, graphSplitThreshold);
					firstGraphBuild = true;
				} else {
					if (nodesToSet[graphSplitThreshold * i - 1] !== undefined)
						nodesPerGraph = nodesToSet.slice(graphSplitThreshold * (i - 1), graphSplitThreshold * i);
					else
						nodesPerGraph = nodesToSet.slice(graphSplitThreshold * (i - 1));
				}
				var graph = createGraph();
				setGraphNodes(graph, nodesPerGraph);
				if (graph.nodes().length > 0) {
					graphMap.push(graph);
					roundNodeCorners(graph);
					var graphEdges = edges.filter(function (e) {
						if ((nodesPerGraph[0].index <= e.source && e.source <= nodesPerGraph[nodesPerGraph.length - 1].index) &&
							(nodesPerGraph[0].index <= e.target && e.target <= nodesPerGraph[nodesPerGraph.length - 1].index)) {
							return e;
						}
					});
					setGraphEdges(graph, graphEdges, true);
				}
			}
			buildCrossgraphEdges(nodesToSet);
			if (funcName === functions[0]) {
				self.postMessage({
					"graph": JSON.stringify(graphMap[graphCounter]),
					"id": funcName + graphCounter,
					"func": funcName
				});
				graphCounter++;
			}
		}

		// Handle Edges that connect Graphs
		function buildCrossgraphEdges(crossGraphNodes) {
			var nodesIndices = [];
			crossGraphNodes.forEach(function (n) {
				nodesIndices.push(n.index);
			});
			var edgesToConsider = edges.filter(function (e) {
				return nodesIndices.includes(e.source) && nodesIndices.includes(e.target);
			});
			edgesToConsider.forEach(function (edge) {
				var source = edge.source;
				var target = edge.target;
				if (mergedNodes.includes(source) && mergedNodes.includes(target)) return;
				if (mergedNodes.includes(source)) source = getMergingNode(source);
				if (mergedNodes.includes(target)) target = getMergingNode(target);
				var sourceGraph = getGraphForNode(source);
				var targetGraph = getGraphForNode(target);
				if (sourceGraph < targetGraph) {
					if (Object.keys(functionCallEdges).includes("" + source)) {
						var funcCallNodeId = functionCallEdges["" + source][0];
						graphMap[sourceGraph].setNode(funcCallNodeId, {
							label: getNodeLabelFCall(edge.stmt),
							class: "cfa-node fcall",
							id: "cfa-node" + funcCallNodeId,
							shape: "rect"
						});
						graphMap[sourceGraph].setEdge(source, funcCallNodeId, {
							label: edge.stmt,
							labelStyle: labelStyleDecider(edge, source, funcCallNodeId),
							class: edgeClassDecider(edge, source, funcCallNodeId),
							id: "cfa-edge_" + source + "-" + funcCallNodeId
						});
						graphMap[sourceGraph].setNode("" + source + target + sourceGraph, {
							label: "",
							class: "cfa-dummy",
							id: "dummy-" + target,
							shape: "rect"
						});
						graphMap[sourceGraph].setEdge(funcCallNodeId, "" + source + target + sourceGraph, {
							label: source + "->" + target,
							style: "stroke-dasharray: 5, 5;"
						});
					} else {
						graphMap[sourceGraph].setNode("" + source + target + sourceGraph, {
							label: "",
							class: "cfa-dummy",
							id: "dummy-" + target,
							shape: "rect"
						});
						graphMap[sourceGraph].setEdge(source, "" + source + target + sourceGraph, {
							label: edge.stmt,
							labelStyle: labelStyleDecider(edge, source, "" + source + target + sourceGraph),
							id: "cfa-edge_" + source + "-" + target,
							class: edgeClassDecider(edge, source, "" + source + target + sourceGraph),
							style: "stroke-dasharray: 5, 5;"
						});
					}
					graphMap[targetGraph].setNode("" + target + source + targetGraph, {
						label: "",
						class: "dummy"
					});
					graphMap[targetGraph].setEdge("" + target + source + targetGraph, target, {
						label: "",
						labelStyle: "font-size: 12px;",
						id: "cfa-split-edge_" + source + "-" + target,
						class: "cfa-split-edge",
						style: "stroke-dasharray: 5, 5;"
					});
				} else if (sourceGraph > targetGraph) {
					graphMap[sourceGraph].setNode("" + source + target + sourceGraph, {
						label: "",
						class: "cfa-dummy",
						id: "dummy-" + target
					});
					graphMap[sourceGraph].setEdge(source, "" + source + target + sourceGraph, {
						label: edge.stmt,
						labelStyle: labelStyleDecider(edge, "" + source + target + sourceGraph, source),
						id: "cfa-edge_" + source + "-" + target,
						class: edgeClassDecider(edge, "" + source + target + sourceGraph, source),
						arrowhead: "undirected",
						style: "stroke-dasharray: 5, 5;"
					});
					graphMap[targetGraph].setNode("" + target + source + targetGraph, {
						label: "",
						class: "dummy",
						id: "node" + source
					});
					graphMap[targetGraph].setEdge("" + target + source + targetGraph, target, {
						label: "",
						labelStyle: "font-size: 12px;",
						id: "cfa-split-edge_" + source + "-" + target,
						class: "cfa-split-edge",
						arrowhead: "undirected",
						style: "stroke-dasharray: 5, 5;"
					});
				}
			});
		}

		// Return the graph in which the nodeNumber is present
		function getGraphForNode(nodeNumber) {
			return graphMap.findIndex(function (graph) {
				return graph.nodes().includes("" + nodeNumber);
			})
		}

		// create and return a graph element with a set transition
		function createGraph() {
			var g = new dagreD3.graphlib.Graph().setGraph({}).setDefaultEdgeLabel(
				function () {
					return {};
				});
			return g;
		}

		// Set nodes for the graph contained in the json nodes
		function setGraphNodes(graph, nodesToSet) {
			nodesToSet.forEach(function (n) {
				if (!mergedNodes.includes(n.index)) {
					graph.setNode(n.index, {
						label: setNodeLabel(n),
						labelStyle: "font-family: 'Courier New', Courier, monospace",
						class: "cfa-node",
						id: "cfa-node" + n.index,
						shape: nodeShapeDecider(n)
					});
				}
			});
		}

		// Node label, the label from combined nodes or a simple label
		function setNodeLabel(node) {
			var nodeIndex = "" + node.index;
			if (Object.keys(combinedNodesLabels).includes(nodeIndex))
				return combinedNodesLabels[nodeIndex];
			else return "N" + nodeIndex;
		}

		// Decide the shape of the nodes based on type
		function nodeShapeDecider(n) {
			if (n.loop) {
				return "diamond";
			} else if (Object.keys(combinedNodes).includes("" + n.index)) {
				return "rect";
			} else {
				return "circle";
			}
		}

		// Round the corners of rectangle shaped nodes
		function roundNodeCorners(graph) {
			graph.nodes().forEach(function (it) {
				var item = graph.node(it);
				item.rx = item.ry = 5;
			});
		}

		// Set the edges for a single graph while considering merged nodes and edges between them
		function setGraphEdges(graph, edgesToSet, multigraph) {
			edgesToSet.forEach(function (e) {
				var source, target;
				if (!mergedNodes.includes(e.source) && !mergedNodes.includes(e.target)) {
					source = e.source;
					target = e.target;
				} else if (!mergedNodes.includes(e.source) && mergedNodes.includes(e.target)) {
					source = e.source;
					target = getMergingNode(e.target);
				} else if (mergedNodes.includes(e.source) && !mergedNodes.includes(e.target)) {
					source = getMergingNode(e.source);
					target = e.target;
				}
				if (multigraph && (!graph.nodes().includes("" + source) || !graph.nodes().includes("" + target)))
					source = undefined;
				if (source !== undefined && target !== undefined && checkEligibleEdge(source, target)) {
					if (Object.keys(functionCallEdges).includes("" + source)) {
						var funcCallNodeId = functionCallEdges["" + source][0];
						graph.setNode(funcCallNodeId, {
							label: getNodeLabelFCall(e.stmt),
							class: "cfa-node fcall",
							id: "cfa-node" + funcCallNodeId,
							shape: "rect"
						});
						graph.setEdge(source, funcCallNodeId, {
							label: e.stmt,
							labelStyle: labelStyleDecider(e, source, funcCallNodeId),
							class: edgeClassDecider(e, source, funcCallNodeId),
							id: "cfa-edge_" + source + "-" + funcCallNodeId,
							weight: edgeWeightDecider(source, target)
						});
						graph.setEdge(funcCallNodeId, target, {
							label: "",
							labelStyle: labelStyleDecider(e, funcCallNodeId, target),
							class: edgeClassDecider(e, funcCallNodeId, target),
							id: "cfa-edge_" + funcCallNodeId + "-" + target,
							weight: edgeWeightDecider(source, target)
						});
					} else {
						graph.setEdge(source, target, {
							label: e.stmt,
							labelStyle: labelStyleDecider(e, source, target),
							lineInterpolate: "basis",
							class: edgeClassDecider(e, source, target),
							id: "cfa-edge_" + source + "-" + target,
							weight: edgeWeightDecider(source, target)
						});
					}
				}
			});
		}

		// If edge is part of error path, give it a representative class
		function edgeClassDecider(edge, source, target) {
			if (errorPath === undefined) {
				return "cfa-edge";
			}
			var mergedMatch = errorPath.find(function (entry) {
				return entry.source === source && entry.target === target;
			})
			var initialMatch = errorPath.find(function (entry) {
				return entry.source === edge.source && entry.target === edge.target;
			})
			if (mergedMatch !== undefined || initialMatch !== undefined) {
				return "cfa-edge error-edge";
			} else {
				return "cfa-edge";
			}
		}

		// If edge is part of error path, give its label a representative class
		function labelStyleDecider(edge, source, target) {
			var edgeClass = edgeClassDecider(edge, source, target);
			if (edgeClass.indexOf("error") !== -1) {
				return "font-size: 12px; fill: red";
			}
			return "font-size: 12px";
		}

		// Check if edge is eligible to place in graph. Same node edge only if it is not combined node
		function checkEligibleEdge(source, target) {
			if (mergedNodes.includes(source) && mergedNodes.includes(target)) return false;
			if (mergedNodes.includes(source) && Object.keys(combinedNodes).includes("" + target)) {
				if (combinedNodes["" + target].includes(source)) return false;
				else return true;
			}
			if (Object.keys(combinedNodes).includes("" + source) && mergedNodes.includes(target)) {
				if (combinedNodes["" + source].includes(target)) return false;
				else return true;
			}
			if ((Object.keys(combinedNodes).includes("" + source) && Object.keys(combinedNodes).includes("" + target)) && source == target) return false;
			return true;
		}

		// Retrieve the node in which this node was merged
		function getMergingNode(index) {
			var result = "";
			Object.keys(combinedNodes).some(function (key) {
				if (combinedNodes[key].includes(index)) {
					result = key;
					return result;
				}
			})
			return parseInt(result);
		}

		// Decide the weight for the edges based on type
		function edgeWeightDecider(source, target) {
			var sourceNode = nodes.find(function (it) {
				return it.index === source;
			})
			var targetNode = nodes.find(function (it) {
				return it.index === target;
			})
			if (source === target) {
				return 2;
			} else if (sourceNode.rpid < targetNode.rpid) {
				return 0;
			} else {
				return 1;
			}
		}

		// Get node label for functionCall node by providing the edge statement
		function getNodeLabelFCall(stmt) {
			var result = "";
			if (stmt.includes("=")) {
				result = stmt.split("=")[1].split("(")[0].trim();
			} else {
				result = stmt.split("(")[0].trim();
			}
			return result;
		}

	}

	/**
	 * The ARG Worker. Contains the logic for creating a single or multi ARG graph.
	 * Once the graph(s) is/are created they are returned to the main script.
	 * ONLY if ARG data is available!
	 */
	if (argJson.nodes) {
		function argWorker_function() {
			self.importScripts("https://www.sosy-lab.org/lib/d3js/5.4.0/d3.min.js", "https://www.sosy-lab.org/lib/dagre-d3/0.5.0/dagre-d3.min.js");
			var json, nodes, edges, errorPath, relevantNodes, relevantEdges, errorGraphMap;
			var graphSplitThreshold = 700;
			var graphMap = [], graphCounter = 0,
			    simplifiedGraphMap, simplifiedGraphCounter = 0,
			    reducedGraphMap, reducedGraphCounter = 0;
			self.addEventListener("message", function (m) {
				if (m.data.json !== undefined) {
					json = JSON.parse(m.data.json);
					nodes = json.nodes;
					edges = json.edges;
					buildGraphsAndPrepareResults(nodes, edges, "default");
					if(json.relevantedges !== undefined && json.relevantnodes !== undefined){
					        relevantEdges = json.relevantedges;
					        relevantNodes = json.relevantnodes;
					        simplifiedGraphMap = [];
					        buildGraphsAndPrepareResults(relevantNodes, relevantEdges, "relevant");
					}
					if(json.reducededges !== undefined && json.reducednodes !== undefined){
				        reducedEdges = json.reducededges;
				        reducedNodes = json.reducednodes;
				        reducedGraphMap = [];
				        buildGraphsAndPrepareResults(reducedNodes, reducedEdges, "witness");
					}
				} else if (m.data.errorPath !== undefined) {
					errorPath = [];
					JSON.parse(m.data.errorPath).forEach(function (d) {
						if (d.argelem !== undefined) {
							errorPath.push(d.argelem);
						}
					});
				} else if (m.data.renderer !== undefined) {
					if (graphMap.length > 0) {
						self.postMessage({
							"graph": JSON.stringify(graphMap[0]),
							"id": graphCounter
						});
						graphMap.shift();
						graphCounter++;
					} else {
						self.postMessage({
							"status": "done"
						});
						if (simplifiedGraphMap.length > 0) {
						        self.postMessage({
						              "graph": JSON.stringify(simplifiedGraphMap[0]),
						              "id": simplifiedGraphCounter,
						              "simplifiedGraph" : true
						        });
						        simplifiedGraphMap.shift();
						        simplifiedGraphCounter++;
						}
						if (typeof reducedGraphMap !== 'undefined' && reducedGraphMap.length > 0) {
					        self.postMessage({
					              "graph": JSON.stringify(reducedGraphMap[0]),
					              "id": reducedGraphCounter,
					              "reducedGraph" : true
					        });
					        reducedGraphMap.shift();
					        reducedGraphCounter++;
						}
						if (errorPath !== undefined) {
							errorGraphMap = [];
							graphCounter = 0;
							prepareErrorGraph();
						}
					}
				} else if (m.data.errorGraph !== undefined) {
					if (errorGraphMap.length > 0) {
						self.postMessage({
							"graph": JSON.stringify(errorGraphMap[0]),
							"id": graphCounter,
							"errorGraph": true
						});
						errorGraphMap.shift();
						graphCounter++;
					}
				} else if (m.data.split !== undefined) {
					graphSplitThreshold = m.data.split;
					if (errorGraphMap !== undefined && errorGraphMap.length > 0) {
						errorGraphMap = [];
					}
					buildGraphsAndPrepareResults();
				}
			}, false);

			function buildGraphsAndPrepareResults(nodes, edges, graphLabel) {
				if (nodes.length > graphSplitThreshold) {
					buildMultipleGraphs(nodes, edges, graphLabel);
				} else {
					buildSingleGraph(nodes, edges, graphLabel);
				}
			}

			// After the initial ARG graph has been send to the master script, prepare ARG containing only error path
			function prepareErrorGraph() {
				var errorNodes = [],
					errorEdges = [];
				nodes.forEach(function (n) {
					if (errorPath.includes(n.index)) {
						errorNodes.push(n);
					}
				});
				edges.forEach(function (e) {
					if (errorPath.includes(e.source) && errorPath.includes(e.target)) {
						errorEdges.push(e);
					}
				});
				if (errorNodes.length > graphSplitThreshold) {
					buildMultipleErrorGraphs(errorNodes, errorEdges);
				} else {
					var g = createGraph();
					setGraphNodes(g, errorNodes);
					setGraphEdges(g, errorEdges, false);
					errorGraphMap.push(g);
				}
			}

			function buildSingleGraph(nodes, edges, graphLabel) {
				var g = createGraph();
				setGraphNodes(g, nodes);
				setGraphEdges(g, edges, false);
				if(graphLabel === "relevant"){
					simplifiedGraphMap.push(g);
				} else if (graphLabel === "witness") {
					reducedGraphMap.push(g);
				} else {
					graphMap.push(g);
				}
			}

			// Split the ARG graph honoring the split threshold
			function buildMultipleGraphs(nodes, edges, graphLabel) {
				nodes.sort(function (firstNode, secondNode) {
					return firstNode.index - secondNode.index;
				})
				var requiredGraphs = Math.ceil(nodes.length / graphSplitThreshold);
				var firstGraphBuild = false;
				var nodesPerGraph = [];
				for (var i = 1; i <= requiredGraphs; i++) {
					if (!firstGraphBuild) {
						nodesPerGraph = nodes.slice(0, graphSplitThreshold);
						firstGraphBuild = true;
					} else {
						if (nodes[graphSplitThreshold * i - 1] !== undefined) {
							nodesPerGraph = nodes.slice(graphSplitThreshold * (i - 1), graphSplitThreshold * i);
						} else {
							nodesPerGraph = nodes.slice(graphSplitThreshold * (i - 1));
						}
					}
					var graph = createGraph();
					if (graphLabel === "relevant") {
					    simplifiedGraphMap.push(graph);
					} else if (graphLabel === "witness") {
						reducedGraphMap.push(graph);
					} else {
						graphMap.push(graph);
					}
					setGraphNodes(graph, nodesPerGraph);
					var nodesIndices = []
					nodesPerGraph.forEach(function (n) {
						nodesIndices.push(n.index);
					});
					var graphEdges = edges.filter(function (e) {
						if (nodesIndices.includes(e.source) && nodesIndices.includes(e.target)) {
							return e;
						}
					});
					setGraphEdges(graph, graphEdges, true);
				}
				buildCrossgraphEdges(edges, false);
			}

			// Split the ARG error graph honoring the split threshold
			function buildMultipleErrorGraphs(errorNodes, errorEdges) {
				errorNodes.sort(function (firstNode, secondNode) {
					return firstNode.index - secondNode.index;
				})
				var requiredGraphs = Math.ceil(errorNodes.length / graphSplitThreshold);
				var firstGraphBuild = false;
				var nodesPerGraph = [];
				for (var i = 1; i <= requiredGraphs; i++) {
					if (!firstGraphBuild) {
						nodesPerGraph = errorNodes.slice(0, graphSplitThreshold);
						firstGraphBuild = true;
					} else {
						if (nodes[graphSplitThreshold * i - 1] !== undefined) {
							nodesPerGraph = errorNodes.slice(graphSplitThreshold * (i - 1), graphSplitThreshold * i);
						} else {
							nodesPerGraph = errorNodes.slice(graphSplitThreshold * (i - 1));
						}
					}
					var graph = createGraph();
					errorGraphMap.push(graph);
					setGraphNodes(graph, nodesPerGraph);
					var nodesIndices = []
					nodesPerGraph.forEach(function (n) {
						nodesIndices.push(n.index);
					});
					var graphEdges = errorEdges.filter(function (e) {
						if (nodesIndices.includes(e.source) && nodesIndices.includes(e.target)) {
							return e;
						}
					});
					setGraphEdges(graph, graphEdges, true);
				}
				buildCrossgraphEdges(errorEdges, true);
			}

			// Handle graph connecting edges
			function buildCrossgraphEdges(edges, errorGraph) {
				edges.forEach(function (edge) {
					var sourceGraph, targetGraph;
					if (errorGraph) {
						sourceGraph = getGraphForErrorNode(edge.source);
						targetGraph = getGraphForErrorNode(edge.target);
						if (sourceGraph < targetGraph) {
							errorGraphMap[sourceGraph].setNode("" + edge.source + edge.target + sourceGraph, {
								label: "",
								class: "arg-dummy",
								id: "dummy-" + edge.target
							});
							errorGraphMap[sourceGraph].setEdge(edge.source, "" + edge.source + edge.target + sourceGraph, {
								label: edge.label,
								id: "arg-edge" + edge.source + edge.target,
								style: "stroke-dasharray: 5, 5;",
								class: edgeClassDecider(edge)
							});
							errorGraphMap[targetGraph].setNode("" + edge.target + edge.source + targetGraph, {
								label: "",
								class: "dummy"
							});
							errorGraphMap[targetGraph].setEdge("" + edge.target + edge.source + targetGraph, edge.target, {
								label: "",
								labelStyle: "font-size: 12px;",
								id: "arg-edge_" + edge.source + "-" + edge.target,
								style: "stroke-dasharray: 5, 5;",
								class: "arg-split-edge"
							});
						} else if (sourceGraph > targetGraph) {
							errorGraphMap[sourceGraph].setNode("" + edge.source + edge.target + sourceGraph, {
								label: "",
								class: "arg-dummy",
								id: "dummy-" + edge.target
							});
							errorGraphMap[sourceGraph].setEdge(edge.source, "" + edge.source + edge.target + sourceGraph, {
								label: edge.label,
								id: "arg-edge" + edge.source + edge.target,
								arrowhead: "undirected",
								style: "stroke-dasharray: 5, 5;",
								class: edgeClassDecider(edge)
							});
							errorGraphMap[targetGraph].setNode("" + edge.target + edge.source + targetGraph, {
								label: "",
								class: "dummy"
							});
							errorGraphMap[targetGraph].setEdge("" + edge.target + edge.source + targetGraph, edge.target, {
								label: "",
								labelStyle: "font-size: 12px;",
								id: "arg-edge_" + edge.source + "-" + edge.target,
								arrowhead: "undirected",
								style: "stroke-dasharray: 5, 5;",
								class: "arg-split-edge"
							});
						}
					} else {
						sourceGraph = getGraphForNode(edge.source);
						targetGraph = getGraphForNode(edge.target);
						if (sourceGraph < targetGraph) {
							graphMap[sourceGraph].setNode("" + edge.source + edge.target + sourceGraph, {
								label: "",
								class: "arg-dummy",
								id: "dummy-" + edge.target
							});
							graphMap[sourceGraph].setEdge(edge.source, "" + edge.source + edge.target + sourceGraph, {
								label: edge.label,
								id: "arg-edge" + edge.source + edge.target,
								style: "stroke-dasharray: 5, 5;",
								class: edgeClassDecider(edge)
							});
							graphMap[targetGraph].setNode("" + edge.target + edge.source + targetGraph, {
								label: "",
								class: "dummy"
							});
							graphMap[targetGraph].setEdge("" + edge.target + edge.source + targetGraph, edge.target, {
								label: "",
								labelStyle: "font-size: 12px;",
								id: "arg-edge_" + edge.source + "-" + edge.target,
								style: "stroke-dasharray: 5, 5;",
								class: "arg-split-edge"
							});
						} else if (sourceGraph > targetGraph) {
							graphMap[sourceGraph].setNode("" + edge.source + edge.target + sourceGraph, {
								label: "",
								class: "arg-dummy",
								id: "dummy-" + edge.target
							});
							graphMap[sourceGraph].setEdge(edge.source, "" + edge.source + edge.target + sourceGraph, {
								label: edge.label,
								id: "arg-edge" + edge.source + edge.target,
								arrowhead: "undirected",
								style: "stroke-dasharray: 5, 5;",
								class: edgeClassDecider(edge)
							});
							graphMap[targetGraph].setNode("" + edge.target + edge.source + targetGraph, {
								label: "",
								class: "dummy"
							});
							graphMap[targetGraph].setEdge("" + edge.target + edge.source + targetGraph, edge.target, {
								label: "",
								labelStyle: "font-size: 12px;",
								id: "arg-edge_" + edge.source + "-" + edge.target,
								arrowhead: "undirected",
								style: "stroke-dasharray: 5, 5;",
								class: "arg-split-edge"
							});
						}
					}
				});
			}

			// Return the graph in which the nodeNumber is present
			function getGraphForNode(nodeNumber) {
				return graphMap.findIndex(function (graph) {
					return graph.nodes().includes("" + nodeNumber);
				})
			}

			// Return the graph in which the nodeNumber is present for an error node
			function getGraphForErrorNode(nodeNumber) {
				return errorGraphMap.findIndex(function (graph) {
					return graph.nodes().includes("" + nodeNumber);
				})
			}

			// create and return a graph element with a set transition
			function createGraph() {
				var g = new dagreD3.graphlib.Graph().setGraph({}).setDefaultEdgeLabel(
					function () {
						return {};
					});
				return g;
			}

			// Set nodes for the graph contained in the json nodes
			function setGraphNodes(graph, nodesToSet) {
				nodesToSet.forEach(function (n) {
					if (n.type === "target" && errorPath !== undefined && !errorPath.includes(n.index)) {
						errorPath.push(n.index);
					}
					graph.setNode(n.index, {
						label: n.label,
						class: "arg-node " + n.type,
						id: nodeIdDecider(n)
					});
				});
			}

			function nodeIdDecider(node) {
				if (errorGraphMap === undefined)
					return "arg-node" + node.index;
				else
					return "arg-error-node" + node.index;
			}

			// Set the graph edges
			function setGraphEdges(graph, edgesToSet, multigraph) {
				edgesToSet.forEach(function (e) {
					if (!multigraph || (graph.nodes().includes("" + e.source) && graph.nodes().includes("" + e.target))) {
						graph.setEdge(e.source, e.target, {
							label: e.label,
							lineInterpolate: "basis",
							class: edgeClassDecider(e),
							id: "arg-edge" + e.source + e.target,
							weight: edgeWeightDecider(e)
						});
					}
				});
			}

			// Set class for passed edge
			function edgeClassDecider(edge) {
				if (errorPath !== undefined && errorPath.includes(edge.source) && errorPath.includes(edge.target)) {
					return "arg-edge error-edge";
				} else {
					return "arg-edge";
				}
			}

			// Decide the weight for the edges based on type
			function edgeWeightDecider(edge) {
				if (edge.type === "covered") return 0;
				return 1;
			}

		}
	}

	// ======================= Create CFA and ARG Worker Listeners =======================
	/**
	 * Create workers using blobs due to Chrome's default security policy and
	 * the need of having a single file at the end that can be send i.e. via e-mail
	 */
	cfaWorker = new Worker(URL.createObjectURL(new Blob(["(" + cfaWorker_function + ")()"], {
		type: 'text/javascript'
	})));
	if (argJson.nodes) {
		argWorker = new Worker(URL.createObjectURL(new Blob(["(" + argWorker_function + ")()"], {
			type: "text/javascript"
		})));
	}

	cfaWorker.addEventListener("message", function (m) {
		if (m.data.graph !== undefined) {
			// id was already processed
			if (!d3.select("#cfa-graph-" + m.data.id).empty()) {
				cfaWorker.postMessage({
					"renderer": "ready"
				});
				return;
			}
			var id = m.data.id;
			d3.select("#cfa-container").append("div").attr("id", "cfa-graph-" + id).attr("class", "cfa-graph");
			var g = createGraph();
			g = Object.assign(g, JSON.parse(m.data.graph));
			var svg = d3.select("#cfa-graph-" + id).append("svg").attr("id", "cfa-svg-" + id).attr("class", "cfa-svg " + "cfa-svg-" + m.data.func);
			var svgGroup = svg.append("g");
			render(d3.select("#cfa-svg-" + id + " g"), g);
			// Center the graph - calculate svg.attributes
			svg.attr("height", g.graph().height + margin * 2);
			svg.attr("width", g.graph().width + margin * 10);
			svgGroup.attr("transform", "translate(" + margin * 2 + ", " + margin + ")");
			$("#cfa-modal").text(parseInt($("#cfa-modal").text().split("/")[0]) + 1 + "/" + $("#cfa-modal").text().split("/")[1]);
			cfaWorker.postMessage({
				"renderer": "ready"
			});
		} else if (m.data.status !== undefined) {
			addEventsToCfa();
			d3.select("#cfa-toolbar").style("visibility", "visible");
			d3.select("#cfa-container").classed("cfa-content", true);
			d3.selectAll(".cfa-svg").each(function (d, i) {
				d3.select(this).attr("width", Math.max(d3.select(this).attr("width"), d3.select(this.parentNode).style("width").split("px")[0]));
			});
			d3.selectAll(".cfa-graph").style("visibility", "visible");
			if (cfaSplit) {
				$("#renderStateModal").hide();
				$('.modal-backdrop').hide();
			} else {
				if (!argTabDisabled) {
					argWorker.postMessage({
						"renderer": "ready"
					});
				} else {
					$("#renderStateModal").hide();
					$('.modal-backdrop').hide();
				}
			}
		}
	}, false);

	cfaWorker.addEventListener("error", function (e) {
		alert("CFA Worker failed in line " + e.lineno + " with message " + e.message)
	}, false);

	// Initial postMessage to the CFA worker to trigger CFA graph(s) creation
	cfaWorker.postMessage({
		"json": JSON.stringify(cfaJson)
	});

	// ONLY if ARG data is available
	if (argJson.nodes) {
		argWorker.addEventListener('message', function (m) {
			if (m.data.graph !== undefined) {
				var id = "arg-graph" + m.data.id;
				var argClass = "arg-graph";
				if (m.data.errorGraph !== undefined) {
					id = "arg-error-graph" + m.data.id;
					argClass = "arg-error-graph";
					d3.select("#arg-modal-error").style("display", "inline");
					$("#renderStateModal").modal("show");
				}
				if(m.data.simplifiedGraph !== undefined) {
				        id = "arg-simplified-graph" + m.data.id;
				        argClass = "arg-simplified-graph";
				}
				if(m.data.reducedGraph !== undefined) {
					id = "arg-reduced-graph" + m.data.id;
					argClass = "arg-reduced-graph";
				}
				var g = createGraph();
				g = Object.assign(g, JSON.parse(m.data.graph));
				d3.select("#arg-container").append("div").attr("id", id).attr("class", argClass);
				var svg = d3.select("#" + id).append("svg").attr("id", "arg-svg" + id).attr("class", "arg-svg");
				var svgGroup = svg.append("g");
				render(d3.select("#arg-svg" + id + " g"), g);
				// Center the graph - calculate svg.attributes
				svg.attr("height", g.graph().height + margin * 2);
				svg.attr("width", g.graph().width + margin * 10);
				svgGroup.attr("transform", "translate(" + margin * 2 + ", " + margin + ")");
				// FIXME: until https://github.com/cpettitt/dagre-d3/issues/169 is not resolved, label centering like so:
				d3.selectAll(".arg-node tspan").each(function (d, i) {
					var transformation = d3.select(this.parentNode.parentNode).attr("transform")
					d3.select(this).attr("dx", Math.abs(getTransformation(transformation).translateX));
				});
				if (m.data.errorGraph !== undefined) {
					addEventsToArg();
					$("#renderStateModal").hide();
					$('.modal-backdrop').hide();
					argWorker.postMessage({
						"errorGraph": true
					});
				} else {
					$("#arg-modal").text(parseInt($("#arg-modal").text().split("/")[0]) + 1 + "/" + $("#arg-modal").text().split("/")[1]);
					argWorker.postMessage({
						"renderer": "ready"
					});
				}
			} else if (m.data.status !== undefined) {
				if ($("#report-controller").scope().getTabSet() === 2) {
					d3.select("#arg-toolbar").style("visibility", "visible");
					d3.select("#arg-container").classed("arg-content", true);
					d3.selectAll(".arg-graph").style("visibility", "visible");
					$("#arg-container").scrollLeft(d3.select(".arg-svg").attr("width") / 4);
				}
				addEventsToArg();
				if (errorPath !== undefined) {
					d3.selectAll("td.disabled").classed("disabled", false);
					if (!d3.select(".make-pretty").classed("prettyprint")) {
						d3.selectAll(".make-pretty").classed("prettyprint", true);
						PR.prettyPrint();
					}
				}
				$("#renderStateModal").hide();
				$('.modal-backdrop').hide();
			}
		}, false);

		argWorker.addEventListener("error", function (e) {
			alert("ARG Worker failed in line " + e.lineno + " with message " + e.message)
		}, false);

		// Initial postMessage to the ARG worker to trigger ARG graph(s) creation
		if (errorPath !== undefined) {
			argWorker.postMessage({
				"errorPath": JSON.stringify(errorPath)
			});
		}
		argWorker.postMessage({
			"json": JSON.stringify(argJson)
		});
	}

	// Function to get transfromation thorugh translate as in new version of D3.js d3.transfrom is removed
	function getTransformation(transform) {
		// Create a dummy g for calculation purposes only. This will never
		// be appended to the DOM and will be discarded once this function
		// returns.
		var g = document.createElementNS("http://www.w3.org/2000/svg", "g");

		// Set the transform attribute to the provided string value.
		g.setAttributeNS(null, "transform", transform);

		// consolidate the SVGTransformList containing all transformations
		// to a single SVGTransform of type SVG_TRANSFORM_MATRIX and get
		// its SVGMatrix.
		var matrix = g.transform.baseVal.consolidate().matrix;

		// Below calculations are taken and adapted from the private function
		// transform/decompose.js of D3's module d3-interpolate.
		// var {
		// 	a,
		// 	b,
		// 	c,
		// 	d,
		// 	e,
		// 	f
		// } = matrix; // ES6, if this doesn't work, use below assignment
		var a = matrix.a,
			b = matrix.b,
			c = matrix.c,
			d = matrix.d,
			e = matrix.e,
			f = matrix.f; // ES5
		var scaleX, scaleY, skewX;
		if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
		if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
		if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
		if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
		return {
			translateX: e,
			translateY: f,
			rotate: Math.atan2(b, a) * 180 / Math.PI,
			skewX: Math.atan(skewX) * 180 / Math.PI,
			scaleX: scaleX,
			scaleY: scaleY
		};
	}

	// create and return a graph element with a set transition
	function createGraph() {
		var g = new dagreD3.graphlib.Graph().setGraph({}).setDefaultEdgeLabel(
			function () {
				return {};
			});
		return g;
	}

	// Retrieve the node in which this node was merged - used for the node events
	// FIXME: this is a duplicate function already contained in error path controller, currently no better way to call it
	function getMergingNode(index) {
		var result = "";
		Object.keys(cfaJson.combinedNodes).some(function (key) {
			if (cfaJson.combinedNodes[key].includes(index)) {
				result = key;
				return result;
			}
		})
		return result;
	}

	// Add desired events to CFA nodes and edges
	function addEventsToCfa() {
		addPanEvent(".cfa-svg");
		d3.selectAll(".cfa-node").on("mouseover", function (d) {
			var message;
			if (parseInt(d) > 100000) {
				message = "<span class=\" bold \">type</span>: function call node <br>" + "<span class=\" bold \">dblclick</span>: Select function";
			} else {
				var node = cfaJson.nodes.find(function (n) {
					return n.index === parseInt(d);
				});
				message = "<span class=\" bold \">function</span>: " + node.func;
				if (d in cfaJson.combinedNodes) {
					message += "<br><span class=\" bold \">combines nodes</span> : " + Math.min.apply(null, cfaJson.combinedNodes[d]) + "-" + Math.max.apply(null, cfaJson.combinedNodes[d]);
				}
				message += "<br> <span class=\" bold \">reverse postorder Id</span>: " + node.rpid;
			}
			showToolTipBox(d3.event, message);
		}).on("mouseout", function () {
			hideToolTipBox();
		});
		d3.selectAll(".fcall").on("dblclick", function (d) {
			$("#cfa-toolbar").scope().selectedCFAFunction = d3.select("#cfa-node" + d + " text").text();
			$("#cfa-toolbar").scope().setCFAFunction();
		});
		d3.selectAll(".cfa-dummy").on("mouseover", function (d) {
			showToolTipBox(d3.event, "<span class=\" bold \">type</span>: placeholder <br> <span class=\" bold \">dblclick</span>: jump to Target node");
		}).on("mouseout", function () {
			hideToolTipBox();
		}).on("dblclick", function () {
			if (!d3.select(".marked-cfa-node").empty()) {
				d3.select(".marked-cfa-node").classed("marked-cfa-node", false);
			}
			var selection = d3.select("#cfa-node" + d3.select(this).attr("id").split("-")[1]);
			selection.classed("marked-cfa-node", true);
			var boundingRect = selection.node().getBoundingClientRect();
			$("#cfa-container").scrollTop(boundingRect.top + $("#cfa-container").scrollTop() - 300).scrollLeft(boundingRect.left + $("#cfa-container").scrollLeft() - $("#errorpath_section").width() - 2 * boundingRect.width);
		})
		d3.selectAll(".cfa-edge")
			.on("mouseover", function (d) {
				d3.select(this).select("path").style("stroke-width", "3px");
				showToolTipBox(d3.event, "<span class=\" bold \">dblclick</span>: jump to Source line");
			}).on("mouseout", function () {
				d3.select(this).select("path").style("stroke-width", "1.5px");
				hideToolTipBox();
			}).on("dblclick", function (d) {
				var edge = findCfaEdge(d);
				if (edge === undefined) { // this occurs for edges between graphs - splitting edges
					var thisEdgeData = d3.select(this).attr("id").split("_")[1];
					edge = findCfaEdge({
						v: thisEdgeData.split("-")[0],
						w: thisEdgeData.split("-")[1]
					});
				}
				$("#set-tab-3").click();
				var line = edge.line;
				if (line === 0) {
					line = 1;
				}
				if (!d3.select(".marked-source-line").empty()) {
					d3.select(".marked-source-line").classed("marked-source-line", false);
				}
				var selection = d3.select("#source-" + line + " td pre.prettyprint");
				selection.classed("marked-source-line", true);
				$(".sourceContent").scrollTop(selection.node().getBoundingClientRect().top + $(".sourceContent").scrollTop() - 200);
			});
		d3.selectAll(".cfa-split-edge")
			.on("mouseover", function (d) {
				d3.select(this).select("path").style("stroke-width", "3px");
				showToolTipBox(d3.event, "<span class=\" bold \">type</span>: place holder <br> <span class=\" bold \">dblclick</span>: jump to Original edge");
			}).on("mouseout", function () {
				d3.select(this).select("path").style("stroke-width", "1.5px");
				hideToolTipBox();
			}).on("dblclick", function () {
				var edgeSourceTarget = d3.select(this).attr("id").split("_")[1];
				if (!d3.select(".marked-cfa-edge").empty()) {
					d3.select(".marked-cfa-edge").classed("marked-cfa-edge", false);
				}
				var selection = d3.select("#cfa-edge_" + edgeSourceTarget.split("-")[0] + "-" + edgeSourceTarget.split("-")[1]);
				selection.classed("marked-cfa-edge", true);
				var boundingRect = selection.node().getBoundingClientRect();
				$("#cfa-container").scrollTop(boundingRect.top + $("#cfa-container").scrollTop() - 300).scrollLeft(boundingRect.left + $("#cfa-container").scrollLeft() - $("#errorpath_section").width() - 2 * boundingRect.width);
			})
	}

	// Find and return the actual edge element from cfaJson.edges array by considering funcCallEdges and combinedNodes
	function findCfaEdge(eventElement) {
		var source = parseInt(eventElement.v);
		var target = parseInt(eventElement.w);
		if (source > 100000) {
			source = Object.keys(cfaJson.functionCallEdges).find(function (key) {
				if (cfaJson.functionCallEdges[key].includes(source)) {
					return key;
				}
			});
		}
		if (target > 100000) {
			target = cfaJson.functionCallEdges[eventElement.v][1];
		}
		if (source in cfaJson.combinedNodes) {
			source = cfaJson.combinedNodes[source][cfaJson.combinedNodes[source].length - 1];
		}
		return cfaJson.edges.find(function (e) {
			return e.source === parseInt(source) && e.target === target;
		})
	}

	// Add desired events to ARG the nodes
	function addEventsToArg() {
		addPanEvent(".arg-svg");
		d3.selectAll(".arg-node")
			.on("mouseover", function (d) {
				var nodesArray = Array.prototype.concat(
						argJson.nodes,
						typeof argJson.relevantnodes === "undefined" ? [] : argJson.relevantnodes,
						typeof argJson.reducednodes === "undefined" ? [] : argJson.reducednodes
				);
				var node = nodesArray.find(function (it) {
					return it.index === parseInt(d);
				})
				var message = "<span class=\" bold \">function</span>: " + node.func + "<br>";
				if (node.type) {
					message += "<span class=\" bold \">type</span>: " + node.type + "<br>";
				}
				message += "<span class=\" bold \">dblclick</span>: jump to CFA node";
				showToolTipBox(d3.event, message);
			}).on("mouseout", function () {
				hideToolTipBox();
			}).on("dblclick", function () {
				$("#set-tab-1").click();
				if (!d3.select(".marked-cfa-node").empty()) {
					d3.select(".marked-cfa-node").classed("marked-cfa-node", false);
				}
				var nodeId = d3.select(this).select("tspan").text().split("N")[1];
				if (cfaJson.mergedNodes.includes(parseInt(nodeId))) {
					nodeId = getMergingNode(parseInt(nodeId));
				}
				var selection = d3.select("#cfa-node" + nodeId);
				selection.classed("marked-cfa-node", true);
				var boundingRect = selection.node().getBoundingClientRect();
				$("#cfa-container").scrollTop(boundingRect.top + $("#cfa-container").scrollTop() - 300).scrollLeft(boundingRect.left + $("#cfa-container").scrollLeft() - $("#errorpath_section").width() - 2 * boundingRect.width);
			});
		d3.selectAll(".arg-dummy")
			.on("mouseover", function (d) {
				showToolTipBox(d3.event, "<span class=\" bold \">type</span>: placeholder <br> <span class=\" bold \">dblclick</span>: jump to Target node");
			}).on("mouseout", function () {
				hideToolTipBox();
			}).on("dblclick", function () {
				if (!d3.select(".marked-arg-node").empty()) {
					d3.select(".marked-arg-node").classed("marked-arg-node", false);
				}
				var selection = d3.select("#arg-node" + d3.select(this).attr("id").split("-")[1]);
				selection.classed("marked-arg-node", true);
				var boundingRect = selection.node().getBoundingClientRect();
				$("#arg-container").scrollTop(boundingRect.top + $("#arg-container").scrollTop() - 300).scrollLeft(boundingRect.left + $("#arg-container").scrollLeft() - $("#errorpath_section").width() - 2 * boundingRect.width);
			});
		d3.selectAll(".arg-edge")
			.on("mouseover", function (d) {
				d3.select(this).select("path").style("stroke-width", "3px");
				var edgeArray = Array.prototype.concat(
						argJson.edges,
						typeof argJson.relevantedges === "undefined" ? [] : argJson.relevantedges,
						typeof argJson.reducededges === "undefined" ? [] : argJson.reducededges
						);
				var edge = edgeArray.find(function (it) {
					return it.source === parseInt(d.v) && it.target === parseInt(d.w);
				})
				var message = "";
				Object.keys(edge).forEach(function(key,index) {
					if ($.inArray(key,["target", "source", "label", "line"])==-1) {
						message += "<span class=\" bold \">"+key+"<\span>: "+edge[key]+"<br>";
					}
				});
				if (edge) {
					showToolTipBox(d3.event, message);
				} else {
					showToolTipBox(d3.event, "<span class=\" bold \">type</span>: graph connecting edge")
				}
			}).on("mouseout", function () {
				d3.select(this).select("path").style("stroke-width", "1.5px");
				hideToolTipBox();
			});
		d3.selectAll(".arg-split-edge")
			.on("mouseover", function (d) {
				d3.select(this).select("path").style("stroke-width", "3px");
				showToolTipBox(d3.event, "<span class=\" bold \">type</span>: place holder <br> <span class=\" bold \">dblclick</span>: jump to Original edge");
			}).on("mouseout", function () {
				d3.select(this).select("path").style("stroke-width", "1.5px");
				hideToolTipBox();
			}).on("dblclick", function () {
				var edgeSourceTarget = d3.select(this).attr("id").split("_")[1];
				if (!d3.select(".marked-arg-edge").empty()) {
					d3.select(".marked-arg-edge").classed("marked-arg-edge", false);
				}
				var selection = d3.select("#arg-edge" + edgeSourceTarget.split("-")[0] + edgeSourceTarget.split("-")[1]);
				selection.classed("marked-arg-edge", true);
				var boundingRect = selection.node().getBoundingClientRect();
				$("#arg-container").scrollTop(boundingRect.top + $("#arg-container").scrollTop() - 300).scrollLeft(boundingRect.left + $("#arg-container").scrollLeft() - $("#errorpath_section").width() - 2 * boundingRect.width);
			});
	}

	// Use D3 zoom behavior to add pan event
	function addPanEvent(itemsToSelect) {
		d3.selectAll(itemsToSelect).each(function (d, i) {
			var svg = d3.select(this),
				svgGroup = d3.select(this.firstChild);
			var zoom = d3.zoom().on("zoom", function () {
				svgGroup.attr("transform", d3.event.transform)
			});
			svg.call(zoom);
			svg.on("zoom", null).on("wheel.zoom", null).on("dblclick.zoom", null).on("touchstart.zoom", null);
		});
	}

	// On mouse over display tool tip box
	function showToolTipBox(e, displayInfo) {
		var offsetX = 20;
		var offsetY = 0;
		var positionX = e.pageX;
		var positionY = e.pageY;
		d3.select("#boxContent").html("<p>" + displayInfo + "</p>");
		d3.select("#infoBox").style("left", function () {
			return positionX + offsetX + "px";
		}).style("top", function () {
			return positionY + offsetY + "px";
		}).style("visibility", "visible");
	}

	// On mouse out hide the tool tip box
	function hideToolTipBox() {
		d3.select("#infoBox").style("visibility", "hidden");
	}

}
  </script>
</head>

<body ng-controller="ReportController" id="report-controller" onload="init()">
  <header class="header">
    <a href="https://cpachecker.sosy-lab.org/">
      <img class="logo" ng-src="{{logo}}" />
    </a>
    <h1>
      Report for
test/bs2.i (Counterexample 2)    </h1>
    <span class="badge badge-info generated">
Generated on 2021-07-08 17:39:39 by CPAchecker 2.0.1-svn / predicateAnalysis-faultlocalization-maxsat    </span>
  </header>

  <div class="modal fade" id="renderStateModal" role="dialog" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h4 class="modal-title text-center">Graphs Rendering Progress</h4>
        </div>
        <div class="modal-body">
          <p class="loader">Rendered CFA graphs : &nbsp;
            <span id="cfa-modal"></span>
          </p>
          <p class="loader">Rendered ARG graphs : &nbsp;
            <span id="arg-modal"></span>
          </p>
          <p id="arg-modal-error" class="loader" style="display: none;"> Render ARG Error Graph </p>
        </div>
      </div>
    </div>
  </div>

  <div class="sections">

    <section id="errorpath_section" ng-controller="ErrorpathController">
      <header ng-controller="SearchController" class="text-center">
        <div class="btn-group" role="group" aria-label="Button group">
          <button class="btn btn-success" ng-click="errPathPrevClicked($event)" data-toggle="tooltip" data-placement="top" title="Click here to move on Previous Line">Prev</button>
          <button class="btn btn-warning" ng-click="errPathStartClicked()">Start</button>
          <button class="btn btn-success" ng-click="errPathNextClicked($event)" data-toggle="tooltip" data-placement="bottom" title="Click here to move on Next Line">Next</button>
        </div>
        <div class="help_button" data-toggle="tooltip" data-placement="top" title="Get help!">
          <a tabindex="0" role="button" data-container="body" data-toggle="popover" data-html="true" data-placement="right" data-trigger="focus"
            data-content="{{help_errorpath}}" class="btn btn-outline-info btn-lg help_button">
            <i class="fas fa-question-circle"></i>
          </a>
        </div>
        <div class="input-group input-group-sm">
          <input type="text" ng-keydown="checkIfEnter($event)" class="form-control search-input" placeholder="Search for...">
          <span class="input-group-btn">
            <button ng-click="searchFor()" class="btn btn-light" type="button">
              <i class="fas fa-search"></i>
            </button>
          </span>
        </div>
        <div id="searchOptions">
          <label for="optionExactMatch">
            <input id="optionExactMatch" type="checkbox" name="searchOption">
            <strong>Find only exact matches</strong>
          </label>
        </div>
        <!--shown iff property analysis.algorithm.FaultLocalization=true-->
        <div id="fault-localization-info" ng-hide="hideFaults" class="horizontal-div">
          <button id="fault-button" class="btn btn-success" ng-click="faultClicked()" data-toggle="tooltip" data-placement="bottom" title="Click here to get more detailed information about the error">Change view</button>
          <div class="help_button" data-toggle="tooltip" data-placement="top" title="Get help!">
            <a tabindex="0" role="button" data-container="body" data-toggle="popover" data-html="true" data-placement="bottom" data-trigger="focus"
               data-content="{{help_fault_localization}}" class="btn btn-outline-info btn-lg help_button">
              <i class="fas fa-question-circle"></i>
            </a>
          </div>
        </div>
        <div id="matches">
          <p class="markedValues">Matches in value-assignements (V): {{numOfValueMatches}}</p>
          <p class="markedDescriptions">Matches in edge-description: {{numOfDescriptionMatches}}</p>
        </div>
      </header>
      <div class="fileContent" ng-controller="ValueAssignmentsController" id="value-assignment">
        <table id="err-table" ng-hide="hideErrorTable">
          <tr id="errpath-header" ng-hide="hideFaults"> <td><pre></pre></td> <td><pre>Rank</pre></td> <td><pre>Scope</pre></td> </tr>
          <tr id="errpath-{{$index}}" ng-repeat="line in errorPath">
            <td ng-click="showValues($event)" data-toggle="popover" data-placement="right" data-trigger="click" data-content="{{line.valString}}">
              <pre>-V-</pre>
            </td>
	          <td ng-hide="hideFaults" class="rank" tabindex="0" data-trigger="focus" data-toggle="popover" data-placement="right" data-content="{{line.bestreason}}">
              <pre>{{line.bestrank}}</pre>
            </td>
            <td class="disabled" ng-click="clickedErrpathElement($event)">
              <pre class="make-pretty">{{line.desc}}</pre>
            </td>
          </tr>
        </table>
          <table class="fault-table" ng-show="hideErrorTable && hasPrecondition">
            <tr>
              <td class="fault-precond-header">
                Precondition (initial variable assignment):
              </td>
            </tr>
            <tr>
              <td>
                <p class="precondition">{{precondition}}</p>
              </td>
            </tr>
          </table>
          <table ng-show="hideErrorTable" ng-click="clickedFaultLocElement($event)" class="fault-table" ng-repeat="fault in faults" id="fault-{{$index}}">
            <tr>
              <td class="fault-rank" data-toggle="tooltip" data-placement="bottom" title="Rank">
                {{fault.rank}}.
              </td>
              <td class="fault-score" data-toggle="tooltip" data-placement="bottom" title="Score">
                {{fault.score}}
              </td>
              <td class="fault-details-header">
                Details:
              </td>
            </tr>
            <tr class="fault-details">
              <td colspan="3" html=true>
                
                <div ng-bind-html="htmlTrusted(fault.reason)"></div>

                <details>
                  <summary>
                    <strong>Current values:</strong>
                  </summary>
                  <table id="fault-values" class="value-table">
                    <tr><th>Name</th><th>Value</th></tr>
                    <tr ng-repeat="(variable,value) in fault.valDict">
                      <td ng-bind-html="htmlTrusted(variable)"></td>
                      <td ng-bind-html="htmlTrusted(value)"></td>
                    </tr>
                  </table>
                </details>

              </td>
            </tr>
          </table>
      </div>
    </section>

    <section id="externalFiles_section">

      <ul class="nav nav-pills nav-tabs">
        <li class="nav-item" id="toggle_button_error_path">
          <label class="switch" style="margin-top:5px" data-toggle="tooltip" data-placement="bottom" title="Toggle slider to show/hide error path section">
            <input type="checkbox" checked id="toggle_error_path" ng-click="toggleErrorPathSection($event)">
            <span class="slider round"></span>
          </label>
          <li class="nav-item" style="padding:10px;" id="toggle_button_error_path_placeholder">
            <span class="badge badge-warning" style="font-size: 1.1em" data-toggle="tooltip" data-placement="top" title="Toggle slider to show/hide error path section">Show Error Path Section</span>
          </li>
        </li>
        <li class="nav-item" ng-class="{active: tabIsSet(1)}" data-toggle="tooltip" data-placement="top" title="Shows CFA (Control flow Automation) of the Program">
          <a class="nav-link active" data-toggle="pill" href ng-click="setTab(1)" id="set-tab-1">CFA</a>
        </li>
        <li class="nav-item" ng-class="{active: tabIsSet(2)}" data-toggle="tooltip" data-placement="top" title="Shows ARG (Abstract Reachability Graph) of the Program">
          <a class="nav-link" data-toggle="pill" href ng-click="setTab(2)" id="set-tab-2">ARG</a>
        </li>
        <li class="nav-item" ng-class="{active: tabIsSet(3)}" data-toggle="tooltip" data-placement="top" title="Click here for source code of the program">
          <a class="nav-link" data-toggle="pill" href ng-click="setTab(3)" id="set-tab-3">Source</a>
        </li>
        <li class="nav-item" ng-class="{active: tabIsSet(4)}">
          <a class="nav-link" data-toggle="pill" href ng-click="setTab(4)">Log</a>
        </li>
        <li class="nav-item" ng-class="{active: tabIsSet(5)}">
          <a class="nav-link" data-toggle="pill" href ng-click="setTab(5)">Statistics</a>
        </li>
        <li class="nav-item" ng-class="{active: tabIsSet(6)}">
          <a class="nav-link" data-toggle="pill" href ng-click="setTab(6)">Configurations</a>
        </li>
        <div>
          <button id="full_screen_mode" class="btn btn-outline-info btn-lg help_button" ng-click="makeFullScreen()">
            <i class="fas fa-expand"></i> Full Screen Mode</button>
        </div>
        <div class="help_button" data-toggle="tooltip" data-placement="top" title="Get help!">
          <a tabindex="0" role="button" data-container="body" data-toggle="popover" data-html="true" data-placement="bottom" data-trigger="focus"
            data-content="{{help_content}}" class="btn btn-outline-info btn-lg help_button">
            <i class="fas fa-question-circle"></i>
          </a>
        </div>
      </ul>

      <div id="cfa-toolbar" ng-controller="CFAToolbarController">
        <nav class="navbar navbar-light bg-light">
          <div class="nav-item">
            <label>
              <strong>Displayed CFA</strong>
            </label>
            <select class="btn btn-outline-secondary selectpicker" ng-options="f as f for f in functions" ng-model="selectedCFAFunction"
              ng-change="setCFAFunction()">
            </select>
          </div>
          <div class="nav-item">
            <label>
              <strong>Mouse Wheel Zoom</strong>
            </label>
            <span class="button-checkbox">
              <button class="btn btn-outline-secondary" id="cfa-zoom-button" type="button" data-color="primary" ng-click="zoomControl()">
                <i class="far fa-square"></i>
              </button>
            </span>
          </div>
          <div class="nav-item">
            <label>
              <strong>Split Threshold</strong>
            </label>
            <input type="text" aria-label="Split Threshold" id="cfa-split-threshold">
            <button class="btn btn-outline-secondary" type="button" ng-click="redraw()" data-toggle="tooltip" data-placement="top" title="Refresh Split Threshold">
              <i class="fas fa-sync"></i>
            </button>
          </div>
          </ul>
        </nav>
      </div>

      <div id="arg-toolbar" ng-controller="ARGToolbarController">
        <nav class="navbar navbar-light bg-light">
          <div class="nav-item">
            <label>
              <strong>Displayed ARG</strong>
            </label>
            <select class="btn btn-outline-secondary selectpicker" ng-options="s as s for s in argSelections" ng-model="$root.displayedARG"
              ng-change="displayARG()"></select>
          </div>
          <div class="nav-item">
            <strong>Mouse Wheel Zoom</strong>
            </label>
            <span class="button-checkbox">
              <button class="btn btn-outline-secondary" id="arg-zoom-button" type="button" data-color="primary" ng-click="argZoomControl()">
                <i class="far fa-square"></i>
              </button>
            </span>
          </div>
          <div class="nav-item">
            <label>
              <strong>Split Threshold</strong>
            </label>
            <input type="text" aria-label="Split Threshold" id="arg-split-threshold">
            <button class="btn btn-outline-secondary" type="button" ng-click="argRedraw()" data-toggle="tooltip" data-placement="top"
              title="Refresh Split Threshold">
              <i class="fas fa-sync"></i>
            </button>
          </div>
        </nav>
      </div>

      <div id="cfa-container" ng-class="{active: tabIsSet(1)}">
      </div>

      <div id="arg-container" ng-class="{active: tabIsSet(2)}">
      </div>

      <div class="fileContent content" ng-show="tabIsSet(3)" ng-class="{active: tabIsSet(3)}" ng-controller="SourceController">
        <div class="edit-line">
          <div class="dropdown" id="dropdownMenu2">
            <button class="btn btn-outline-secondary dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">
              Displayed Sourcefile
              <span class="caret"></span>
            </button>
            <ul class="dropdown-menu pre-scrollable">
              <li ng-repeat="file in sourceFiles">
                <a ng-click="setSourceFile($index)">{{file}}</a>
              </li>
            </ul>
          </div>
          <label>
            <strong>{{sourceFiles[selectedSourceFile]}}</strong>
          </label>
        </div>
<div id="source-file" class="sourceContent" ng-show = "sourceFileIsSet(0)">
<table>
<tr id="source-1"><td><pre>1</pre></td><td><pre class="prettyprint">extern void abort(void);  </pre></td></tr>
<tr id="source-2"><td><pre>2</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-3"><td><pre>3</pre></td><td><pre class="prettyprint">extern void __assert_fail (const char *__assertion, const char *__file,  </pre></td></tr>
<tr id="source-4"><td><pre>4</pre></td><td><pre class="prettyprint">      unsigned int __line, const char *__function)  </pre></td></tr>
<tr id="source-5"><td><pre>5</pre></td><td><pre class="prettyprint">     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));  </pre></td></tr>
<tr id="source-6"><td><pre>6</pre></td><td><pre class="prettyprint">extern void __assert_perror_fail (int __errnum, const char *__file,  </pre></td></tr>
<tr id="source-7"><td><pre>7</pre></td><td><pre class="prettyprint">      unsigned int __line, const char *__function)  </pre></td></tr>
<tr id="source-8"><td><pre>8</pre></td><td><pre class="prettyprint">     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));  </pre></td></tr>
<tr id="source-9"><td><pre>9</pre></td><td><pre class="prettyprint">extern void __assert (const char *__assertion, const char *__file, int __line)  </pre></td></tr>
<tr id="source-10"><td><pre>10</pre></td><td><pre class="prettyprint">     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));  </pre></td></tr>
<tr id="source-11"><td><pre>11</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-12"><td><pre>12</pre></td><td><pre class="prettyprint">void reach_error() { ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (&quot;0&quot;, &quot;bubble_sort-2.c&quot;, 3, __extension__ __PRETTY_FUNCTION__); })); }  </pre></td></tr>
<tr id="source-13"><td><pre>13</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-14"><td><pre>14</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-15"><td><pre>15</pre></td><td><pre class="prettyprint">extern void __assert_fail (__const char *__assertion, __const char *__file,  </pre></td></tr>
<tr id="source-16"><td><pre>16</pre></td><td><pre class="prettyprint">      unsigned int __line, __const char *__function)  </pre></td></tr>
<tr id="source-17"><td><pre>17</pre></td><td><pre class="prettyprint">     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));  </pre></td></tr>
<tr id="source-18"><td><pre>18</pre></td><td><pre class="prettyprint">extern void __assert_perror_fail (int __errnum, __const char *__file,  </pre></td></tr>
<tr id="source-19"><td><pre>19</pre></td><td><pre class="prettyprint">      unsigned int __line,  </pre></td></tr>
<tr id="source-20"><td><pre>20</pre></td><td><pre class="prettyprint">      __const char *__function)  </pre></td></tr>
<tr id="source-21"><td><pre>21</pre></td><td><pre class="prettyprint">     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));  </pre></td></tr>
<tr id="source-22"><td><pre>22</pre></td><td><pre class="prettyprint">extern void __assert (const char *__assertion, const char *__file, int __line)  </pre></td></tr>
<tr id="source-23"><td><pre>23</pre></td><td><pre class="prettyprint">     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));  </pre></td></tr>
<tr id="source-24"><td><pre>24</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-25"><td><pre>25</pre></td><td><pre class="prettyprint">typedef unsigned int size_t;  </pre></td></tr>
<tr id="source-26"><td><pre>26</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-27"><td><pre>27</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-28"><td><pre>28</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-29"><td><pre>29</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-30"><td><pre>30</pre></td><td><pre class="prettyprint">struct list_head {  </pre></td></tr>
<tr id="source-31"><td><pre>31</pre></td><td><pre class="prettyprint">   struct list_head *next ;  </pre></td></tr>
<tr id="source-32"><td><pre>32</pre></td><td><pre class="prettyprint">   struct list_head *prev ;  </pre></td></tr>
<tr id="source-33"><td><pre>33</pre></td><td><pre class="prettyprint">};  </pre></td></tr>
<tr id="source-34"><td><pre>34</pre></td><td><pre class="prettyprint">struct node {  </pre></td></tr>
<tr id="source-35"><td><pre>35</pre></td><td><pre class="prettyprint">   int value ;  </pre></td></tr>
<tr id="source-36"><td><pre>36</pre></td><td><pre class="prettyprint">   struct list_head linkage ;  </pre></td></tr>
<tr id="source-37"><td><pre>37</pre></td><td><pre class="prettyprint">   struct list_head nested ;  </pre></td></tr>
<tr id="source-38"><td><pre>38</pre></td><td><pre class="prettyprint">};  </pre></td></tr>
<tr id="source-39"><td><pre>39</pre></td><td><pre class="prettyprint">extern __attribute__((__nothrow__)) void *malloc(size_t __size ) __attribute__((__malloc__)) ;  </pre></td></tr>
<tr id="source-40"><td><pre>40</pre></td><td><pre class="prettyprint">extern __attribute__((__nothrow__)) void free(void *__ptr ) ;  </pre></td></tr>
<tr id="source-41"><td><pre>41</pre></td><td><pre class="prettyprint">extern __attribute__((__nothrow__, __noreturn__)) void abort(void) ;  </pre></td></tr>
<tr id="source-42"><td><pre>42</pre></td><td><pre class="prettyprint">extern int __VERIFIER_nondet_int(void);  </pre></td></tr>
<tr id="source-43"><td><pre>43</pre></td><td><pre class="prettyprint">static void fail(void)  </pre></td></tr>
<tr id="source-44"><td><pre>44</pre></td><td><pre class="prettyprint">{  </pre></td></tr>
<tr id="source-45"><td><pre>45</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-46"><td><pre>46</pre></td><td><pre class="prettyprint">  ERROR: {reach_error();abort();}((0) ? (void) (0) : __assert_fail (&quot;0&quot;, &quot;test-0180.c&quot;, 11, __PRETTY_FUNCTION__));  </pre></td></tr>
<tr id="source-47"><td><pre>47</pre></td><td><pre class="prettyprint">  goto ERROR;  </pre></td></tr>
<tr id="source-48"><td><pre>48</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-49"><td><pre>49</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-50"><td><pre>50</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-51"><td><pre>51</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-52"><td><pre>52</pre></td><td><pre class="prettyprint">struct list_head gl_list = {&amp; gl_list, &amp; gl_list};  </pre></td></tr>
<tr id="source-53"><td><pre>53</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-54"><td><pre>54</pre></td><td><pre class="prettyprint">static void inspect(struct list_head const *head )  </pre></td></tr>
<tr id="source-55"><td><pre>55</pre></td><td><pre class="prettyprint">{ struct node const *node ;  </pre></td></tr>
<tr id="source-56"><td><pre>56</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp3 ;  </pre></td></tr>
<tr id="source-57"><td><pre>57</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp4 ;  </pre></td></tr>
<tr id="source-58"><td><pre>58</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp5 ;  </pre></td></tr>
<tr id="source-59"><td><pre>59</pre></td><td><pre class="prettyprint">  int __cil_tmp6 ;  </pre></td></tr>
<tr id="source-60"><td><pre>60</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp7 ;  </pre></td></tr>
<tr id="source-61"><td><pre>61</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp8 ;  </pre></td></tr>
<tr id="source-62"><td><pre>62</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp9 ;  </pre></td></tr>
<tr id="source-63"><td><pre>63</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp10 ;  </pre></td></tr>
<tr id="source-64"><td><pre>64</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp11 ;  </pre></td></tr>
<tr id="source-65"><td><pre>65</pre></td><td><pre class="prettyprint">  int __cil_tmp12 ;  </pre></td></tr>
<tr id="source-66"><td><pre>66</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp13 ;  </pre></td></tr>
<tr id="source-67"><td><pre>67</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp14 ;  </pre></td></tr>
<tr id="source-68"><td><pre>68</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp15 ;  </pre></td></tr>
<tr id="source-69"><td><pre>69</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp16 ;  </pre></td></tr>
<tr id="source-70"><td><pre>70</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp17 ;  </pre></td></tr>
<tr id="source-71"><td><pre>71</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp18 ;  </pre></td></tr>
<tr id="source-72"><td><pre>72</pre></td><td><pre class="prettyprint">  int __cil_tmp19 ;  </pre></td></tr>
<tr id="source-73"><td><pre>73</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp20 ;  </pre></td></tr>
<tr id="source-74"><td><pre>74</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp21 ;  </pre></td></tr>
<tr id="source-75"><td><pre>75</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp22 ;  </pre></td></tr>
<tr id="source-76"><td><pre>76</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp23 ;  </pre></td></tr>
<tr id="source-77"><td><pre>77</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp24 ;  </pre></td></tr>
<tr id="source-78"><td><pre>78</pre></td><td><pre class="prettyprint">  int __cil_tmp25 ;  </pre></td></tr>
<tr id="source-79"><td><pre>79</pre></td><td><pre class="prettyprint">  struct node *__cil_tmp26 ;  </pre></td></tr>
<tr id="source-80"><td><pre>80</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp27 ;  </pre></td></tr>
<tr id="source-81"><td><pre>81</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp28 ;  </pre></td></tr>
<tr id="source-82"><td><pre>82</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp29 ;  </pre></td></tr>
<tr id="source-83"><td><pre>83</pre></td><td><pre class="prettyprint">  unsigned long __cil_tmp30 ;  </pre></td></tr>
<tr id="source-84"><td><pre>84</pre></td><td><pre class="prettyprint">  char *__cil_tmp31 ;  </pre></td></tr>
<tr id="source-85"><td><pre>85</pre></td><td><pre class="prettyprint">  char *__cil_tmp32 ;  </pre></td></tr>
<tr id="source-86"><td><pre>86</pre></td><td><pre class="prettyprint">  struct node *__cil_tmp33 ;  </pre></td></tr>
<tr id="source-87"><td><pre>87</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp34 ;  </pre></td></tr>
<tr id="source-88"><td><pre>88</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp35 ;  </pre></td></tr>
<tr id="source-89"><td><pre>89</pre></td><td><pre class="prettyprint">  struct list_head const *__cil_tmp36 ;  </pre></td></tr>
<tr id="source-90"><td><pre>90</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp37 ;  </pre></td></tr>
<tr id="source-91"><td><pre>91</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp38 ;  </pre></td></tr>
<tr id="source-92"><td><pre>92</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp39 ;  </pre></td></tr>
<tr id="source-93"><td><pre>93</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp40 ;  </pre></td></tr>
<tr id="source-94"><td><pre>94</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp41 ;  </pre></td></tr>
<tr id="source-95"><td><pre>95</pre></td><td><pre class="prettyprint">  int __cil_tmp42 ;  </pre></td></tr>
<tr id="source-96"><td><pre>96</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp43 ;  </pre></td></tr>
<tr id="source-97"><td><pre>97</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp44 ;  </pre></td></tr>
<tr id="source-98"><td><pre>98</pre></td><td><pre class="prettyprint">  struct list_head const *__cil_tmp45 ;  </pre></td></tr>
<tr id="source-99"><td><pre>99</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp46 ;  </pre></td></tr>
<tr id="source-100"><td><pre>100</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp47 ;  </pre></td></tr>
<tr id="source-101"><td><pre>101</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp48 ;  </pre></td></tr>
<tr id="source-102"><td><pre>102</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp49 ;  </pre></td></tr>
<tr id="source-103"><td><pre>103</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp50 ;  </pre></td></tr>
<tr id="source-104"><td><pre>104</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp51 ;  </pre></td></tr>
<tr id="source-105"><td><pre>105</pre></td><td><pre class="prettyprint">  int __cil_tmp52 ;  </pre></td></tr>
<tr id="source-106"><td><pre>106</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp53 ;  </pre></td></tr>
<tr id="source-107"><td><pre>107</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp54 ;  </pre></td></tr>
<tr id="source-108"><td><pre>108</pre></td><td><pre class="prettyprint">  struct list_head const *__cil_tmp55 ;  </pre></td></tr>
<tr id="source-109"><td><pre>109</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp56 ;  </pre></td></tr>
<tr id="source-110"><td><pre>110</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp57 ;  </pre></td></tr>
<tr id="source-111"><td><pre>111</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp58 ;  </pre></td></tr>
<tr id="source-112"><td><pre>112</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp59 ;  </pre></td></tr>
<tr id="source-113"><td><pre>113</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp60 ;  </pre></td></tr>
<tr id="source-114"><td><pre>114</pre></td><td><pre class="prettyprint">  int __cil_tmp61 ;  </pre></td></tr>
<tr id="source-115"><td><pre>115</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp62 ;  </pre></td></tr>
<tr id="source-116"><td><pre>116</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp63 ;  </pre></td></tr>
<tr id="source-117"><td><pre>117</pre></td><td><pre class="prettyprint">  struct list_head const *__cil_tmp64 ;  </pre></td></tr>
<tr id="source-118"><td><pre>118</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp65 ;  </pre></td></tr>
<tr id="source-119"><td><pre>119</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp66 ;  </pre></td></tr>
<tr id="source-120"><td><pre>120</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp67 ;  </pre></td></tr>
<tr id="source-121"><td><pre>121</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp68 ;  </pre></td></tr>
<tr id="source-122"><td><pre>122</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp69 ;  </pre></td></tr>
<tr id="source-123"><td><pre>123</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp70 ;  </pre></td></tr>
<tr id="source-124"><td><pre>124</pre></td><td><pre class="prettyprint">  int __cil_tmp71 ;  </pre></td></tr>
<tr id="source-125"><td><pre>125</pre></td><td><pre class="prettyprint">  struct node const *__cil_tmp72 ;  </pre></td></tr>
<tr id="source-126"><td><pre>126</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp73 ;  </pre></td></tr>
<tr id="source-127"><td><pre>127</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp74 ;  </pre></td></tr>
<tr id="source-128"><td><pre>128</pre></td><td><pre class="prettyprint">  int __cil_tmp75 ;  </pre></td></tr>
<tr id="source-129"><td><pre>129</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp76 ;  </pre></td></tr>
<tr id="source-130"><td><pre>130</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp77 ;  </pre></td></tr>
<tr id="source-131"><td><pre>131</pre></td><td><pre class="prettyprint">  struct list_head const *__cil_tmp78 ;  </pre></td></tr>
<tr id="source-132"><td><pre>132</pre></td><td><pre class="prettyprint">  struct node const *__cil_tmp79 ;  </pre></td></tr>
<tr id="source-133"><td><pre>133</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp80 ;  </pre></td></tr>
<tr id="source-134"><td><pre>134</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp81 ;  </pre></td></tr>
<tr id="source-135"><td><pre>135</pre></td><td><pre class="prettyprint">  int __cil_tmp82 ;  </pre></td></tr>
<tr id="source-136"><td><pre>136</pre></td><td><pre class="prettyprint">  int const *__cil_tmp83 ;  </pre></td></tr>
<tr id="source-137"><td><pre>137</pre></td><td><pre class="prettyprint">  struct node const *__cil_tmp84 ;  </pre></td></tr>
<tr id="source-138"><td><pre>138</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp85 ;  </pre></td></tr>
<tr id="source-139"><td><pre>139</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp86 ;  </pre></td></tr>
<tr id="source-140"><td><pre>140</pre></td><td><pre class="prettyprint">  int __cil_tmp87 ;  </pre></td></tr>
<tr id="source-141"><td><pre>141</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp88 ;  </pre></td></tr>
<tr id="source-142"><td><pre>142</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp89 ;  </pre></td></tr>
<tr id="source-143"><td><pre>143</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp90 ;  </pre></td></tr>
<tr id="source-144"><td><pre>144</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp91 ;  </pre></td></tr>
<tr id="source-145"><td><pre>145</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp92 ;  </pre></td></tr>
<tr id="source-146"><td><pre>146</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp93 ;  </pre></td></tr>
<tr id="source-147"><td><pre>147</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp94 ;  </pre></td></tr>
<tr id="source-148"><td><pre>148</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp95 ;  </pre></td></tr>
<tr id="source-149"><td><pre>149</pre></td><td><pre class="prettyprint">  int __cil_tmp96 ;  </pre></td></tr>
<tr id="source-150"><td><pre>150</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp97 ;  </pre></td></tr>
<tr id="source-151"><td><pre>151</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp98 ;  </pre></td></tr>
<tr id="source-152"><td><pre>152</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp99 ;  </pre></td></tr>
<tr id="source-153"><td><pre>153</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp100 ;  </pre></td></tr>
<tr id="source-154"><td><pre>154</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp101 ;  </pre></td></tr>
<tr id="source-155"><td><pre>155</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp102 ;  </pre></td></tr>
<tr id="source-156"><td><pre>156</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp103 ;  </pre></td></tr>
<tr id="source-157"><td><pre>157</pre></td><td><pre class="prettyprint">  int __cil_tmp104 ;  </pre></td></tr>
<tr id="source-158"><td><pre>158</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp105 ;  </pre></td></tr>
<tr id="source-159"><td><pre>159</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp106 ;  </pre></td></tr>
<tr id="source-160"><td><pre>160</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp107 ;  </pre></td></tr>
<tr id="source-161"><td><pre>161</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp108 ;  </pre></td></tr>
<tr id="source-162"><td><pre>162</pre></td><td><pre class="prettyprint">  struct list_head const *__cil_tmp109 ;  </pre></td></tr>
<tr id="source-163"><td><pre>163</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp110 ;  </pre></td></tr>
<tr id="source-164"><td><pre>164</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp111 ;  </pre></td></tr>
<tr id="source-165"><td><pre>165</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp112 ;  </pre></td></tr>
<tr id="source-166"><td><pre>166</pre></td><td><pre class="prettyprint">  struct node *__cil_tmp113 ;  </pre></td></tr>
<tr id="source-167"><td><pre>167</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp114 ;  </pre></td></tr>
<tr id="source-168"><td><pre>168</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp115 ;  </pre></td></tr>
<tr id="source-169"><td><pre>169</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp116 ;  </pre></td></tr>
<tr id="source-170"><td><pre>170</pre></td><td><pre class="prettyprint">  unsigned long __cil_tmp117 ;  </pre></td></tr>
<tr id="source-171"><td><pre>171</pre></td><td><pre class="prettyprint">  char *__cil_tmp118 ;  </pre></td></tr>
<tr id="source-172"><td><pre>172</pre></td><td><pre class="prettyprint">  char *__cil_tmp119 ;  </pre></td></tr>
<tr id="source-173"><td><pre>173</pre></td><td><pre class="prettyprint">  struct node *__cil_tmp120 ;  </pre></td></tr>
<tr id="source-174"><td><pre>174</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp121 ;  </pre></td></tr>
<tr id="source-175"><td><pre>175</pre></td><td><pre class="prettyprint">  int __cil_tmp122 ;  </pre></td></tr>
<tr id="source-176"><td><pre>176</pre></td><td><pre class="prettyprint">  </pre></td></tr>
<tr id="source-177"><td><pre>177</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-178"><td><pre>178</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-179"><td><pre>179</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-180"><td><pre>180</pre></td><td><pre class="prettyprint">    while_0_continue: ;  </pre></td></tr>
<tr id="source-181"><td><pre>181</pre></td><td><pre class="prettyprint">    if (! head) {  </pre></td></tr>
<tr id="source-182"><td><pre>182</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-183"><td><pre>183</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-184"><td><pre>184</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-185"><td><pre>185</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-186"><td><pre>186</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-187"><td><pre>187</pre></td><td><pre class="prettyprint">    goto while_0_break;  </pre></td></tr>
<tr id="source-188"><td><pre>188</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-189"><td><pre>189</pre></td><td><pre class="prettyprint">  while_0_break: ;  </pre></td></tr>
<tr id="source-190"><td><pre>190</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-191"><td><pre>191</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-192"><td><pre>192</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-193"><td><pre>193</pre></td><td><pre class="prettyprint">    while_1_continue: ;  </pre></td></tr>
<tr id="source-194"><td><pre>194</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-195"><td><pre>195</pre></td><td><pre class="prettyprint">    __cil_tmp3 = (unsigned int )head;  </pre></td></tr>
<tr id="source-196"><td><pre>196</pre></td><td><pre class="prettyprint">    __cil_tmp4 = *((struct list_head * const *)head);  </pre></td></tr>
<tr id="source-197"><td><pre>197</pre></td><td><pre class="prettyprint">    __cil_tmp5 = (unsigned int )__cil_tmp4;  </pre></td></tr>
<tr id="source-198"><td><pre>198</pre></td><td><pre class="prettyprint">    __cil_tmp6 = __cil_tmp5 != __cil_tmp3;  </pre></td></tr>
<tr id="source-199"><td><pre>199</pre></td><td><pre class="prettyprint">    if (! __cil_tmp6) {  </pre></td></tr>
<tr id="source-200"><td><pre>200</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-201"><td><pre>201</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-202"><td><pre>202</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-203"><td><pre>203</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-204"><td><pre>204</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-205"><td><pre>205</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-206"><td><pre>206</pre></td><td><pre class="prettyprint">    goto while_1_break;  </pre></td></tr>
<tr id="source-207"><td><pre>207</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-208"><td><pre>208</pre></td><td><pre class="prettyprint">  while_1_break: ;  </pre></td></tr>
<tr id="source-209"><td><pre>209</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-210"><td><pre>210</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-211"><td><pre>211</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-212"><td><pre>212</pre></td><td><pre class="prettyprint">    while_2_continue: ;  </pre></td></tr>
<tr id="source-213"><td><pre>213</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-214"><td><pre>214</pre></td><td><pre class="prettyprint">    __cil_tmp7 = (unsigned int )head;  </pre></td></tr>
<tr id="source-215"><td><pre>215</pre></td><td><pre class="prettyprint">    __cil_tmp8 = (unsigned int )head;  </pre></td></tr>
<tr id="source-216"><td><pre>216</pre></td><td><pre class="prettyprint">    __cil_tmp9 = __cil_tmp8 + 4;  </pre></td></tr>
<tr id="source-217"><td><pre>217</pre></td><td><pre class="prettyprint">    __cil_tmp10 = *((struct list_head * const *)__cil_tmp9);  </pre></td></tr>
<tr id="source-218"><td><pre>218</pre></td><td><pre class="prettyprint">    __cil_tmp11 = (unsigned int )__cil_tmp10;  </pre></td></tr>
<tr id="source-219"><td><pre>219</pre></td><td><pre class="prettyprint">    __cil_tmp12 = __cil_tmp11 != __cil_tmp7;  </pre></td></tr>
<tr id="source-220"><td><pre>220</pre></td><td><pre class="prettyprint">    if (! __cil_tmp12) {  </pre></td></tr>
<tr id="source-221"><td><pre>221</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-222"><td><pre>222</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-223"><td><pre>223</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-224"><td><pre>224</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-225"><td><pre>225</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-226"><td><pre>226</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-227"><td><pre>227</pre></td><td><pre class="prettyprint">    goto while_2_break;  </pre></td></tr>
<tr id="source-228"><td><pre>228</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-229"><td><pre>229</pre></td><td><pre class="prettyprint">  while_2_break: ;  </pre></td></tr>
<tr id="source-230"><td><pre>230</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-231"><td><pre>231</pre></td><td><pre class="prettyprint">  __cil_tmp13 = (unsigned int )head;  </pre></td></tr>
<tr id="source-232"><td><pre>232</pre></td><td><pre class="prettyprint">  __cil_tmp14 = __cil_tmp13 + 4;  </pre></td></tr>
<tr id="source-233"><td><pre>233</pre></td><td><pre class="prettyprint">  __cil_tmp15 = *((struct list_head * const *)__cil_tmp14);  </pre></td></tr>
<tr id="source-234"><td><pre>234</pre></td><td><pre class="prettyprint">  head = (struct list_head const *)__cil_tmp15;  </pre></td></tr>
<tr id="source-235"><td><pre>235</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-236"><td><pre>236</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-237"><td><pre>237</pre></td><td><pre class="prettyprint">    while_3_continue: ;  </pre></td></tr>
<tr id="source-238"><td><pre>238</pre></td><td><pre class="prettyprint">    if (! head) {  </pre></td></tr>
<tr id="source-239"><td><pre>239</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-240"><td><pre>240</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-241"><td><pre>241</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-242"><td><pre>242</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-243"><td><pre>243</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-244"><td><pre>244</pre></td><td><pre class="prettyprint">    goto while_3_break;  </pre></td></tr>
<tr id="source-245"><td><pre>245</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-246"><td><pre>246</pre></td><td><pre class="prettyprint">  while_3_break: ;  </pre></td></tr>
<tr id="source-247"><td><pre>247</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-248"><td><pre>248</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-249"><td><pre>249</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-250"><td><pre>250</pre></td><td><pre class="prettyprint">    while_4_continue: ;  </pre></td></tr>
<tr id="source-251"><td><pre>251</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-252"><td><pre>252</pre></td><td><pre class="prettyprint">    __cil_tmp16 = (unsigned int )head;  </pre></td></tr>
<tr id="source-253"><td><pre>253</pre></td><td><pre class="prettyprint">    __cil_tmp17 = *((struct list_head * const *)head);  </pre></td></tr>
<tr id="source-254"><td><pre>254</pre></td><td><pre class="prettyprint">    __cil_tmp18 = (unsigned int )__cil_tmp17;  </pre></td></tr>
<tr id="source-255"><td><pre>255</pre></td><td><pre class="prettyprint">    __cil_tmp19 = __cil_tmp18 != __cil_tmp16;  </pre></td></tr>
<tr id="source-256"><td><pre>256</pre></td><td><pre class="prettyprint">    if (! __cil_tmp19) {  </pre></td></tr>
<tr id="source-257"><td><pre>257</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-258"><td><pre>258</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-259"><td><pre>259</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-260"><td><pre>260</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-261"><td><pre>261</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-262"><td><pre>262</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-263"><td><pre>263</pre></td><td><pre class="prettyprint">    goto while_4_break;  </pre></td></tr>
<tr id="source-264"><td><pre>264</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-265"><td><pre>265</pre></td><td><pre class="prettyprint">  while_4_break: ;  </pre></td></tr>
<tr id="source-266"><td><pre>266</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-267"><td><pre>267</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-268"><td><pre>268</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-269"><td><pre>269</pre></td><td><pre class="prettyprint">    while_5_continue: ;  </pre></td></tr>
<tr id="source-270"><td><pre>270</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-271"><td><pre>271</pre></td><td><pre class="prettyprint">    __cil_tmp20 = (unsigned int )head;  </pre></td></tr>
<tr id="source-272"><td><pre>272</pre></td><td><pre class="prettyprint">    __cil_tmp21 = (unsigned int )head;  </pre></td></tr>
<tr id="source-273"><td><pre>273</pre></td><td><pre class="prettyprint">    __cil_tmp22 = __cil_tmp21 + 4;  </pre></td></tr>
<tr id="source-274"><td><pre>274</pre></td><td><pre class="prettyprint">    __cil_tmp23 = *((struct list_head * const *)__cil_tmp22);  </pre></td></tr>
<tr id="source-275"><td><pre>275</pre></td><td><pre class="prettyprint">    __cil_tmp24 = (unsigned int )__cil_tmp23;  </pre></td></tr>
<tr id="source-276"><td><pre>276</pre></td><td><pre class="prettyprint">    __cil_tmp25 = __cil_tmp24 != __cil_tmp20;  </pre></td></tr>
<tr id="source-277"><td><pre>277</pre></td><td><pre class="prettyprint">    if (! __cil_tmp25) {  </pre></td></tr>
<tr id="source-278"><td><pre>278</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-279"><td><pre>279</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-280"><td><pre>280</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-281"><td><pre>281</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-282"><td><pre>282</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-283"><td><pre>283</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-284"><td><pre>284</pre></td><td><pre class="prettyprint">    goto while_5_break;  </pre></td></tr>
<tr id="source-285"><td><pre>285</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-286"><td><pre>286</pre></td><td><pre class="prettyprint">  while_5_break: ;  </pre></td></tr>
<tr id="source-287"><td><pre>287</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-288"><td><pre>288</pre></td><td><pre class="prettyprint">  __cil_tmp26 = (struct node *)0;  </pre></td></tr>
<tr id="source-289"><td><pre>289</pre></td><td><pre class="prettyprint">  __cil_tmp27 = (unsigned int )__cil_tmp26;  </pre></td></tr>
<tr id="source-290"><td><pre>290</pre></td><td><pre class="prettyprint">  __cil_tmp28 = __cil_tmp27 + 4;  </pre></td></tr>
<tr id="source-291"><td><pre>291</pre></td><td><pre class="prettyprint">  __cil_tmp29 = (struct list_head *)__cil_tmp28;  </pre></td></tr>
<tr id="source-292"><td><pre>292</pre></td><td><pre class="prettyprint">  __cil_tmp30 = (unsigned long )__cil_tmp29;  </pre></td></tr>
<tr id="source-293"><td><pre>293</pre></td><td><pre class="prettyprint">  __cil_tmp31 = (char *)head;  </pre></td></tr>
<tr id="source-294"><td><pre>294</pre></td><td><pre class="prettyprint">  __cil_tmp32 = __cil_tmp31 - __cil_tmp30;  </pre></td></tr>
<tr id="source-295"><td><pre>295</pre></td><td><pre class="prettyprint">  __cil_tmp33 = (struct node *)__cil_tmp32;  </pre></td></tr>
<tr id="source-296"><td><pre>296</pre></td><td><pre class="prettyprint">  node = (struct node const *)__cil_tmp33;  </pre></td></tr>
<tr id="source-297"><td><pre>297</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-298"><td><pre>298</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-299"><td><pre>299</pre></td><td><pre class="prettyprint">    while_6_continue: ;  </pre></td></tr>
<tr id="source-300"><td><pre>300</pre></td><td><pre class="prettyprint">    if (! node) {  </pre></td></tr>
<tr id="source-301"><td><pre>301</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-302"><td><pre>302</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-303"><td><pre>303</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-304"><td><pre>304</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-305"><td><pre>305</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-306"><td><pre>306</pre></td><td><pre class="prettyprint">    goto while_6_break;  </pre></td></tr>
<tr id="source-307"><td><pre>307</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-308"><td><pre>308</pre></td><td><pre class="prettyprint">  while_6_break: ;  </pre></td></tr>
<tr id="source-309"><td><pre>309</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-310"><td><pre>310</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-311"><td><pre>311</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-312"><td><pre>312</pre></td><td><pre class="prettyprint">    while_7_continue: ;  </pre></td></tr>
<tr id="source-313"><td><pre>313</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-314"><td><pre>314</pre></td><td><pre class="prettyprint">    __cil_tmp34 = (unsigned int )node;  </pre></td></tr>
<tr id="source-315"><td><pre>315</pre></td><td><pre class="prettyprint">    __cil_tmp35 = __cil_tmp34 + 12;  </pre></td></tr>
<tr id="source-316"><td><pre>316</pre></td><td><pre class="prettyprint">    __cil_tmp36 = (struct list_head const *)__cil_tmp35;  </pre></td></tr>
<tr id="source-317"><td><pre>317</pre></td><td><pre class="prettyprint">    __cil_tmp37 = (unsigned int )__cil_tmp36;  </pre></td></tr>
<tr id="source-318"><td><pre>318</pre></td><td><pre class="prettyprint">    __cil_tmp38 = (unsigned int )node;  </pre></td></tr>
<tr id="source-319"><td><pre>319</pre></td><td><pre class="prettyprint">    __cil_tmp39 = __cil_tmp38 + 12;  </pre></td></tr>
<tr id="source-320"><td><pre>320</pre></td><td><pre class="prettyprint">    __cil_tmp40 = *((struct list_head * const *)__cil_tmp39);  </pre></td></tr>
<tr id="source-321"><td><pre>321</pre></td><td><pre class="prettyprint">    __cil_tmp41 = (unsigned int )__cil_tmp40;  </pre></td></tr>
<tr id="source-322"><td><pre>322</pre></td><td><pre class="prettyprint">    __cil_tmp42 = __cil_tmp41 == __cil_tmp37;  </pre></td></tr>
<tr id="source-323"><td><pre>323</pre></td><td><pre class="prettyprint">    if (! __cil_tmp42) {  </pre></td></tr>
<tr id="source-324"><td><pre>324</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-325"><td><pre>325</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-326"><td><pre>326</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-327"><td><pre>327</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-328"><td><pre>328</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-329"><td><pre>329</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-330"><td><pre>330</pre></td><td><pre class="prettyprint">    goto while_7_break;  </pre></td></tr>
<tr id="source-331"><td><pre>331</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-332"><td><pre>332</pre></td><td><pre class="prettyprint">  while_7_break: ;  </pre></td></tr>
<tr id="source-333"><td><pre>333</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-334"><td><pre>334</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-335"><td><pre>335</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-336"><td><pre>336</pre></td><td><pre class="prettyprint">    while_8_continue: ;  </pre></td></tr>
<tr id="source-337"><td><pre>337</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-338"><td><pre>338</pre></td><td><pre class="prettyprint">    __cil_tmp43 = (unsigned int )node;  </pre></td></tr>
<tr id="source-339"><td><pre>339</pre></td><td><pre class="prettyprint">    __cil_tmp44 = __cil_tmp43 + 12;  </pre></td></tr>
<tr id="source-340"><td><pre>340</pre></td><td><pre class="prettyprint">    __cil_tmp45 = (struct list_head const *)__cil_tmp44;  </pre></td></tr>
<tr id="source-341"><td><pre>341</pre></td><td><pre class="prettyprint">    __cil_tmp46 = (unsigned int )__cil_tmp45;  </pre></td></tr>
<tr id="source-342"><td><pre>342</pre></td><td><pre class="prettyprint">    __cil_tmp47 = 12 + 4;  </pre></td></tr>
<tr id="source-343"><td><pre>343</pre></td><td><pre class="prettyprint">    __cil_tmp48 = (unsigned int )node;  </pre></td></tr>
<tr id="source-344"><td><pre>344</pre></td><td><pre class="prettyprint">    __cil_tmp49 = __cil_tmp48 + __cil_tmp47;  </pre></td></tr>
<tr id="source-345"><td><pre>345</pre></td><td><pre class="prettyprint">    __cil_tmp50 = *((struct list_head * const *)__cil_tmp49);  </pre></td></tr>
<tr id="source-346"><td><pre>346</pre></td><td><pre class="prettyprint">    __cil_tmp51 = (unsigned int )__cil_tmp50;  </pre></td></tr>
<tr id="source-347"><td><pre>347</pre></td><td><pre class="prettyprint">    __cil_tmp52 = __cil_tmp51 == __cil_tmp46;  </pre></td></tr>
<tr id="source-348"><td><pre>348</pre></td><td><pre class="prettyprint">    if (! __cil_tmp52) {  </pre></td></tr>
<tr id="source-349"><td><pre>349</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-350"><td><pre>350</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-351"><td><pre>351</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-352"><td><pre>352</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-353"><td><pre>353</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-354"><td><pre>354</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-355"><td><pre>355</pre></td><td><pre class="prettyprint">    goto while_8_break;  </pre></td></tr>
<tr id="source-356"><td><pre>356</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-357"><td><pre>357</pre></td><td><pre class="prettyprint">  while_8_break: ;  </pre></td></tr>
<tr id="source-358"><td><pre>358</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-359"><td><pre>359</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-360"><td><pre>360</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-361"><td><pre>361</pre></td><td><pre class="prettyprint">    while_9_continue: ;  </pre></td></tr>
<tr id="source-362"><td><pre>362</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-363"><td><pre>363</pre></td><td><pre class="prettyprint">    __cil_tmp53 = (unsigned int )node;  </pre></td></tr>
<tr id="source-364"><td><pre>364</pre></td><td><pre class="prettyprint">    __cil_tmp54 = __cil_tmp53 + 4;  </pre></td></tr>
<tr id="source-365"><td><pre>365</pre></td><td><pre class="prettyprint">    __cil_tmp55 = (struct list_head const *)__cil_tmp54;  </pre></td></tr>
<tr id="source-366"><td><pre>366</pre></td><td><pre class="prettyprint">    __cil_tmp56 = (unsigned int )__cil_tmp55;  </pre></td></tr>
<tr id="source-367"><td><pre>367</pre></td><td><pre class="prettyprint">    __cil_tmp57 = (unsigned int )node;  </pre></td></tr>
<tr id="source-368"><td><pre>368</pre></td><td><pre class="prettyprint">    __cil_tmp58 = __cil_tmp57 + 12;  </pre></td></tr>
<tr id="source-369"><td><pre>369</pre></td><td><pre class="prettyprint">    __cil_tmp59 = *((struct list_head * const *)__cil_tmp58);  </pre></td></tr>
<tr id="source-370"><td><pre>370</pre></td><td><pre class="prettyprint">    __cil_tmp60 = (unsigned int )__cil_tmp59;  </pre></td></tr>
<tr id="source-371"><td><pre>371</pre></td><td><pre class="prettyprint">    __cil_tmp61 = __cil_tmp60 != __cil_tmp56;  </pre></td></tr>
<tr id="source-372"><td><pre>372</pre></td><td><pre class="prettyprint">    if (! __cil_tmp61) {  </pre></td></tr>
<tr id="source-373"><td><pre>373</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-374"><td><pre>374</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-375"><td><pre>375</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-376"><td><pre>376</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-377"><td><pre>377</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-378"><td><pre>378</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-379"><td><pre>379</pre></td><td><pre class="prettyprint">    goto while_9_break;  </pre></td></tr>
<tr id="source-380"><td><pre>380</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-381"><td><pre>381</pre></td><td><pre class="prettyprint">  while_9_break: ;  </pre></td></tr>
<tr id="source-382"><td><pre>382</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-383"><td><pre>383</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-384"><td><pre>384</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-385"><td><pre>385</pre></td><td><pre class="prettyprint">    while_10_continue: ;  </pre></td></tr>
<tr id="source-386"><td><pre>386</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-387"><td><pre>387</pre></td><td><pre class="prettyprint">    __cil_tmp62 = (unsigned int )node;  </pre></td></tr>
<tr id="source-388"><td><pre>388</pre></td><td><pre class="prettyprint">    __cil_tmp63 = __cil_tmp62 + 4;  </pre></td></tr>
<tr id="source-389"><td><pre>389</pre></td><td><pre class="prettyprint">    __cil_tmp64 = (struct list_head const *)__cil_tmp63;  </pre></td></tr>
<tr id="source-390"><td><pre>390</pre></td><td><pre class="prettyprint">    __cil_tmp65 = (unsigned int )__cil_tmp64;  </pre></td></tr>
<tr id="source-391"><td><pre>391</pre></td><td><pre class="prettyprint">    __cil_tmp66 = 12 + 4;  </pre></td></tr>
<tr id="source-392"><td><pre>392</pre></td><td><pre class="prettyprint">    __cil_tmp67 = (unsigned int )node;  </pre></td></tr>
<tr id="source-393"><td><pre>393</pre></td><td><pre class="prettyprint">    __cil_tmp68 = __cil_tmp67 + __cil_tmp66;  </pre></td></tr>
<tr id="source-394"><td><pre>394</pre></td><td><pre class="prettyprint">    __cil_tmp69 = *((struct list_head * const *)__cil_tmp68);  </pre></td></tr>
<tr id="source-395"><td><pre>395</pre></td><td><pre class="prettyprint">    __cil_tmp70 = (unsigned int )__cil_tmp69;  </pre></td></tr>
<tr id="source-396"><td><pre>396</pre></td><td><pre class="prettyprint">    __cil_tmp71 = __cil_tmp70 != __cil_tmp65;  </pre></td></tr>
<tr id="source-397"><td><pre>397</pre></td><td><pre class="prettyprint">    if (! __cil_tmp71) {  </pre></td></tr>
<tr id="source-398"><td><pre>398</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-399"><td><pre>399</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-400"><td><pre>400</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-401"><td><pre>401</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-402"><td><pre>402</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-403"><td><pre>403</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-404"><td><pre>404</pre></td><td><pre class="prettyprint">    goto while_10_break;  </pre></td></tr>
<tr id="source-405"><td><pre>405</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-406"><td><pre>406</pre></td><td><pre class="prettyprint">  while_10_break: ;  </pre></td></tr>
<tr id="source-407"><td><pre>407</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-408"><td><pre>408</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-409"><td><pre>409</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-410"><td><pre>410</pre></td><td><pre class="prettyprint">    while_11_continue: ;  </pre></td></tr>
<tr id="source-411"><td><pre>411</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-412"><td><pre>412</pre></td><td><pre class="prettyprint">    __cil_tmp72 = (struct node const *)head;  </pre></td></tr>
<tr id="source-413"><td><pre>413</pre></td><td><pre class="prettyprint">    __cil_tmp73 = (unsigned int )__cil_tmp72;  </pre></td></tr>
<tr id="source-414"><td><pre>414</pre></td><td><pre class="prettyprint">    __cil_tmp74 = (unsigned int )node;  </pre></td></tr>
<tr id="source-415"><td><pre>415</pre></td><td><pre class="prettyprint">    __cil_tmp75 = __cil_tmp74 != __cil_tmp73;  </pre></td></tr>
<tr id="source-416"><td><pre>416</pre></td><td><pre class="prettyprint">    if (! __cil_tmp75) {  </pre></td></tr>
<tr id="source-417"><td><pre>417</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-418"><td><pre>418</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-419"><td><pre>419</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-420"><td><pre>420</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-421"><td><pre>421</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-422"><td><pre>422</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-423"><td><pre>423</pre></td><td><pre class="prettyprint">    goto while_11_break;  </pre></td></tr>
<tr id="source-424"><td><pre>424</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-425"><td><pre>425</pre></td><td><pre class="prettyprint">  while_11_break: ;  </pre></td></tr>
<tr id="source-426"><td><pre>426</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-427"><td><pre>427</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-428"><td><pre>428</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-429"><td><pre>429</pre></td><td><pre class="prettyprint">    while_12_continue: ;  </pre></td></tr>
<tr id="source-430"><td><pre>430</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-431"><td><pre>431</pre></td><td><pre class="prettyprint">    __cil_tmp76 = (unsigned int )node;  </pre></td></tr>
<tr id="source-432"><td><pre>432</pre></td><td><pre class="prettyprint">    __cil_tmp77 = __cil_tmp76 + 4;  </pre></td></tr>
<tr id="source-433"><td><pre>433</pre></td><td><pre class="prettyprint">    __cil_tmp78 = (struct list_head const *)__cil_tmp77;  </pre></td></tr>
<tr id="source-434"><td><pre>434</pre></td><td><pre class="prettyprint">    __cil_tmp79 = (struct node const *)__cil_tmp78;  </pre></td></tr>
<tr id="source-435"><td><pre>435</pre></td><td><pre class="prettyprint">    __cil_tmp80 = (unsigned int )__cil_tmp79;  </pre></td></tr>
<tr id="source-436"><td><pre>436</pre></td><td><pre class="prettyprint">    __cil_tmp81 = (unsigned int )node;  </pre></td></tr>
<tr id="source-437"><td><pre>437</pre></td><td><pre class="prettyprint">    __cil_tmp82 = __cil_tmp81 != __cil_tmp80;  </pre></td></tr>
<tr id="source-438"><td><pre>438</pre></td><td><pre class="prettyprint">    if (! __cil_tmp82) {  </pre></td></tr>
<tr id="source-439"><td><pre>439</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-440"><td><pre>440</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-441"><td><pre>441</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-442"><td><pre>442</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-443"><td><pre>443</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-444"><td><pre>444</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-445"><td><pre>445</pre></td><td><pre class="prettyprint">    goto while_12_break;  </pre></td></tr>
<tr id="source-446"><td><pre>446</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-447"><td><pre>447</pre></td><td><pre class="prettyprint">  while_12_break: ;  </pre></td></tr>
<tr id="source-448"><td><pre>448</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-449"><td><pre>449</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-450"><td><pre>450</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-451"><td><pre>451</pre></td><td><pre class="prettyprint">    while_13_continue: ;  </pre></td></tr>
<tr id="source-452"><td><pre>452</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-453"><td><pre>453</pre></td><td><pre class="prettyprint">    __cil_tmp83 = (int const *)node;  </pre></td></tr>
<tr id="source-454"><td><pre>454</pre></td><td><pre class="prettyprint">    __cil_tmp84 = (struct node const *)__cil_tmp83;  </pre></td></tr>
<tr id="source-455"><td><pre>455</pre></td><td><pre class="prettyprint">    __cil_tmp85 = (unsigned int )__cil_tmp84;  </pre></td></tr>
<tr id="source-456"><td><pre>456</pre></td><td><pre class="prettyprint">    __cil_tmp86 = (unsigned int )node;  </pre></td></tr>
<tr id="source-457"><td><pre>457</pre></td><td><pre class="prettyprint">    __cil_tmp87 = __cil_tmp86 == __cil_tmp85;  </pre></td></tr>
<tr id="source-458"><td><pre>458</pre></td><td><pre class="prettyprint">    if (! __cil_tmp87) {  </pre></td></tr>
<tr id="source-459"><td><pre>459</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-460"><td><pre>460</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-461"><td><pre>461</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-462"><td><pre>462</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-463"><td><pre>463</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-464"><td><pre>464</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-465"><td><pre>465</pre></td><td><pre class="prettyprint">    goto while_13_break;  </pre></td></tr>
<tr id="source-466"><td><pre>466</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-467"><td><pre>467</pre></td><td><pre class="prettyprint">  while_13_break: ;  </pre></td></tr>
<tr id="source-468"><td><pre>468</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-469"><td><pre>469</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-470"><td><pre>470</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-471"><td><pre>471</pre></td><td><pre class="prettyprint">    while_14_continue: ;  </pre></td></tr>
<tr id="source-472"><td><pre>472</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-473"><td><pre>473</pre></td><td><pre class="prettyprint">    __cil_tmp88 = (unsigned int )node;  </pre></td></tr>
<tr id="source-474"><td><pre>474</pre></td><td><pre class="prettyprint">    __cil_tmp89 = __cil_tmp88 + 4;  </pre></td></tr>
<tr id="source-475"><td><pre>475</pre></td><td><pre class="prettyprint">    __cil_tmp90 = *((struct list_head * const *)__cil_tmp89);  </pre></td></tr>
<tr id="source-476"><td><pre>476</pre></td><td><pre class="prettyprint">    __cil_tmp91 = (unsigned int )__cil_tmp90;  </pre></td></tr>
<tr id="source-477"><td><pre>477</pre></td><td><pre class="prettyprint">    __cil_tmp92 = __cil_tmp91 + 4;  </pre></td></tr>
<tr id="source-478"><td><pre>478</pre></td><td><pre class="prettyprint">    __cil_tmp93 = *((struct list_head **)__cil_tmp92);  </pre></td></tr>
<tr id="source-479"><td><pre>479</pre></td><td><pre class="prettyprint">    __cil_tmp94 = (unsigned int )__cil_tmp93;  </pre></td></tr>
<tr id="source-480"><td><pre>480</pre></td><td><pre class="prettyprint">    __cil_tmp95 = (unsigned int )head;  </pre></td></tr>
<tr id="source-481"><td><pre>481</pre></td><td><pre class="prettyprint">    __cil_tmp96 = __cil_tmp95 == __cil_tmp94;  </pre></td></tr>
<tr id="source-482"><td><pre>482</pre></td><td><pre class="prettyprint">    if (! __cil_tmp96) {  </pre></td></tr>
<tr id="source-483"><td><pre>483</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-484"><td><pre>484</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-485"><td><pre>485</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-486"><td><pre>486</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-487"><td><pre>487</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-488"><td><pre>488</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-489"><td><pre>489</pre></td><td><pre class="prettyprint">    goto while_14_break;  </pre></td></tr>
<tr id="source-490"><td><pre>490</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-491"><td><pre>491</pre></td><td><pre class="prettyprint">  while_14_break: ;  </pre></td></tr>
<tr id="source-492"><td><pre>492</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-493"><td><pre>493</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-494"><td><pre>494</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-495"><td><pre>495</pre></td><td><pre class="prettyprint">    while_15_continue: ;  </pre></td></tr>
<tr id="source-496"><td><pre>496</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-497"><td><pre>497</pre></td><td><pre class="prettyprint">    __cil_tmp97 = 4 + 4;  </pre></td></tr>
<tr id="source-498"><td><pre>498</pre></td><td><pre class="prettyprint">    __cil_tmp98 = (unsigned int )node;  </pre></td></tr>
<tr id="source-499"><td><pre>499</pre></td><td><pre class="prettyprint">    __cil_tmp99 = __cil_tmp98 + __cil_tmp97;  </pre></td></tr>
<tr id="source-500"><td><pre>500</pre></td><td><pre class="prettyprint">    __cil_tmp100 = *((struct list_head * const *)__cil_tmp99);  </pre></td></tr>
<tr id="source-501"><td><pre>501</pre></td><td><pre class="prettyprint">    __cil_tmp101 = *((struct list_head **)__cil_tmp100);  </pre></td></tr>
<tr id="source-502"><td><pre>502</pre></td><td><pre class="prettyprint">    __cil_tmp102 = (unsigned int )__cil_tmp101;  </pre></td></tr>
<tr id="source-503"><td><pre>503</pre></td><td><pre class="prettyprint">    __cil_tmp103 = (unsigned int )head;  </pre></td></tr>
<tr id="source-504"><td><pre>504</pre></td><td><pre class="prettyprint">    __cil_tmp104 = __cil_tmp103 == __cil_tmp102;  </pre></td></tr>
<tr id="source-505"><td><pre>505</pre></td><td><pre class="prettyprint">    if (! __cil_tmp104) {  </pre></td></tr>
<tr id="source-506"><td><pre>506</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-507"><td><pre>507</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-508"><td><pre>508</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-509"><td><pre>509</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-510"><td><pre>510</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-511"><td><pre>511</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-512"><td><pre>512</pre></td><td><pre class="prettyprint">    goto while_15_break;  </pre></td></tr>
<tr id="source-513"><td><pre>513</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-514"><td><pre>514</pre></td><td><pre class="prettyprint">  while_15_break: ;  </pre></td></tr>
<tr id="source-515"><td><pre>515</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-516"><td><pre>516</pre></td><td><pre class="prettyprint">  __cil_tmp105 = *((struct list_head * const *)head);  </pre></td></tr>
<tr id="source-517"><td><pre>517</pre></td><td><pre class="prettyprint">  head = (struct list_head const *)__cil_tmp105;  </pre></td></tr>
<tr id="source-518"><td><pre>518</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-519"><td><pre>519</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-520"><td><pre>520</pre></td><td><pre class="prettyprint">    while_16_continue: ;  </pre></td></tr>
<tr id="source-521"><td><pre>521</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-522"><td><pre>522</pre></td><td><pre class="prettyprint">    __cil_tmp106 = (unsigned int )head;  </pre></td></tr>
<tr id="source-523"><td><pre>523</pre></td><td><pre class="prettyprint">    __cil_tmp107 = (unsigned int )node;  </pre></td></tr>
<tr id="source-524"><td><pre>524</pre></td><td><pre class="prettyprint">    __cil_tmp108 = __cil_tmp107 + 4;  </pre></td></tr>
<tr id="source-525"><td><pre>525</pre></td><td><pre class="prettyprint">    __cil_tmp109 = (struct list_head const *)__cil_tmp108;  </pre></td></tr>
<tr id="source-526"><td><pre>526</pre></td><td><pre class="prettyprint">    __cil_tmp110 = (unsigned int )__cil_tmp109;  </pre></td></tr>
<tr id="source-527"><td><pre>527</pre></td><td><pre class="prettyprint">    if (__cil_tmp110 != __cil_tmp106) {  </pre></td></tr>
<tr id="source-528"><td><pre>528</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-529"><td><pre>529</pre></td><td><pre class="prettyprint">      goto while_16_break;  </pre></td></tr>
<tr id="source-530"><td><pre>530</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-531"><td><pre>531</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-532"><td><pre>532</pre></td><td><pre class="prettyprint">    __cil_tmp111 = *((struct list_head * const *)head);  </pre></td></tr>
<tr id="source-533"><td><pre>533</pre></td><td><pre class="prettyprint">    head = (struct list_head const *)__cil_tmp111;  </pre></td></tr>
<tr id="source-534"><td><pre>534</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-535"><td><pre>535</pre></td><td><pre class="prettyprint">  while_16_break: ;  </pre></td></tr>
<tr id="source-536"><td><pre>536</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-537"><td><pre>537</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-538"><td><pre>538</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-539"><td><pre>539</pre></td><td><pre class="prettyprint">    while_17_continue: ;  </pre></td></tr>
<tr id="source-540"><td><pre>540</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-541"><td><pre>541</pre></td><td><pre class="prettyprint">    __cil_tmp112 = (unsigned int )node;  </pre></td></tr>
<tr id="source-542"><td><pre>542</pre></td><td><pre class="prettyprint">    __cil_tmp113 = (struct node *)0;  </pre></td></tr>
<tr id="source-543"><td><pre>543</pre></td><td><pre class="prettyprint">    __cil_tmp114 = (unsigned int )__cil_tmp113;  </pre></td></tr>
<tr id="source-544"><td><pre>544</pre></td><td><pre class="prettyprint">    __cil_tmp115 = __cil_tmp114 + 4;  </pre></td></tr>
<tr id="source-545"><td><pre>545</pre></td><td><pre class="prettyprint">    __cil_tmp116 = (struct list_head *)__cil_tmp115;  </pre></td></tr>
<tr id="source-546"><td><pre>546</pre></td><td><pre class="prettyprint">    __cil_tmp117 = (unsigned long )__cil_tmp116;  </pre></td></tr>
<tr id="source-547"><td><pre>547</pre></td><td><pre class="prettyprint">    __cil_tmp118 = (char *)head;  </pre></td></tr>
<tr id="source-548"><td><pre>548</pre></td><td><pre class="prettyprint">    __cil_tmp119 = __cil_tmp118 - __cil_tmp117;  </pre></td></tr>
<tr id="source-549"><td><pre>549</pre></td><td><pre class="prettyprint">    __cil_tmp120 = (struct node *)__cil_tmp119;  </pre></td></tr>
<tr id="source-550"><td><pre>550</pre></td><td><pre class="prettyprint">    __cil_tmp121 = (unsigned int )__cil_tmp120;  </pre></td></tr>
<tr id="source-551"><td><pre>551</pre></td><td><pre class="prettyprint">    __cil_tmp122 = __cil_tmp121 == __cil_tmp112;  </pre></td></tr>
<tr id="source-552"><td><pre>552</pre></td><td><pre class="prettyprint">    if (! __cil_tmp122) {  </pre></td></tr>
<tr id="source-553"><td><pre>553</pre></td><td><pre class="prettyprint">      {  </pre></td></tr>
<tr id="source-554"><td><pre>554</pre></td><td><pre class="prettyprint">      fail();  </pre></td></tr>
<tr id="source-555"><td><pre>555</pre></td><td><pre class="prettyprint">      }  </pre></td></tr>
<tr id="source-556"><td><pre>556</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-557"><td><pre>557</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-558"><td><pre>558</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-559"><td><pre>559</pre></td><td><pre class="prettyprint">    goto while_17_break;  </pre></td></tr>
<tr id="source-560"><td><pre>560</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-561"><td><pre>561</pre></td><td><pre class="prettyprint">  while_17_break: ;  </pre></td></tr>
<tr id="source-562"><td><pre>562</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-563"><td><pre>563</pre></td><td><pre class="prettyprint">  return;  </pre></td></tr>
<tr id="source-564"><td><pre>564</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-565"><td><pre>565</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-566"><td><pre>566</pre></td><td><pre class="prettyprint">__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next )  </pre></td></tr>
<tr id="source-567"><td><pre>567</pre></td><td><pre class="prettyprint">{ unsigned int __cil_tmp4 ;  </pre></td></tr>
<tr id="source-568"><td><pre>568</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp5 ;  </pre></td></tr>
<tr id="source-569"><td><pre>569</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp6 ;  </pre></td></tr>
<tr id="source-570"><td><pre>570</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp7 ;  </pre></td></tr>
<tr id="source-571"><td><pre>571</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-572"><td><pre>572</pre></td><td><pre class="prettyprint">  __cil_tmp4 = (unsigned int )next;  </pre></td></tr>
<tr id="source-573"><td><pre>573</pre></td><td><pre class="prettyprint">  __cil_tmp5 = __cil_tmp4 + 4;  </pre></td></tr>
<tr id="source-574"><td><pre>574</pre></td><td><pre class="prettyprint">  *((struct list_head **)__cil_tmp5) = new;  </pre></td></tr>
<tr id="source-575"><td><pre>575</pre></td><td><pre class="prettyprint">  *((struct list_head **)new) = next;  </pre></td></tr>
<tr id="source-576"><td><pre>576</pre></td><td><pre class="prettyprint">  __cil_tmp6 = (unsigned int )new;  </pre></td></tr>
<tr id="source-577"><td><pre>577</pre></td><td><pre class="prettyprint">  __cil_tmp7 = __cil_tmp6 + 4;  </pre></td></tr>
<tr id="source-578"><td><pre>578</pre></td><td><pre class="prettyprint">  *((struct list_head **)__cil_tmp7) = prev;  </pre></td></tr>
<tr id="source-579"><td><pre>579</pre></td><td><pre class="prettyprint">  *((struct list_head **)prev) = new;  </pre></td></tr>
<tr id="source-580"><td><pre>580</pre></td><td><pre class="prettyprint">  return;  </pre></td></tr>
<tr id="source-581"><td><pre>581</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-582"><td><pre>582</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-583"><td><pre>583</pre></td><td><pre class="prettyprint">__inline static void __list_del(struct list_head *prev , struct list_head *next )  </pre></td></tr>
<tr id="source-584"><td><pre>584</pre></td><td><pre class="prettyprint">{ unsigned int __cil_tmp3 ;  </pre></td></tr>
<tr id="source-585"><td><pre>585</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp4 ;  </pre></td></tr>
<tr id="source-586"><td><pre>586</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-587"><td><pre>587</pre></td><td><pre class="prettyprint">  __cil_tmp3 = (unsigned int )next;  </pre></td></tr>
<tr id="source-588"><td><pre>588</pre></td><td><pre class="prettyprint">  __cil_tmp4 = __cil_tmp3 + 4;  </pre></td></tr>
<tr id="source-589"><td><pre>589</pre></td><td><pre class="prettyprint">  *((struct list_head **)__cil_tmp4) = prev;  </pre></td></tr>
<tr id="source-590"><td><pre>590</pre></td><td><pre class="prettyprint">  *((struct list_head **)prev) = next;  </pre></td></tr>
<tr id="source-591"><td><pre>591</pre></td><td><pre class="prettyprint">  return;  </pre></td></tr>
<tr id="source-592"><td><pre>592</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-593"><td><pre>593</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-594"><td><pre>594</pre></td><td><pre class="prettyprint">__inline static void list_add(struct list_head *new , struct list_head *head )  </pre></td></tr>
<tr id="source-595"><td><pre>595</pre></td><td><pre class="prettyprint">{ struct list_head *__cil_tmp3 ;  </pre></td></tr>
<tr id="source-596"><td><pre>596</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-597"><td><pre>597</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-598"><td><pre>598</pre></td><td><pre class="prettyprint">  __cil_tmp3 = *((struct list_head **)head);  </pre></td></tr>
<tr id="source-599"><td><pre>599</pre></td><td><pre class="prettyprint">  __list_add(new, head, __cil_tmp3);  </pre></td></tr>
<tr id="source-600"><td><pre>600</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-601"><td><pre>601</pre></td><td><pre class="prettyprint">  return;  </pre></td></tr>
<tr id="source-602"><td><pre>602</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-603"><td><pre>603</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-604"><td><pre>604</pre></td><td><pre class="prettyprint">__inline static void list_move(struct list_head *list , struct list_head *head )  </pre></td></tr>
<tr id="source-605"><td><pre>605</pre></td><td><pre class="prettyprint">{ unsigned int __cil_tmp3 ;  </pre></td></tr>
<tr id="source-606"><td><pre>606</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp4 ;  </pre></td></tr>
<tr id="source-607"><td><pre>607</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp5 ;  </pre></td></tr>
<tr id="source-608"><td><pre>608</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp6 ;  </pre></td></tr>
<tr id="source-609"><td><pre>609</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-610"><td><pre>610</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-611"><td><pre>611</pre></td><td><pre class="prettyprint">  __cil_tmp3 = (unsigned int )list;  </pre></td></tr>
<tr id="source-612"><td><pre>612</pre></td><td><pre class="prettyprint">  __cil_tmp4 = __cil_tmp3 + 4;  </pre></td></tr>
<tr id="source-613"><td><pre>613</pre></td><td><pre class="prettyprint">  __cil_tmp5 = *((struct list_head **)__cil_tmp4);  </pre></td></tr>
<tr id="source-614"><td><pre>614</pre></td><td><pre class="prettyprint">  __cil_tmp6 = *((struct list_head **)list);  </pre></td></tr>
<tr id="source-615"><td><pre>615</pre></td><td><pre class="prettyprint">  __list_del(__cil_tmp5, __cil_tmp6);  </pre></td></tr>
<tr id="source-616"><td><pre>616</pre></td><td><pre class="prettyprint">  list_add(list, head);  </pre></td></tr>
<tr id="source-617"><td><pre>617</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-618"><td><pre>618</pre></td><td><pre class="prettyprint">  return;  </pre></td></tr>
<tr id="source-619"><td><pre>619</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-620"><td><pre>620</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-621"><td><pre>621</pre></td><td><pre class="prettyprint">static void gl_insert(int value )  </pre></td></tr>
<tr id="source-622"><td><pre>622</pre></td><td><pre class="prettyprint">{ struct node *node ;  </pre></td></tr>
<tr id="source-623"><td><pre>623</pre></td><td><pre class="prettyprint">  void *tmp ;  </pre></td></tr>
<tr id="source-624"><td><pre>624</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp4 ;  </pre></td></tr>
<tr id="source-625"><td><pre>625</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp5 ;  </pre></td></tr>
<tr id="source-626"><td><pre>626</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp6 ;  </pre></td></tr>
<tr id="source-627"><td><pre>627</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp7 ;  </pre></td></tr>
<tr id="source-628"><td><pre>628</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp8 ;  </pre></td></tr>
<tr id="source-629"><td><pre>629</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp9 ;  </pre></td></tr>
<tr id="source-630"><td><pre>630</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp10 ;  </pre></td></tr>
<tr id="source-631"><td><pre>631</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp11 ;  </pre></td></tr>
<tr id="source-632"><td><pre>632</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp12 ;  </pre></td></tr>
<tr id="source-633"><td><pre>633</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp13 ;  </pre></td></tr>
<tr id="source-634"><td><pre>634</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp14 ;  </pre></td></tr>
<tr id="source-635"><td><pre>635</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp15 ;  </pre></td></tr>
<tr id="source-636"><td><pre>636</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-637"><td><pre>637</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-638"><td><pre>638</pre></td><td><pre class="prettyprint">  __cil_tmp4 = (unsigned int )20UL;  </pre></td></tr>
<tr id="source-639"><td><pre>639</pre></td><td><pre class="prettyprint">  tmp = malloc(__cil_tmp4);  </pre></td></tr>
<tr id="source-640"><td><pre>640</pre></td><td><pre class="prettyprint">  node = (struct node *)tmp;  </pre></td></tr>
<tr id="source-641"><td><pre>641</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-642"><td><pre>642</pre></td><td><pre class="prettyprint">  if (! node) {  </pre></td></tr>
<tr id="source-643"><td><pre>643</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-644"><td><pre>644</pre></td><td><pre class="prettyprint">    abort();  </pre></td></tr>
<tr id="source-645"><td><pre>645</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-646"><td><pre>646</pre></td><td><pre class="prettyprint">  } else {  </pre></td></tr>
<tr id="source-647"><td><pre>647</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-648"><td><pre>648</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-649"><td><pre>649</pre></td><td><pre class="prettyprint">  *((int *)node) = value;  </pre></td></tr>
<tr id="source-650"><td><pre>650</pre></td><td><pre class="prettyprint">  __cil_tmp5 = (unsigned int )node;  </pre></td></tr>
<tr id="source-651"><td><pre>651</pre></td><td><pre class="prettyprint">  __cil_tmp6 = __cil_tmp5 + 4;  </pre></td></tr>
<tr id="source-652"><td><pre>652</pre></td><td><pre class="prettyprint">  __cil_tmp7 = (struct list_head *)__cil_tmp6;  </pre></td></tr>
<tr id="source-653"><td><pre>653</pre></td><td><pre class="prettyprint">  list_add(__cil_tmp7, &amp; gl_list);  </pre></td></tr>
<tr id="source-654"><td><pre>654</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-655"><td><pre>655</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-656"><td><pre>656</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-657"><td><pre>657</pre></td><td><pre class="prettyprint">    while_18_continue: ;  </pre></td></tr>
<tr id="source-658"><td><pre>658</pre></td><td><pre class="prettyprint">    __cil_tmp8 = (unsigned int )node;  </pre></td></tr>
<tr id="source-659"><td><pre>659</pre></td><td><pre class="prettyprint">    __cil_tmp9 = __cil_tmp8 + 12;  </pre></td></tr>
<tr id="source-660"><td><pre>660</pre></td><td><pre class="prettyprint">    __cil_tmp10 = (unsigned int )node;  </pre></td></tr>
<tr id="source-661"><td><pre>661</pre></td><td><pre class="prettyprint">    __cil_tmp11 = __cil_tmp10 + 12;  </pre></td></tr>
<tr id="source-662"><td><pre>662</pre></td><td><pre class="prettyprint">    *((struct list_head **)__cil_tmp9) = (struct list_head *)__cil_tmp11;  </pre></td></tr>
<tr id="source-663"><td><pre>663</pre></td><td><pre class="prettyprint">    __cil_tmp12 = (unsigned int )node;  </pre></td></tr>
<tr id="source-664"><td><pre>664</pre></td><td><pre class="prettyprint">    __cil_tmp13 = __cil_tmp12 + 12;  </pre></td></tr>
<tr id="source-665"><td><pre>665</pre></td><td><pre class="prettyprint">    __cil_tmp14 = (unsigned int )node;  </pre></td></tr>
<tr id="source-666"><td><pre>666</pre></td><td><pre class="prettyprint">    __cil_tmp15 = __cil_tmp14 + 12;  </pre></td></tr>
<tr id="source-667"><td><pre>667</pre></td><td><pre class="prettyprint">    *((struct list_head **)__cil_tmp13) = (struct list_head *)__cil_tmp15;  </pre></td></tr>
<tr id="source-668"><td><pre>668</pre></td><td><pre class="prettyprint">    goto while_18_break;  </pre></td></tr>
<tr id="source-669"><td><pre>669</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-670"><td><pre>670</pre></td><td><pre class="prettyprint">  while_18_break: ;  </pre></td></tr>
<tr id="source-671"><td><pre>671</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-672"><td><pre>672</pre></td><td><pre class="prettyprint">  return;  </pre></td></tr>
<tr id="source-673"><td><pre>673</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-674"><td><pre>674</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-675"><td><pre>675</pre></td><td><pre class="prettyprint">static void gl_read(void)  </pre></td></tr>
<tr id="source-676"><td><pre>676</pre></td><td><pre class="prettyprint">{ int tmp ;  </pre></td></tr>
<tr id="source-677"><td><pre>677</pre></td><td><pre class="prettyprint">  int tmp___0 ;  </pre></td></tr>
<tr id="source-678"><td><pre>678</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-679"><td><pre>679</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-680"><td><pre>680</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-681"><td><pre>681</pre></td><td><pre class="prettyprint">    while_19_continue: ;  </pre></td></tr>
<tr id="source-682"><td><pre>682</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-683"><td><pre>683</pre></td><td><pre class="prettyprint">    tmp = __VERIFIER_nondet_int();  </pre></td></tr>
<tr id="source-684"><td><pre>684</pre></td><td><pre class="prettyprint">    gl_insert(tmp);  </pre></td></tr>
<tr id="source-685"><td><pre>685</pre></td><td><pre class="prettyprint">    tmp___0 = __VERIFIER_nondet_int();  </pre></td></tr>
<tr id="source-686"><td><pre>686</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-687"><td><pre>687</pre></td><td><pre class="prettyprint">    if (tmp___0) {  </pre></td></tr>
<tr id="source-688"><td><pre>688</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-689"><td><pre>689</pre></td><td><pre class="prettyprint">      goto while_19_break;  </pre></td></tr>
<tr id="source-690"><td><pre>690</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-691"><td><pre>691</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-692"><td><pre>692</pre></td><td><pre class="prettyprint">  while_19_break: ;  </pre></td></tr>
<tr id="source-693"><td><pre>693</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-694"><td><pre>694</pre></td><td><pre class="prettyprint">  return;  </pre></td></tr>
<tr id="source-695"><td><pre>695</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-696"><td><pre>696</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-697"><td><pre>697</pre></td><td><pre class="prettyprint">static void gl_destroy(void)  </pre></td></tr>
<tr id="source-698"><td><pre>698</pre></td><td><pre class="prettyprint">{ struct list_head *next ;  </pre></td></tr>
<tr id="source-699"><td><pre>699</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp2 ;  </pre></td></tr>
<tr id="source-700"><td><pre>700</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp3 ;  </pre></td></tr>
<tr id="source-701"><td><pre>701</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp4 ;  </pre></td></tr>
<tr id="source-702"><td><pre>702</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp5 ;  </pre></td></tr>
<tr id="source-703"><td><pre>703</pre></td><td><pre class="prettyprint">  struct node *__cil_tmp6 ;  </pre></td></tr>
<tr id="source-704"><td><pre>704</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp7 ;  </pre></td></tr>
<tr id="source-705"><td><pre>705</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp8 ;  </pre></td></tr>
<tr id="source-706"><td><pre>706</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp9 ;  </pre></td></tr>
<tr id="source-707"><td><pre>707</pre></td><td><pre class="prettyprint">  unsigned long __cil_tmp10 ;  </pre></td></tr>
<tr id="source-708"><td><pre>708</pre></td><td><pre class="prettyprint">  char *__cil_tmp11 ;  </pre></td></tr>
<tr id="source-709"><td><pre>709</pre></td><td><pre class="prettyprint">  char *__cil_tmp12 ;  </pre></td></tr>
<tr id="source-710"><td><pre>710</pre></td><td><pre class="prettyprint">  struct node *__cil_tmp13 ;  </pre></td></tr>
<tr id="source-711"><td><pre>711</pre></td><td><pre class="prettyprint">  void *__cil_tmp14 ;  </pre></td></tr>
<tr id="source-712"><td><pre>712</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-713"><td><pre>713</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-714"><td><pre>714</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-715"><td><pre>715</pre></td><td><pre class="prettyprint">    while_20_continue: ;  </pre></td></tr>
<tr id="source-716"><td><pre>716</pre></td><td><pre class="prettyprint">    __cil_tmp2 = &amp; gl_list;  </pre></td></tr>
<tr id="source-717"><td><pre>717</pre></td><td><pre class="prettyprint">    next = *((struct list_head **)__cil_tmp2);  </pre></td></tr>
<tr id="source-718"><td><pre>718</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-719"><td><pre>719</pre></td><td><pre class="prettyprint">    __cil_tmp3 = (unsigned int )next;  </pre></td></tr>
<tr id="source-720"><td><pre>720</pre></td><td><pre class="prettyprint">    __cil_tmp4 = (unsigned int )(&amp; gl_list);  </pre></td></tr>
<tr id="source-721"><td><pre>721</pre></td><td><pre class="prettyprint">    if (__cil_tmp4 != __cil_tmp3) {  </pre></td></tr>
<tr id="source-722"><td><pre>722</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-723"><td><pre>723</pre></td><td><pre class="prettyprint">      goto while_20_break;  </pre></td></tr>
<tr id="source-724"><td><pre>724</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-725"><td><pre>725</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-726"><td><pre>726</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-727"><td><pre>727</pre></td><td><pre class="prettyprint">    __cil_tmp5 = &amp; gl_list;  </pre></td></tr>
<tr id="source-728"><td><pre>728</pre></td><td><pre class="prettyprint">    *((struct list_head **)__cil_tmp5) = *((struct list_head **)next);  </pre></td></tr>
<tr id="source-729"><td><pre>729</pre></td><td><pre class="prettyprint">    __cil_tmp6 = (struct node *)0;  </pre></td></tr>
<tr id="source-730"><td><pre>730</pre></td><td><pre class="prettyprint">    __cil_tmp7 = (unsigned int )__cil_tmp6;  </pre></td></tr>
<tr id="source-731"><td><pre>731</pre></td><td><pre class="prettyprint">    __cil_tmp8 = __cil_tmp7 + 4;  </pre></td></tr>
<tr id="source-732"><td><pre>732</pre></td><td><pre class="prettyprint">    __cil_tmp9 = (struct list_head *)__cil_tmp8;  </pre></td></tr>
<tr id="source-733"><td><pre>733</pre></td><td><pre class="prettyprint">    __cil_tmp10 = (unsigned long )__cil_tmp9;  </pre></td></tr>
<tr id="source-734"><td><pre>734</pre></td><td><pre class="prettyprint">    __cil_tmp11 = (char *)next;  </pre></td></tr>
<tr id="source-735"><td><pre>735</pre></td><td><pre class="prettyprint">    __cil_tmp12 = __cil_tmp11 - __cil_tmp10;  </pre></td></tr>
<tr id="source-736"><td><pre>736</pre></td><td><pre class="prettyprint">    __cil_tmp13 = (struct node *)__cil_tmp12;  </pre></td></tr>
<tr id="source-737"><td><pre>737</pre></td><td><pre class="prettyprint">    __cil_tmp14 = (void *)__cil_tmp13;  </pre></td></tr>
<tr id="source-738"><td><pre>738</pre></td><td><pre class="prettyprint">    free(__cil_tmp14);  </pre></td></tr>
<tr id="source-739"><td><pre>739</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-740"><td><pre>740</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-741"><td><pre>741</pre></td><td><pre class="prettyprint">  while_20_break: ;  </pre></td></tr>
<tr id="source-742"><td><pre>742</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-743"><td><pre>743</pre></td><td><pre class="prettyprint">  return;  </pre></td></tr>
<tr id="source-744"><td><pre>744</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-745"><td><pre>745</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-746"><td><pre>746</pre></td><td><pre class="prettyprint">static int val_from_node(struct list_head *head )  </pre></td></tr>
<tr id="source-747"><td><pre>747</pre></td><td><pre class="prettyprint">{ struct node *entry ;  </pre></td></tr>
<tr id="source-748"><td><pre>748</pre></td><td><pre class="prettyprint">  struct node *__cil_tmp3 ;  </pre></td></tr>
<tr id="source-749"><td><pre>749</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp4 ;  </pre></td></tr>
<tr id="source-750"><td><pre>750</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp5 ;  </pre></td></tr>
<tr id="source-751"><td><pre>751</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp6 ;  </pre></td></tr>
<tr id="source-752"><td><pre>752</pre></td><td><pre class="prettyprint">  unsigned long __cil_tmp7 ;  </pre></td></tr>
<tr id="source-753"><td><pre>753</pre></td><td><pre class="prettyprint">  char *__cil_tmp8 ;  </pre></td></tr>
<tr id="source-754"><td><pre>754</pre></td><td><pre class="prettyprint">  char *__cil_tmp9 ;  </pre></td></tr>
<tr id="source-755"><td><pre>755</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-756"><td><pre>756</pre></td><td><pre class="prettyprint">  __cil_tmp3 = (struct node *)0;  </pre></td></tr>
<tr id="source-757"><td><pre>757</pre></td><td><pre class="prettyprint">  __cil_tmp4 = (unsigned int )__cil_tmp3;  </pre></td></tr>
<tr id="source-758"><td><pre>758</pre></td><td><pre class="prettyprint">  __cil_tmp5 = __cil_tmp4 + 4;  </pre></td></tr>
<tr id="source-759"><td><pre>759</pre></td><td><pre class="prettyprint">  __cil_tmp6 = (struct list_head *)__cil_tmp5;  </pre></td></tr>
<tr id="source-760"><td><pre>760</pre></td><td><pre class="prettyprint">  __cil_tmp7 = (unsigned long )__cil_tmp6;  </pre></td></tr>
<tr id="source-761"><td><pre>761</pre></td><td><pre class="prettyprint">  __cil_tmp8 = (char *)head;  </pre></td></tr>
<tr id="source-762"><td><pre>762</pre></td><td><pre class="prettyprint">  __cil_tmp9 = __cil_tmp8 - __cil_tmp7;  </pre></td></tr>
<tr id="source-763"><td><pre>763</pre></td><td><pre class="prettyprint">  entry = (struct node *)__cil_tmp9;  </pre></td></tr>
<tr id="source-764"><td><pre>764</pre></td><td><pre class="prettyprint">  return (*((int *)entry));  </pre></td></tr>
<tr id="source-765"><td><pre>765</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-766"><td><pre>766</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-767"><td><pre>767</pre></td><td><pre class="prettyprint">static _Bool gl_sort_pass(void)  </pre></td></tr>
<tr id="source-768"><td><pre>768</pre></td><td><pre class="prettyprint">{ _Bool any_change ;  </pre></td></tr>
<tr id="source-769"><td><pre>769</pre></td><td><pre class="prettyprint">  struct list_head *pos0 ;  </pre></td></tr>
<tr id="source-770"><td><pre>770</pre></td><td><pre class="prettyprint">  struct list_head *pos1 ;  </pre></td></tr>
<tr id="source-771"><td><pre>771</pre></td><td><pre class="prettyprint">  int val0 ;  </pre></td></tr>
<tr id="source-772"><td><pre>772</pre></td><td><pre class="prettyprint">  int tmp ;  </pre></td></tr>
<tr id="source-773"><td><pre>773</pre></td><td><pre class="prettyprint">  int val1 ;  </pre></td></tr>
<tr id="source-774"><td><pre>774</pre></td><td><pre class="prettyprint">  int tmp___0 ;  </pre></td></tr>
<tr id="source-775"><td><pre>775</pre></td><td><pre class="prettyprint">  struct list_head *__cil_tmp8 ;  </pre></td></tr>
<tr id="source-776"><td><pre>776</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp9 ;  </pre></td></tr>
<tr id="source-777"><td><pre>777</pre></td><td><pre class="prettyprint">  unsigned int __cil_tmp10 ;  </pre></td></tr>
<tr id="source-778"><td><pre>778</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-779"><td><pre>779</pre></td><td><pre class="prettyprint">  any_change = (_Bool)0;  </pre></td></tr>
<tr id="source-780"><td><pre>780</pre></td><td><pre class="prettyprint">  __cil_tmp8 = &amp; gl_list;  </pre></td></tr>
<tr id="source-781"><td><pre>781</pre></td><td><pre class="prettyprint">  pos0 = *((struct list_head **)__cil_tmp8);  </pre></td></tr>
<tr id="source-782"><td><pre>782</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-783"><td><pre>783</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-784"><td><pre>784</pre></td><td><pre class="prettyprint">    while_21_continue: ;  </pre></td></tr>
<tr id="source-785"><td><pre>785</pre></td><td><pre class="prettyprint">    pos1 = *((struct list_head **)pos0);  </pre></td></tr>
<tr id="source-786"><td><pre>786</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-787"><td><pre>787</pre></td><td><pre class="prettyprint">    __cil_tmp9 = (unsigned int )pos1;  </pre></td></tr>
<tr id="source-788"><td><pre>788</pre></td><td><pre class="prettyprint">    __cil_tmp10 = (unsigned int )(&amp; gl_list);  </pre></td></tr>
<tr id="source-789"><td><pre>789</pre></td><td><pre class="prettyprint">    if (__cil_tmp10 != __cil_tmp9) {  </pre></td></tr>
<tr id="source-790"><td><pre>790</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-791"><td><pre>791</pre></td><td><pre class="prettyprint">      goto while_21_break;  </pre></td></tr>
<tr id="source-792"><td><pre>792</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-793"><td><pre>793</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-794"><td><pre>794</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-795"><td><pre>795</pre></td><td><pre class="prettyprint">    tmp = val_from_node(pos0);  </pre></td></tr>
<tr id="source-796"><td><pre>796</pre></td><td><pre class="prettyprint">    val0 = tmp;  </pre></td></tr>
<tr id="source-797"><td><pre>797</pre></td><td><pre class="prettyprint">    tmp___0 = val_from_node(pos1);  </pre></td></tr>
<tr id="source-798"><td><pre>798</pre></td><td><pre class="prettyprint">    val1 = tmp___0;  </pre></td></tr>
<tr id="source-799"><td><pre>799</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-800"><td><pre>800</pre></td><td><pre class="prettyprint">    if (val0 &lt;= val1) {  </pre></td></tr>
<tr id="source-801"><td><pre>801</pre></td><td><pre class="prettyprint">      pos0 = pos1;  </pre></td></tr>
<tr id="source-802"><td><pre>802</pre></td><td><pre class="prettyprint">      goto while_21_continue;  </pre></td></tr>
<tr id="source-803"><td><pre>803</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-804"><td><pre>804</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-805"><td><pre>805</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-806"><td><pre>806</pre></td><td><pre class="prettyprint">    any_change = (_Bool)1;  </pre></td></tr>
<tr id="source-807"><td><pre>807</pre></td><td><pre class="prettyprint">    list_move(pos0, pos1);  </pre></td></tr>
<tr id="source-808"><td><pre>808</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-809"><td><pre>809</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-810"><td><pre>810</pre></td><td><pre class="prettyprint">  while_21_break: ;  </pre></td></tr>
<tr id="source-811"><td><pre>811</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-812"><td><pre>812</pre></td><td><pre class="prettyprint">  return (any_change);  </pre></td></tr>
<tr id="source-813"><td><pre>813</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-814"><td><pre>814</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-815"><td><pre>815</pre></td><td><pre class="prettyprint">static void gl_sort(void)  </pre></td></tr>
<tr id="source-816"><td><pre>816</pre></td><td><pre class="prettyprint">{ _Bool tmp ;  </pre></td></tr>
<tr id="source-817"><td><pre>817</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-818"><td><pre>818</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-819"><td><pre>819</pre></td><td><pre class="prettyprint">  while (1) {  </pre></td></tr>
<tr id="source-820"><td><pre>820</pre></td><td><pre class="prettyprint">    while_22_continue: ;  </pre></td></tr>
<tr id="source-821"><td><pre>821</pre></td><td><pre class="prettyprint">    {  </pre></td></tr>
<tr id="source-822"><td><pre>822</pre></td><td><pre class="prettyprint">    tmp = gl_sort_pass();  </pre></td></tr>
<tr id="source-823"><td><pre>823</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-824"><td><pre>824</pre></td><td><pre class="prettyprint">    if (tmp) {  </pre></td></tr>
<tr id="source-825"><td><pre>825</pre></td><td><pre class="prettyprint">    } else {  </pre></td></tr>
<tr id="source-826"><td><pre>826</pre></td><td><pre class="prettyprint">      goto while_22_break;  </pre></td></tr>
<tr id="source-827"><td><pre>827</pre></td><td><pre class="prettyprint">    }  </pre></td></tr>
<tr id="source-828"><td><pre>828</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-829"><td><pre>829</pre></td><td><pre class="prettyprint">  while_22_break: ;  </pre></td></tr>
<tr id="source-830"><td><pre>830</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-831"><td><pre>831</pre></td><td><pre class="prettyprint">  return;  </pre></td></tr>
<tr id="source-832"><td><pre>832</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-833"><td><pre>833</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-834"><td><pre>834</pre></td><td><pre class="prettyprint">int main(void)  </pre></td></tr>
<tr id="source-835"><td><pre>835</pre></td><td><pre class="prettyprint">{ struct list_head const *__cil_tmp1 ;  </pre></td></tr>
<tr id="source-836"><td><pre>836</pre></td><td><pre class="prettyprint">  struct list_head const *__cil_tmp2 ;  </pre></td></tr>
<tr id="source-837"><td><pre>837</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-838"><td><pre>838</pre></td><td><pre class="prettyprint">  {  </pre></td></tr>
<tr id="source-839"><td><pre>839</pre></td><td><pre class="prettyprint">  gl_read();  </pre></td></tr>
<tr id="source-840"><td><pre>840</pre></td><td><pre class="prettyprint">  __cil_tmp1 = (struct list_head const *)(&amp; gl_list);  </pre></td></tr>
<tr id="source-841"><td><pre>841</pre></td><td><pre class="prettyprint">  inspect(__cil_tmp1);  </pre></td></tr>
<tr id="source-842"><td><pre>842</pre></td><td><pre class="prettyprint">  gl_sort();  </pre></td></tr>
<tr id="source-843"><td><pre>843</pre></td><td><pre class="prettyprint">  __cil_tmp2 = (struct list_head const *)(&amp; gl_list);  </pre></td></tr>
<tr id="source-844"><td><pre>844</pre></td><td><pre class="prettyprint">  inspect(__cil_tmp2);  </pre></td></tr>
<tr id="source-845"><td><pre>845</pre></td><td><pre class="prettyprint">  gl_destroy();  </pre></td></tr>
<tr id="source-846"><td><pre>846</pre></td><td><pre class="prettyprint">  }  </pre></td></tr>
<tr id="source-847"><td><pre>847</pre></td><td><pre class="prettyprint">  return (0);  </pre></td></tr>
<tr id="source-848"><td><pre>848</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
<tr id="source-849"><td><pre>849</pre></td><td><pre class="prettyprint">}  </pre></td></tr>
</table></div>
      </div>
      <div class="fileContent content" ng-show="tabIsSet(4)" ng-class="{active: tabIsSet(4)}">
<table  id="log_table" class="display" style="width:100%;padding: 10px" class="table table-bordered"><thead class="thead-light"><tr><th scope="col">Date</th><th scope="col">Time</th><th scope="col">Level</th><th scope="col">Component</th><th scope="col">Message</th></tr></thead><tbody>
<tr id="log-0"><th scope="row">2021-07-08</th><td>17:39:34:246</td><td>INFO</td><td>CPAMain.detectFrontendLanguageIfNecessary</td><td>Language C detected and set for analysis</td></tr>
<tr id="log-1"><th scope="row">2021-07-08</th><td>17:39:34:264</td><td>INFO</td><td>ResourceLimitChecker.fromConfiguration</td><td>Using the following resource limits: CPU-time limit of 900s</td></tr>
<tr id="log-2"><th scope="row">2021-07-08</th><td>17:39:34:325</td><td>INFO</td><td>CPAchecker.run</td><td>CPAchecker 2.0.1-svn / predicateAnalysis-faultlocalization-maxsat (OpenJDK 64-Bit Server VM 15.0.2) started</td></tr>
<tr id="log-3"><th scope="row">2021-07-08</th><td>17:39:34:351</td><td>INFO</td><td>CPAchecker.parse</td><td>Parsing CFA from file(s) &quot;test/bs2.i&quot;</td></tr>
<tr id="log-4"><th scope="row">2021-07-08</th><td>17:39:35:540</td><td>INFO</td><td>PredicateCPA<br>PredicateCPA.&lt;init&gt;</td><td>Using predicate analysis with MathSAT5 version 5.6.6 (218275631c24) (Apr 23 2021 08:35:29, gmp 6.1.2, gcc 7.5.0, 64-bit, reentrant) and JFactory 1.21.</td></tr>
<tr id="log-5"><th scope="row">2021-07-08</th><td>17:39:35:633</td><td>INFO</td><td>PredicateCPA<br>PredicateCPARefiner.&lt;init&gt;</td><td>Using refinement for predicate analysis with PredicateAbstractionRefinementStrategy strategy.</td></tr>
<tr id="log-6"><th scope="row">2021-07-08</th><td>17:39:35:656</td><td>INFO</td><td>CPAchecker.runAlgorithm</td><td>Starting analysis ...</td></tr>
<tr id="log-7"><th scope="row">2021-07-08</th><td>17:39:36:235</td><td>INFO</td><td>FaultLocalizationWithTraceFormula.run</td><td>Starting fault localization...</td></tr>
<tr id="log-8"><th scope="row">2021-07-08</th><td>17:39:36:235</td><td>INFO</td><td>FaultLocalizationWithTraceFormula.run</td><td>Find explanations for fault #1</td></tr>
<tr id="log-9"><th scope="row">2021-07-08</th><td>17:39:39:511</td><td>INFO</td><td>FaultLocalizationWithTraceFormula.runAlgorithm</td><td>Running ModifiedMaxSatAlgorithm:<br>Error suspected on line(s): [214, 215, 216, 217, 218, 219, 840] and 841 (Score: 100).<br>        FIX: Try to change the assigned value of &quot;__cil_tmp12&quot; in &quot;__cil_tmp12 = __cil_tmp11 != __cil_tmp7;&quot; to another value. (0.0%)<br>        FIX: Try to change the assigned value of &quot;__cil_tmp1&quot; in &quot;__cil_tmp1 = (const struct list_head *)(&amp;gl_list);&quot; to another value. (0.0%)<br>        FIX: The function call &quot;inspect(__cil_tmp1)&quot; may have unwanted side effects or a wrong return value. (0.0%)<br>  RANK_INFO: Score based on edge type(s). (100.0%)<br>  RANK_INFO: This set has a size of 8. (100.0%)<br>  RANK_INFO: Sorted by overall occurrence in all faults. (100.0%)<br>  RANK_INFO: This line is 1 line(s) away from the error location (100.0%)<br>  RANK_INFO: This fault is 2 execution step(s) away from the error location. (100.0%)</td></tr>
<tr id="log-10"><th scope="row">2021-07-08</th><td>17:39:39:511</td><td>INFO</td><td>FaultLocalizationWithTraceFormula.run</td><td>Stopping fault localization...</td></tr>
<tr id="log-11"><th scope="row">2021-07-08</th><td>17:39:39:511</td><td>INFO</td><td>CPAchecker.runAlgorithm</td><td>Stopping analysis ...</td></tr>
</tbody></table>
      </div>
      <div class="fileContent content" ng-show="tabIsSet(5)" ng-class="{active: tabIsSet(5)}">
<table  id="statistics_table" class="display" style="width:100%;padding: 10px" class="table table-bordered"><thead class="thead-light"><tr><th scope="col">Statistics Name</th><th scope="col">Statistics Value</th scope="col"><th>Additional Value</th></tr></thead><tbody>
<tr class="table_head" id="statistics-1"><th>PredicateCPA statistics</th><th></th><th></th></tr><tr id="statistics-3"><td>Number of abstractions</td><td>            11 </td><td>1% of all post computations</td></tr>
<tr id="statistics-5"><td>	  Times abstraction was reused</td><td>    0</td><td></td></tr>
<tr id="statistics-7"><td>	  Because of function entry/exit</td><td>  0 </td><td>0%</td></tr>
<tr id="statistics-9"><td>	  Because of loop head</td><td>            11 </td><td>100%</td></tr>
<tr id="statistics-11"><td>	  Because of join nodes</td><td>           0 </td><td>0%</td></tr>
<tr id="statistics-13"><td>	  Because of threshold</td><td>            0 </td><td>0%</td></tr>
<tr id="statistics-15"><td>	  Because of target state</td><td>         0 </td><td>0%</td></tr>
<tr id="statistics-17"><td>	  Times precision was empty</td><td>       6 </td><td>55%</td></tr>
<tr id="statistics-19"><td>	  Times precision was {false}</td><td>     3 </td><td>27%</td></tr>
<tr id="statistics-21"><td>	  Times result was cached</td><td>         0 </td><td>0%</td></tr>
<tr id="statistics-23"><td>	  Times cartesian abs was used</td><td>    0 </td><td>0%</td></tr>
<tr id="statistics-25"><td>	  Times boolean abs was used</td><td>      2 </td><td>18%</td></tr>
<tr id="statistics-27"><td>	  Times result was &#39;false&#39;</td><td>        2 </td><td>18%</td></tr>
<tr id="statistics-29"><td>Number of strengthen sat checks</td><td>   0</td><td></td></tr>
<tr id="statistics-31"><td>Number of coverage checks</td><td>         6</td><td></td></tr>
<tr id="statistics-33"><td>	  BDD entailment checks</td><td>           6</td><td></td></tr>
<tr id="statistics-35"><td>Number of SMT sat checks</td><td>          0</td><td></td></tr>
<tr id="statistics-37"><td>	  trivial</td><td>                         0</td><td></td></tr>
<tr id="statistics-39"><td>	  cached</td><td>                          0</td><td></td></tr>
<tr id="statistics-42"><td>Max ABE block size</td><td>                       188</td><td></td></tr>
<tr id="statistics-44"><td>Avg ABE block size</td><td>                                97.09 </td><td>sum: 1068, count: 11, min: 5, max: 188</td></tr>
<tr id="statistics-46"><td>Number of predicates discovered</td><td>          19</td><td></td></tr>
<tr id="statistics-48"><td>Number of abstraction locations</td><td>          2</td><td></td></tr>
<tr id="statistics-50"><td>Max number of predicates per location</td><td>    2</td><td></td></tr>
<tr id="statistics-52"><td>Avg number of predicates per location</td><td>    1</td><td></td></tr>
<tr id="statistics-54"><td>Total predicates per abstraction</td><td>         7</td><td></td></tr>
<tr id="statistics-56"><td>Max number of predicates per abstraction</td><td> 2</td><td></td></tr>
<tr id="statistics-58"><td>Avg number of predicates per abstraction</td><td> 1.40</td><td></td></tr>
<tr id="statistics-60"><td>Number of irrelevant predicates</td><td>          3 </td><td>43%</td></tr>
<tr id="statistics-62"><td>Number of preds handled by boolean abs</td><td>   4 </td><td>57%</td></tr>
<tr id="statistics-64"><td>	  Total number of models for allsat</td><td>      2</td><td></td></tr>
<tr id="statistics-66"><td>	  Max number of models for allsat</td><td>        1</td><td></td></tr>
<tr id="statistics-68"><td>	  Avg number of models for allsat</td><td>        1.00</td><td></td></tr>
<tr id="statistics-71"><td>Time for post operator</td><td>                                0.129s</td><td></td></tr>
<tr id="statistics-73"><td>	  Time for path formula creation</td><td>                      0.124s</td><td></td></tr>
<tr id="statistics-75"><td>Time for strengthen operator</td><td>                          0.006s</td><td></td></tr>
<tr id="statistics-77"><td>Time for prec operator</td><td>                                0.053s</td><td></td></tr>
<tr id="statistics-79"><td>	  Time for abstraction</td><td>                  0.047s </td><td>Max:     0.019s, Count: 11</td></tr>
<tr id="statistics-81"><td>		    Boolean abstraction</td><td>                 0.007s</td><td></td></tr>
<tr id="statistics-83"><td>		    Solving time</td><td>                        0.026s </td><td>Max:     0.015s</td></tr>
<tr id="statistics-85"><td>		    Model enumeration time</td><td>              0.001s</td><td></td></tr>
<tr id="statistics-87"><td>		    Time for BDD construction</td><td>           0.001s </td><td>Max:     0.001s</td></tr>
<tr id="statistics-89"><td>Time for coverage checks</td><td>                              0.007s</td><td></td></tr>
<tr id="statistics-91"><td>	  Time for BDD entailment checks</td><td>                      0.007s</td><td></td></tr>
<tr id="statistics-93"><td>Total time for SMT solver (w/o itp)</td><td>     0.027s</td><td></td></tr>
<tr id="statistics-96"><td>Number of path formula cache hits</td><td>   496 </td><td>49%</td></tr>
<tr id="statistics-99"><td>Inside post operator</td><td>                  </td><td></td></tr>
<tr id="statistics-101"><td>	  Inside path formula creation</td><td>        </td><td></td></tr>
<tr id="statistics-103"><td>		    Time for path formula computation</td><td>     0.148s</td><td></td></tr>
<tr id="statistics-106"><td>Total number of created targets for pointer analysis</td><td> 0</td><td></td></tr>
<tr id="statistics-110"><td>Number of BDD nodes</td><td>                               203</td><td></td></tr>
<tr id="statistics-112"><td>Size of BDD node table</td><td>                            182561</td><td></td></tr>
<tr id="statistics-114"><td>Size of BDD cache</td><td>                                 18257</td><td></td></tr>
<tr id="statistics-116"><td>Size of BDD node cleanup queue</td><td>                    0.00 </td><td>sum: 0, count: 114, min: 0, max: 0</td></tr>
<tr id="statistics-118"><td>Time for BDD node cleanup</td><td>                             0.000s</td><td></td></tr>
<tr id="statistics-120"><td>Time for BDD garbage collection</td><td>                       0.000s </td><td>in 0 runs</td></tr>
<tr class="table_head" id="statistics-123"><th>KeyValue statistics</th><th></th><th></th></tr><tr id="statistics-125"><td>Init. function predicates</td><td>                         0</td><td></td></tr>
<tr id="statistics-127"><td>Init. global predicates</td><td>                           0</td><td></td></tr>
<tr id="statistics-129"><td>Init. location predicates</td><td>                         0</td><td></td></tr>
<tr class="table_head" id="statistics-132"><th>Invariant Generation statistics</th><th></th><th></th></tr><tr class="table_head" id="statistics-135"><th>AutomatonAnalysis (AssertionAutomaton) statistics</th><th></th><th></th></tr><tr id="statistics-137"><td>Number of states</td><td>                                  1</td><td></td></tr>
<tr id="statistics-139"><td>Total time for successor computation</td><td>                  0.008s</td><td></td></tr>
<tr id="statistics-141"><td>Automaton transfers with branching</td><td>                0</td><td></td></tr>
<tr id="statistics-143"><td>Automaton transfer successors</td><td>                     1.00 </td><td>sum: 734, count: 734, min: 1, max: 1 [1 x 734]</td></tr>
<tr id="statistics-145"><td>Number of states with assumption transitions</td><td>      0</td><td></td></tr>
<tr class="table_head" id="statistics-148"><th>AutomatonAnalysis (ErrorLabelAutomaton) statistics</th><th></th><th></th></tr><tr id="statistics-150"><td>Number of states</td><td>                                  1</td><td></td></tr>
<tr id="statistics-152"><td>Total time for successor computation</td><td>                  0.005s</td><td></td></tr>
<tr id="statistics-154"><td>Automaton transfers with branching</td><td>                0</td><td></td></tr>
<tr id="statistics-156"><td>Automaton transfer successors</td><td>                     1.00 </td><td>sum: 734, count: 734, min: 1, max: 1 [1 x 734]</td></tr>
<tr id="statistics-158"><td>Number of states with assumption transitions</td><td>      0</td><td></td></tr>
<tr class="table_head" id="statistics-161"><th>AutomatonAnalysis (TerminatingFunctions) statistics</th><th></th><th></th></tr><tr id="statistics-163"><td>Number of states</td><td>                                  1</td><td></td></tr>
<tr id="statistics-165"><td>Total time for successor computation</td><td>                  0.004s</td><td></td></tr>
<tr id="statistics-167"><td>Automaton transfers with branching</td><td>                0</td><td></td></tr>
<tr id="statistics-169"><td>Automaton transfer successors</td><td>                     1.00 </td><td>sum: 731, count: 734, min: 0, max: 1 [0 x 3, 1 x 731]</td></tr>
<tr id="statistics-171"><td>Number of states with assumption transitions</td><td>      0</td><td></td></tr>
<tr class="table_head" id="statistics-174"><th>FaultLocalizationWithTraceFormula statistics</th><th></th><th></th></tr><tr id="statistics-176"><td>Total time for fault localization</td><td>                     3.278s</td><td></td></tr>
<tr class="table_head" id="statistics-179"><th>CPA algorithm statistics</th><th></th><th></th></tr><tr id="statistics-181"><td>Number of iterations</td><td>            152</td><td></td></tr>
<tr id="statistics-183"><td>Max size of waitlist</td><td>            2</td><td></td></tr>
<tr id="statistics-185"><td>Average size of waitlist</td><td>        1</td><td></td></tr>
<tr id="statistics-187"><td>ReversePostorderSortedWaitlist</td><td>                    0.00 </td><td>sum: 0, count: 130, min: 0, max: 0</td></tr>
<tr id="statistics-189"><td>CallstackSortedWaitlist</td><td>                           13.33 </td><td>sum: 40, count: 3, min: 6, max: 22</td></tr>
<tr id="statistics-191"><td>Number of computed successors</td><td>   160</td><td></td></tr>
<tr id="statistics-193"><td>Max successors for one state</td><td>    2</td><td></td></tr>
<tr id="statistics-195"><td>Number of times merged</td><td>          0</td><td></td></tr>
<tr id="statistics-197"><td>Number of times stopped</td><td>         3</td><td></td></tr>
<tr id="statistics-199"><td>Number of times breaked</td><td>         3</td><td></td></tr>
<tr id="statistics-202"><td>Total time for CPA algorithm</td><td>         0.290s </td><td>Max:     0.190s</td></tr>
<tr id="statistics-204"><td>	  Time for choose from waitlist</td><td>      0.001s</td><td></td></tr>
<tr id="statistics-206"><td>	  Time for precision adjustment</td><td>      0.060s</td><td></td></tr>
<tr id="statistics-208"><td>	  Time for transfer relation</td><td>         0.212s</td><td></td></tr>
<tr id="statistics-210"><td>	  Time for merge operator</td><td>            0.008s</td><td></td></tr>
<tr id="statistics-212"><td>	  Time for stop operator</td><td>             0.004s</td><td></td></tr>
<tr id="statistics-214"><td>	  Time for adding to reached set</td><td>     0.003s</td><td></td></tr>
<tr class="table_head" id="statistics-217"><th>Static Predicate Refiner statistics</th><th></th><th></th></tr><tr id="statistics-219"><td>Number of predicates found statically</td><td>                   16 </td><td>count: 1, min: 16, max: 16, avg: 16.00</td></tr>
<tr id="statistics-222"><td>Total time for static refinement</td><td>                      0.040s</td><td></td></tr>
<tr id="statistics-224"><td>	  Time for path feasibility check</td><td>                     0.005s</td><td></td></tr>
<tr id="statistics-226"><td>	  Time for predicate extraction from CFA</td><td>              0.023s</td><td></td></tr>
<tr id="statistics-228"><td>	  Time for ARG update</td><td>                                 0.008s</td><td></td></tr>
<tr class="table_head" id="statistics-231"><th>PredicateCPARefiner statistics</th><th></th><th></th></tr><tr id="statistics-233"><td>Number of predicate refinements</td><td>                   2</td><td></td></tr>
<tr id="statistics-235"><td>Avg. length of target path (in blocks)</td><td>            2.00 </td><td>sum: 4, count: 2, min: 2, max: 2</td></tr>
<tr id="statistics-237"><td>Number of infeasible sliced prefixes</td><td>                     0 </td><td>count: 0, min: 0, max: 0, avg: 0.00</td></tr>
<tr id="statistics-240"><td>Time for refinement</td><td>                                   0.234s</td><td></td></tr>
<tr id="statistics-242"><td>	  Counterexample analysis</td><td>                             0.093s </td><td>Max:     0.060s, Calls: 3</td></tr>
<tr id="statistics-244"><td>		    Refinement sat check</td><td>                              0.074s</td><td></td></tr>
<tr id="statistics-246"><td>		    Interpolant computation</td><td>                           0.001s</td><td></td></tr>
<tr id="statistics-248"><td>	  Path-formulas extraction</td><td>                            0.000s</td><td></td></tr>
<tr id="statistics-250"><td>	  Error path post-processing</td><td>                          0.135s</td><td></td></tr>
<tr class="table_head" id="statistics-253"><th>Predicate-Abstraction Refiner statistics</th><th></th><th></th></tr><tr id="statistics-255"><td>	  Predicate creation</td><td>                                  0.002s</td><td></td></tr>
<tr id="statistics-257"><td>	  Precision update</td><td>                                    0.003s</td><td></td></tr>
<tr id="statistics-259"><td>	  ARG update</td><td>                                          0.002s</td><td></td></tr>
<tr id="statistics-262"><td>Length of refined path (in blocks)</td><td>                2.00 </td><td>sum: 2, count: 1, min: 2, max: 2</td></tr>
<tr id="statistics-264"><td>Number of affected states</td><td>                                1 </td><td>count: 1, min: 1, max: 1, avg: 1.00</td></tr>
<tr id="statistics-266"><td>Length (states) of path with itp &#39;true&#39;</td><td>                  0 </td><td>count: 1, min: 0, max: 0, avg: 0.00</td></tr>
<tr id="statistics-268"><td>Length (states) of path with itp non-trivial itp</td><td>         1 </td><td>count: 1, min: 1, max: 1, avg: 1.00</td></tr>
<tr id="statistics-270"><td>Length (states) of path with itp &#39;false&#39;</td><td>                 0 </td><td>count: 1, min: 0, max: 0, avg: 0.00</td></tr>
<tr id="statistics-272"><td>Different non-trivial interpolants along paths</td><td>           0 </td><td>count: 1, min: 0, max: 0, avg: 0.00</td></tr>
<tr id="statistics-274"><td>Equal non-trivial interpolants along paths</td><td>               0 </td><td>count: 1, min: 0, max: 0, avg: 0.00</td></tr>
<tr id="statistics-276"><td>Number of refs with location-based cutoff</td><td>                0</td><td></td></tr>
<tr class="table_head" id="statistics-279"><th>CEGAR algorithm statistics</th><th></th><th></th></tr><tr id="statistics-281"><td>Number of CEGAR refinements</td><td>          3</td><td></td></tr>
<tr id="statistics-283"><td>Number of successful refinements</td><td>     2</td><td></td></tr>
<tr id="statistics-285"><td>Number of failed refinements</td><td>         0</td><td></td></tr>
<tr id="statistics-287"><td>Max. size of reached set before ref.</td><td> 66</td><td></td></tr>
<tr id="statistics-289"><td>Max. size of reached set after ref.</td><td>  5</td><td></td></tr>
<tr id="statistics-291"><td>Avg. size of reached set before ref.</td><td> 54.00</td><td></td></tr>
<tr id="statistics-293"><td>Avg. size of reached set after ref.</td><td>  3.00</td><td></td></tr>
<tr id="statistics-296"><td>Total time for CEGAR algorithm</td><td>       0.572s</td><td></td></tr>
<tr id="statistics-298"><td>Time for refinements</td><td>                 0.281s</td><td></td></tr>
<tr id="statistics-300"><td>Average time for refinement</td><td>          0.093s</td><td></td></tr>
<tr id="statistics-302"><td>Max time for refinement</td><td>              0.196s</td><td></td></tr>
<tr class="table_head" id="statistics-305"><th>MAX-Sat algorithm statistics</th><th></th><th></th></tr><tr id="statistics-307"><td>Total time for max-sat algorithm</td><td>                      3.189s</td><td></td></tr>
<tr id="statistics-309"><td>Number of calls to sat solver</td><td>                          258</td><td></td></tr>
<tr id="statistics-311"><td>Number of calls saved through subset check</td><td>              40</td><td></td></tr>
<tr id="statistics-313"><td>	  Time for subset/supset check</td><td>                        0.001s</td><td></td></tr>
<tr class="table_head" id="statistics-316"><th>Code Coverage</th><th></th><th></th></tr><tr id="statistics-318"><td>	  Function coverage</td><td>      0.500</td><td></td></tr>
<tr id="statistics-320"><td>	  Visited lines</td><td>          230</td><td></td></tr>
<tr id="statistics-322"><td>	  Total lines</td><td>            554</td><td></td></tr>
<tr id="statistics-324"><td>	  Line coverage</td><td>          0.415</td><td></td></tr>
<tr id="statistics-326"><td>	  Visited conditions</td><td>     10</td><td></td></tr>
<tr id="statistics-328"><td>	  Total conditions</td><td>       48</td><td></td></tr>
<tr id="statistics-330"><td>	  Condition coverage</td><td>     0.208</td><td></td></tr>
<tr class="table_head" id="statistics-333"><th>CPAchecker general statistics</th><th></th><th></th></tr><tr id="statistics-335"><td>Number of program locations</td><td>                       673</td><td></td></tr>
<tr id="statistics-337"><td>Number of CFA edges (per node)</td><td>                         682 </td><td>count: 673, min: 0, max: 2, avg: 1.01</td></tr>
<tr id="statistics-339"><td>Number of relevant variables</td><td>                      198</td><td></td></tr>
<tr id="statistics-341"><td>Number of functions</td><td>                               14</td><td></td></tr>
<tr id="statistics-343"><td>Number of loops (and loop nodes)</td><td>                         6 </td><td>sum: 69, min: 4, max: 21, avg: 11.50</td></tr>
<tr id="statistics-345"><td>Size of reached set</td><td>             66</td><td></td></tr>
<tr id="statistics-347"><td>	  Number of reached locations</td><td>   62 </td><td>9%</td></tr>
<tr id="statistics-349"><td>		    Avg states per location</td><td>     1</td><td></td></tr>
<tr id="statistics-351"><td>		    Max states per location</td><td>     3 </td><td>at node N9</td></tr>
<tr id="statistics-353"><td>	  Number of reached functions</td><td>   7 </td><td>50%</td></tr>
<tr id="statistics-355"><td>	  Number of partitions</td><td>          66</td><td></td></tr>
<tr id="statistics-357"><td>		    Avg size of partitions</td><td>      1</td><td></td></tr>
<tr id="statistics-359"><td>		    Max size of partitions</td><td>      1</td><td></td></tr>
<tr id="statistics-361"><td>	  Number of target states</td><td>       1</td><td></td></tr>
<tr id="statistics-363"><td>	  Size of final wait list</td><td>       2</td><td></td></tr>
<tr id="statistics-366"><td>Time for analysis setup</td><td>          1.320s</td><td></td></tr>
<tr id="statistics-368"><td>	  Time for loading CPAs</td><td>          0.344s</td><td></td></tr>
<tr id="statistics-370"><td>	  Time for loading parser</td><td>        0.174s</td><td></td></tr>
<tr id="statistics-372"><td>	  Time for CFA construction</td><td>      0.709s</td><td></td></tr>
<tr id="statistics-374"><td>		    Time for parsing file(s)</td><td>     0.308s</td><td></td></tr>
<tr id="statistics-376"><td>		    Time for AST to CFA</td><td>          0.201s</td><td></td></tr>
<tr id="statistics-378"><td>		    Time for CFA sanity check</td><td>    0.000s</td><td></td></tr>
<tr id="statistics-380"><td>		    Time for post-processing</td><td>     0.154s</td><td></td></tr>
<tr id="statistics-382"><td>		    Time for CFA export</td><td>          0.612s</td><td></td></tr>
<tr id="statistics-384"><td>			      Time for function pointers resolving</td><td>            0.004s</td><td></td></tr>
<tr id="statistics-386"><td>				        Function calls via function pointers</td><td>             0 </td><td>count: 1, min: 0, max: 0, avg: 0.00</td></tr>
<tr id="statistics-388"><td>				        Instrumented function pointer calls</td><td>              0 </td><td>count: 1, min: 0, max: 0, avg: 0.00</td></tr>
<tr id="statistics-390"><td>				        Function calls with function pointer arguments</td><td>        0 </td><td>count: 1, min: 0, max: 0, avg: 0.00</td></tr>
<tr id="statistics-392"><td>				        Instrumented function pointer arguments</td><td>          0 </td><td>count: 1, min: 0, max: 0, avg: 0.00</td></tr>
<tr id="statistics-394"><td>			      Time for classifying variables</td><td>                  0.098s</td><td></td></tr>
<tr id="statistics-396"><td>				        Time for collecting variables</td><td>                 0.045s</td><td></td></tr>
<tr id="statistics-398"><td>				        Time for solving dependencies</td><td>                 0.000s</td><td></td></tr>
<tr id="statistics-400"><td>				        Time for building hierarchy</td><td>                   0.000s</td><td></td></tr>
<tr id="statistics-402"><td>				        Time for building classification</td><td>              0.031s</td><td></td></tr>
<tr id="statistics-404"><td>				        Time for exporting data</td><td>                       0.022s</td><td></td></tr>
<tr id="statistics-406"><td>Time for Analysis</td><td>                3.854s</td><td></td></tr>
<tr id="statistics-408"><td>CPU time for analysis</td><td>            6.350s</td><td></td></tr>
<tr id="statistics-410"><td>Time for analyzing result</td><td>        0.000s</td><td></td></tr>
<tr id="statistics-412"><td>Total time for CPAchecker</td><td>        5.175s</td><td></td></tr>
<tr id="statistics-414"><td>Total CPU time for CPAchecker</td><td>   11.310s</td><td></td></tr>
<tr id="statistics-416"><td>Time for statistics</td><td>              0.046s</td><td></td></tr>
<tr id="statistics-419"><td>Time for Garbage Collector</td><td>       0.043s </td><td>in 6 runs</td></tr>
<tr id="statistics-421"><td>Garbage Collector(s) used</td><td>    G1 Old Generation, G1 Young Generation</td><td></td></tr>
<tr id="statistics-423"><td>Used heap memory</td><td>                 51MB (    49 MiB) max;     38MB (    36 MiB) avg;     73MB (    69 MiB) peak</td><td></td></tr>
<tr id="statistics-425"><td>Used non-heap memory</td><td>             54MB (    52 MiB) max;     48MB (    46 MiB) avg;     55MB (    53 MiB) peak</td><td></td></tr>
<tr id="statistics-427"><td>Used in G1 Old Gen pool</td><td>          22MB (    21 MiB) max;     17MB (    17 MiB) avg;     22MB (    21 MiB) peak</td><td></td></tr>
<tr id="statistics-429"><td>Allocated heap memory</td><td>           228MB (   218 MiB) max;     91MB (    87 MiB) avg</td><td></td></tr>
<tr id="statistics-431"><td>Allocated non-heap memory</td><td>        57MB (    55 MiB) max;     51MB (    49 MiB) avg</td><td></td></tr>
<tr id="statistics-433"><td>Total process virtual memory</td><td>   7644MB (  7290 MiB) max;   7566MB (  7216 MiB) avg</td><td></td></tr>
</tbody></table>
      </div>
      <div class="fileContent content" ng-show="tabIsSet(6)" ng-class="{active: tabIsSet(6)}">
<table  id="config_table" class="display" style="width:100%;padding: 10px" class="table table-bordered"><thead class="thead-light"><tr><th scope="col">#</th><th scope="col">Configuration Name</th><th scope="col">Configuration Value</th></tr></thead><tbody>
<tr id="config-0"><th scope="row">1</th><td>analysis.algorithm.CEGAR </td><td> true</td></tr>
<tr id="config-1"><th scope="row">2</th><td>analysis.algorithm.faultLocalization.by_traceformula </td><td> true</td></tr>
<tr id="config-2"><th scope="row">3</th><td>analysis.alwaysStoreCounterexamples </td><td> true</td></tr>
<tr id="config-3"><th scope="row">4</th><td>analysis.name </td><td> predicateAnalysis-faultlocalization-maxsat</td></tr>
<tr id="config-4"><th scope="row">5</th><td>analysis.programNames </td><td> test/bs2.i</td></tr>
<tr id="config-5"><th scope="row">6</th><td>analysis.traversal.order </td><td> bfs</td></tr>
<tr id="config-6"><th scope="row">7</th><td>analysis.traversal.useCallstack </td><td> true</td></tr>
<tr id="config-7"><th scope="row">8</th><td>analysis.traversal.useReversePostorder </td><td> true</td></tr>
<tr id="config-8"><th scope="row">9</th><td>ARGCPA.cpa </td><td> cpa.composite.CompositeCPA</td></tr>
<tr id="config-9"><th scope="row">10</th><td>cegar.refiner </td><td> cpa.predicate.PredicateRefiner</td></tr>
<tr id="config-10"><th scope="row">11</th><td>CompositeCPA.cpas </td><td> cpa.location.LocationCPA, cpa.callstack.CallstackCPA, cpa.functionpointer.FunctionPointerCPA, cpa.predicate.PredicateCPA</td></tr>
<tr id="config-11"><th scope="row">12</th><td>cpa </td><td> cpa.arg.ARGCPA</td></tr>
<tr id="config-12"><th scope="row">13</th><td>cpa.composite.aggregateBasicBlocks </td><td> true</td></tr>
<tr id="config-13"><th scope="row">14</th><td>cpa.predicate.blk.alwaysAtFunctions </td><td> false</td></tr>
<tr id="config-14"><th scope="row">15</th><td>cpa.predicate.blk.alwaysAtLoops </td><td> true</td></tr>
<tr id="config-15"><th scope="row">16</th><td>cpa.predicate.refinement.performInitialStaticRefinement </td><td> true</td></tr>
<tr id="config-16"><th scope="row">17</th><td>faultLocalization.by_traceformula.type </td><td> MAXSAT</td></tr>
<tr id="config-17"><th scope="row">18</th><td>language </td><td> C</td></tr>
<tr id="config-18"><th scope="row">19</th><td>limits.time.cpu </td><td> 900s</td></tr>
<tr id="config-19"><th scope="row">20</th><td>log.level </td><td> INFO</td></tr>
<tr id="config-20"><th scope="row">21</th><td>specification </td><td> specification/default.spc</td></tr>
</tbody></table>
      </div>
    </section>
  </div>
  <div class="tool_tip" id="infoBox" style="z-index: 1; visibility: hidden;">
    <div id="insideBox">
      <span id="boxContent">&nbsp;</span>
    </div>
  </div>
</body>

</html>
