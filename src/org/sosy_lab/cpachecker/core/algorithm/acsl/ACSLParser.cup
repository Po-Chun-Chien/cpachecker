// This file is part of CPAchecker,
// a tool for configurable software verification:
// https://cpachecker.sosy-lab.org
//
// SPDX-FileCopyrightText: 2007-2020 Dirk Beyer <https://www.sosy-lab.org>
//
// SPDX-License-Identifier: Apache-2.0

package org.sosy_lab.cpachecker.core.algorithm.acsl;

import com.google.common.base.Charsets;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Multimap;
import com.google.common.io.Files;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.logging.Level;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.Symbol;
import java_cup.runtime.SymbolFactory;
import org.eclipse.cdt.core.dom.ast.IASTFileLocation;
import org.sosy_lab.common.log.LogManager;
import org.sosy_lab.cpachecker.cfa.CFA;
import org.sosy_lab.cpachecker.cfa.CFAWithACSLAnnotationLocations;
import org.sosy_lab.cpachecker.cfa.model.CFAEdge;
import org.sosy_lab.cpachecker.cfa.model.CFANode;
import org.sosy_lab.cpachecker.cfa.model.FunctionExitNode;
import org.sosy_lab.cpachecker.exceptions.CParserException;
import org.sosy_lab.cpachecker.util.Pair;

parser code {:

    private ACSLScanner scanner;
    private ACSLTermToCExpressionVisitor visitor;
    // Maps function names to behaviors declared in the function contract or in statement contracts
    // inside the function along with the node where the originating contract is annotated
    private final Multimap<String, Pair<Behavior, CFANode>> behaviors = LinkedHashMultimap.create();
    private CFAWithACSLAnnotationLocations cfa;
    private LogManager logger;
    private List<IASTFileLocation> orderedLocs;
    private final Set<Integer> annotationsToSkip = new HashSet<>();

    private ACSLParser(ACSLScanner pScanner, SymbolFactory sf, CFAWithACSLAnnotationLocations pCfa,
      List<IASTFileLocation> pOrderedLocs, LogManager pLogger) {
        super(pScanner, sf);
        scanner = pScanner;
        cfa = pCfa;
        logger = pLogger;
        visitor = new ACSLTermToCExpressionVisitor(cfa, logger);
        orderedLocs = pOrderedLocs;
    }

    public static CFA parseACSLAnnotations(List<String> files, CFA pCfa, LogManager logger) throws CParserException, IOException {
      Comparator<IASTFileLocation> locationComparator =
          (loc1, loc2) -> Integer.compare(loc1.getNodeOffset(), loc2.getNodeOffset());

      for (String filename : files) {
        Reader reader = new FileReader(new File(filename), StandardCharsets.UTF_8);
        ComplexSymbolFactory sf = new ComplexSymbolFactory();
        ACSLScanner scanner = new ACSLScanner(reader);
        if (pCfa instanceof CFAWithACSLAnnotationLocations) {
          CFAWithACSLAnnotationLocations cfaWithLocs = (CFAWithACSLAnnotationLocations) pCfa;

          List<IASTFileLocation> orderedLocs =
              new ArrayList<>(cfaWithLocs.getCommentPositions().keySet());
          orderedLocs.sort(locationComparator);
          orderedLocs = FluentIterable.from(orderedLocs).filter(x -> x.getFileName().equals(filename)).toList();
          ACSLParser parser = new ACSLParser(scanner, sf, cfaWithLocs, orderedLocs, logger);
          List<ACSLAnnotation> annotations = parser.parseACSLAnnotations();
          int skipped = 0;
          for (int i = 0; i < orderedLocs.size(); i++) {
            if (parser.shouldSkip(i)) {
              skipped++;
              continue;
            }
            if (annotations.get(i) instanceof ACSLAssertion) {
              handleAssertion(cfaWithLocs, orderedLocs.get(i), (ACSLAssertion) annotations.get(i));
            } else {
              cfaWithLocs
                  .getEdgesToAnnotations()
                  .put(
                      cfaWithLocs.getCommentPositions().get(orderedLocs.get(i)).getSecond(),
                      annotations.get(i));
            }
          }
          logger.log(Level.INFO, "Skipped " + skipped + " of " + annotations.size() + " annotations.");

          convertFunctionContractsIfNecessary(cfaWithLocs);

          adjustAnnotationLocations(cfaWithLocs, filename);
        } else {
          throw new AssertionError("No location information available!");
        }
      }

      return pCfa;
    }

    private static void convertFunctionContractsIfNecessary(
        CFAWithACSLAnnotationLocations cfaWithLocs) {
      ImmutableList<CFAEdge> keys =
          ImmutableList.copyOf(cfaWithLocs.getEdgesToAnnotations().keySet());
      for (CFAEdge edge : keys) {
        Collection<ACSLAnnotation> annotations =
            ImmutableList.copyOf(cfaWithLocs.getEdgesToAnnotations().get(edge));
        for (ACSLAnnotation annotation : annotations) {
          if (annotation instanceof FunctionContract) {
            if (edge.getPredecessor().getNumEnteringEdges() != 1
                || !edge.getPredecessor()
                    .getEnteringEdge(0)
                    .getDescription()
                    .equals("Function start dummy edge")) {
              StatementContract statementContract =
                  StatementContract.fromFunctionContract(
                      ImmutableList.of(), (FunctionContract) annotation);
              cfaWithLocs.getEdgesToAnnotations().remove(edge, annotation);
              cfaWithLocs.getEdgesToAnnotations().put(edge, statementContract);
            }
          }
        }
      }
    }

    /**
     * Add, move and remove ACSL annotations to, between and from CFAEdges as necessary to match
     * their semantics.
     *
     * @param cfaWithLocs A CFA holding the location information about the annotations.
     * @param currentFile Name of the file the annotations of which should be handled.
     */
    private static void adjustAnnotationLocations(CFAWithACSLAnnotationLocations cfaWithLocs, String currentFile) {
      ImmutableList<CFAEdge> keys = ImmutableList.copyOf(cfaWithLocs.getEdgesToAnnotations().keySet());
      Set<ACSLAnnotation> moved = new HashSet<>();
      for (CFAEdge key : keys) {
        if (key.getFileLocation().getFileName().equals(currentFile)) {
          Collection<ACSLAnnotation> currentAnnotations = cfaWithLocs.getEdgesToAnnotations().get(key);
          List<ACSLAnnotation> toRemove = new ArrayList<>();
          for (ACSLAnnotation annotation : currentAnnotations) {
            if (moved.contains(annotation)) {
              continue;
            }
            if (annotation instanceof FunctionContract) {
              if (handleFunctionContract(cfaWithLocs, key, (FunctionContract) annotation)) {
                toRemove.add(annotation);
              }
            } else if (annotation instanceof StatementContract) {
              if (handleStatementContract(cfaWithLocs, key, (StatementContract) annotation)) {
                toRemove.add(annotation);
              }
            } else if (annotation instanceof ACSLLoopAnnotation) {
              if (handleLoopAnnotation(cfaWithLocs, key, (ACSLLoopAnnotation) annotation)) {
                toRemove.add(annotation);
              }
            } else if (annotation instanceof ACSLAssertion) {
              // already handled
            } else {
              throw new AssertionError(
                  "Unknown annotation type for annotation\n" + annotation.toString());
            }
            moved.add(annotation);
          }
          cfaWithLocs.getEdgesToAnnotations().get(key).removeAll(toRemove);
        }
      }
    }

    private static boolean handleFunctionContract(
        CFAWithACSLAnnotationLocations cfaWithLocs, CFAEdge edge, FunctionContract annotation) {
      // Add function contracts to function exits as well because some clauses have to be
      // evaluated in the post-state
      FunctionExitNode exit =
          cfaWithLocs.getFunctionHead(edge.getSuccessor().getFunctionName()).getExitNode();
      for (int i = 0; i < exit.getNumEnteringEdges(); i++) {
        CFAEdge currentEdge = exit.getEnteringEdge(i);
        cfaWithLocs.getEdgesToAnnotations().put(currentEdge, annotation.getCopyForPostState());
      }
      // currently we always have to move function contracts since they get matched to
      // one edge too late
      assert edge.getPredecessor().getNumEnteringEdges() == 1;
      cfaWithLocs.getEdgesToAnnotations().put(edge.getPredecessor().getEnteringEdge(0), annotation.getCopyForPreState());
      return true;
    }

    private static boolean handleStatementContract(
        CFAWithACSLAnnotationLocations cfaWithLocs, CFAEdge edge, StatementContract annotation) {
      // requirements have to be fulfilled by all entering edges
      for (int i = 0; i < edge.getPredecessor().getNumEnteringEdges(); i++) {
        cfaWithLocs.getEdgesToAnnotations().put(edge.getPredecessor().getEnteringEdge(i), annotation.getCopyForPreState());
      }
      // Add statement contracts directly after the statement as well because some clauses have to
      // be evaluated in the post-state
      if (edge.getDescription().equals("for")) {
        while (edge.getSuccessor().getNumLeavingEdges() == 1) {
          edge = edge.getSuccessor().getLeavingEdge(0);
        }
        edge = edge.getSuccessor().getLeavingEdge(0);
        // edge is now "cond" or "!cond" edge of for-loop
      }
      int currentDepth = edge.getPredecessor().getStatementStackDepth();
      Queue<CFAEdge> waitlist = new ArrayDeque<>();
      for (int i = 0; i < edge.getPredecessor().getNumLeavingEdges(); i++) {
        waitlist.offer(edge.getPredecessor().getLeavingEdge(i));
      }
      boolean remove = true;
      Set<CFAEdge> reachedSet = new HashSet<>();
      while (!waitlist.isEmpty()) {
        CFAEdge currentEdge = waitlist.poll();
        reachedSet.add(currentEdge);
        CFANode successor = currentEdge.getSuccessor();
        if (successor.getStatementStackDepth() == currentDepth) {
          if (currentEdge == edge) {
            remove = false;
          } else if (!currentEdge.getSuccessor().equals(edge.getPredecessor())) {
            // we do not want to add the statement contract after a loop iteration, only after the
            // whole loop
            cfaWithLocs.getEdgesToAnnotations().put(currentEdge, annotation.getCopyForPostState());
          }
        } else {
          for (int i = 0; i < successor.getNumLeavingEdges(); i++) {
            if (!reachedSet.contains(successor.getLeavingEdge(i))) {
              waitlist.offer(successor.getLeavingEdge(i));
            }
          }
        }
      }
      return remove;
    }

    /**
     * Adds the given annotation to the correct edges in the CFA and signals to remove it from the
     * current one if necessary.
     *
     * @param cfaWithLocs A CFA holding location information about the annotation.
     * @param edge The edge on which the annotation was originally placed.
     * @param annotation The annotation to be handled.
     * @return true if the annotation should be removed from the current edge, false otherwise.
     */
    private static boolean handleLoopAnnotation(
        CFAWithACSLAnnotationLocations cfaWithLocs, CFAEdge edge, ACSLLoopAnnotation annotation) {
      CFANode successor = edge.getSuccessor();
      if (!successor.isLoopStart()) {
        if (edge.getDescription().equals("for")) {
          assert successor.getNumLeavingEdges() == 1;
          CFANode next = successor.getLeavingEdge(0).getSuccessor();
          for (int i = 0; i < next.getNumEnteringEdges(); i++) {
            cfaWithLocs.getEdgesToAnnotations().put(next.getEnteringEdge(i), annotation);
          }
          // loop invariant only has to hold after initilization, so remove it from here
          return true;
        } else {
          boolean isDoWhile = false;
          for (int i = 0; i < successor.getNumEnteringEdges(); i++) {
            if (successor.getEnteringEdge(i).getDescription().equals("do")) {
              isDoWhile = true;
              // loop invariant should also hold on first iteration
              cfaWithLocs.getEdgesToAnnotations().put(successor.getEnteringEdge(i), annotation);
              break;
            }
          }
          assert isDoWhile;
        }
      } else {
        assert edge.getDescription().equals("while");
        for (int i = 0; i < successor.getNumEnteringEdges(); i++) {
          CFAEdge currentEdge = successor.getEnteringEdge(i);
          if (currentEdge != edge) {
            cfaWithLocs.getEdgesToAnnotations().put(currentEdge, annotation);
          }
        }
      }
      // ACSL doesn't guarantee that a loop invariant still holds when the loop is left
      // but if such a thing is desired something akin to the following could be used:

      // LoopStructure loopStructure = cfaWithLocs.getLoopStructure().orElseThrow();
      // assert loopStructure.getAllLoopHeads().contains(key.getSuccessor());
      // Set<Loop> loops = loopStructure.getLoopsForLoopHead(key.getSuccessor());
      // for (Loop loop : loops) {
      //  for (CFAEdge edge : loop.getOutgoingEdges()) {
      //    // Loop invariant still has to hold after last iteration
      //    cfaWithLocs.getEdgesToAnnotations().put(edge, annotation);
      //  }
      // }
      return false;
    }

    /**
     * Adds the given assertion to the correct edges in the CFA.
     *
     * @param cfaWithLocs A CFA holding location information about the annotation.
     * @param loc The location at which the annotation was originally placed.
     * @param annotation The annotation to be handled.
     */
    private static void handleAssertion(
        CFAWithACSLAnnotationLocations cfaWithLocs, IASTFileLocation loc, ACSLAssertion annotation)
        throws IOException {
      CFAEdge prev = cfaWithLocs.getCommentPositions().get(loc).getFirst();
      CFAEdge next = cfaWithLocs.getCommentPositions().get(loc).getSecond();
      int stackDiff = prev.getPredecessor().getStatementStackDepth() - next.getPredecessor().getStatementStackDepth();
      if (stackDiff > 0) {
        // annotation is either placed at very end of block or directly after block
        String fileContent = Files.asCharSource(new File(loc.getFileName()), Charsets.UTF_8).read();
        String fileContentAfterAnnotation = fileContent.substring(loc.getNodeOffset() + loc.getNodeLength());
        int closingBraces = 0;
        while(fileContentAfterAnnotation.stripLeading().charAt(0) == '}') {
          closingBraces++;
          fileContentAfterAnnotation = fileContentAfterAnnotation.stripLeading().substring(1);
        }
        int seekedDepth = next.getPredecessor().getStatementStackDepth() + closingBraces;
        if (prev.getPredecessor().getStatementStackDepth() == seekedDepth) {
          cfaWithLocs.getEdgesToAnnotations().put(prev, annotation);
          return;
        }
        Deque<CFAEdge> waitlist = new ArrayDeque<>();
        Set<CFAEdge> reached = new HashSet<>();
        Set<CFAEdge> result = new HashSet<>();
        waitlist.add(prev);
        while (!waitlist.isEmpty()) {
          CFAEdge current = waitlist.poll();
          reached.add(current);
          if (current.getPredecessor().getStatementStackDepth() == seekedDepth) {
            for (int i = 0; i < current.getPredecessor().getNumLeavingEdges(); i++) {
              CFAEdge candidate = current.getPredecessor().getLeavingEdge(i);
              if (candidate != current) {
                result.add(candidate);
              }
            }
          } else if (current.getPredecessor().getStatementStackDepth() > seekedDepth) {
            for (int i = 0; i < current.getPredecessor().getNumEnteringEdges(); i++) {
              CFAEdge predEdge = current.getPredecessor().getEnteringEdge(i);
              if (!reached.contains(predEdge)) {
                waitlist.add(predEdge);
              }
            }
          }
        }
        for (CFAEdge edge : result) {
          cfaWithLocs.getEdgesToAnnotations().put(edge, annotation);
          if (prev.getSuccessor().getNumLeavingEdges() > 0
              && prev.getSuccessor().getLeavingEdge(0).getSuccessor().equals(edge.getSuccessor())) {
            // annotation is placed after if- or else-block
            cfaWithLocs.getEdgesToAnnotations().put(prev.getSuccessor().getLeavingEdge(0), annotation);
          }
        }
      } else {
        CFANode predecessor = next.getPredecessor();
        for (int i = 0; i < predecessor.getNumEnteringEdges(); i++) {
          CFAEdge currentEdge = predecessor.getEnteringEdge(i);
          while (currentEdge.getFileLocation().getNodeOffset()
              == next.getFileLocation().getNodeOffset()) {
            assert currentEdge.getPredecessor().getNumEnteringEdges() == 1;
            currentEdge = currentEdge.getPredecessor().getEnteringEdge(0);
          }
          cfaWithLocs.getEdgesToAnnotations().put(currentEdge, annotation);
        }
      }
    }

    public List<ACSLAnnotation> parseACSLAnnotations() throws CParserException {
      try {
        Symbol symbol = this.parse();
        if(symbol != null) {
            return (List<ACSLAnnotation>) symbol.value;
        } else {
            return ImmutableList.of();
        }
      } catch (Exception e) {
        throw new CParserException(e);
      }
    }

    public CFANode getCurrentNode() {
      return cfa.getCommentPositions()
          .get(orderedLocs.get(scanner.getCurrentAnnotation()))
          .getSecond()
          .getSuccessor();
    }

    public void putBehavior(String functionName, Pair<Behavior, CFANode> p) {
      behaviors.put(functionName, p);
    }

    public List<Behavior> getAllBehaviors(String functionName) {
      List<Behavior> result = new ArrayList<>();
      for (Pair<Behavior, CFANode> pair : behaviors.get(functionName)) {
        result.add(pair.getFirst());
      }
      return result;
    }

    public Behavior getBehavior(String functionName, String behaviorName, CFANode currentNode) {
      for (Pair<Behavior, CFANode> p : behaviors.get(functionName)) {
        Behavior b = p.getFirst();
        if (b.getName().equals(behaviorName)) {
          CFANode origin = p.getSecond();
          if (inSameScope(origin, currentNode)) {
            return b;
          }
        }
      }
      throw new AssertionError("Unknown behavior identifier: " + behaviorName);
    }

    private boolean inSameScope(CFANode oldNode, CFANode newNode) {
      if (newNode.getStatementStackDepth() < oldNode.getStatementStackDepth()) {
        return false;
      }
      return getInnermostScopeOf(oldNode).contains(newNode);
    }

    private Set<CFANode> getInnermostScopeOf(CFANode pNode) {
      Set<CFANode> inScope = new HashSet<>();
      Set<CFANode> borderNodes = new HashSet<>();
      Set<CFAEdge> initialWaitset = new HashSet<>();
      Queue<CFAEdge> waitlist = new ArrayDeque<>();
      int targetStatementStackDepth = pNode.getStatementStackDepth();
      if (targetStatementStackDepth <= 0) {
        // not inside a function
        return ImmutableSet.copyOf(cfa.getAllNodes());
      } else if (targetStatementStackDepth == 1) {
        // not inside a block statement
        return FluentIterable.from(cfa.getAllNodes())
            .filter(x -> x.getFunctionName().equals(pNode.getFunctionName()))
            .toSet();
      }

      for (int i = 0; i < pNode.getNumEnteringEdges(); i++) {
        CFANode prev = pNode.getEnteringEdge(i).getPredecessor();
        for (int j = 0; j < prev.getNumLeavingEdges(); j++) {
          initialWaitset.add(prev.getLeavingEdge(j));
        }
        borderNodes.add(prev);
      }
      waitlist.addAll(initialWaitset);

      while (!waitlist.isEmpty()) {
        CFAEdge currentEdge = waitlist.poll();
        CFANode successor = currentEdge.getSuccessor();
        if (inScope.contains(successor) || borderNodes.contains(successor)) {
          continue;
        }
        int currentStatementStackDepth = successor.getStatementStackDepth();
        if (currentStatementStackDepth < targetStatementStackDepth) {
          borderNodes.add(successor);
        } else {
          inScope.add(successor);
          for (int i = 0; i < successor.getNumLeavingEdges(); i++) {
            waitlist.add(successor.getLeavingEdge(i));
          }
        }
      }
      return inScope;
    }

    public List<IASTFileLocation> getLocs() {
      return orderedLocs;
    }

    public CFAWithACSLAnnotationLocations getCFA() {
      return cfa;
    }

    @Override
    public ACSLScanner getScanner() {
      return scanner;
    }

    public void checkIdentifier(Identifier i) {
      try {
        visitor.visit(i);
      } catch (AssertionError e) {
        annotationsToSkip.add(scanner.getCurrentAnnotation());
      }
    }

    public boolean shouldSkip(int i) {
      return annotationsToSkip.contains(i);
    }
:}

scan with {: return scanner.getNext(); :}

terminal TRUE, FALSE;
terminal LBRACKET, RBRACKET;
terminal AND, OR, IMP, EQV, XOR;
terminal NEG;
terminal EQ, NEQ, LEQ, GEQ, GT, LT;
terminal BAND, BOR, BIMP, BEQV, BXOR;
terminal BNEG, UPLUS, UMINUS, STAR, AMPERSAND;
terminal SIZEOF;
terminal PLUS, MINUS, TIMES, DIVIDE, MOD, LSHIFT, RSHIFT;
terminal LPAREN, RPAREN;
terminal SEMI;
terminal REQ, ENS, ASS;
terminal BigInteger LITERAL;
terminal String STRING_LITERAL;
terminal String IDENTIFIER;
terminal NEXTCONTRACT;
terminal LINVARIANT;
terminal ASSERT, CHECK;
terminal BEHAVIOR;
terminal COLON;
terminal QUESTION;
terminal PRED_START;
terminal FOR;
terminal COMMA;
terminal COMPLETE_BEHAVIORS, DISJOINT_BEHAVIORS;
terminal OLD;
terminal RETVAL;

non terminal List<ACSLAnnotation> annotations;
non terminal ACSLAnnotation annotation;
non terminal FunctionContract fcontract;
non terminal StatementContract scontract;
non terminal ACSLLoopAnnotation loopannotation;
non terminal ACSLAssertion assertion;
non terminal ContractBuilder clauses;
non terminal BehaviorBuilder behavior_body;
non terminal Collection<RequiresClause> req_clauses;
non terminal Collection<EnsuresClause> ens_clauses;
non terminal Collection<AssumesClause> ass_clauses;
non terminal Collection<Behavior> behaviors;
non terminal Collection<CompletenessClause> completeness_clauses;
non terminal RequiresClause req_clause;
non terminal EnsuresClause ens_clause;
non terminal AssumesClause ass_clause;
non terminal LoopInvariant loop_clauses;
non terminal CompletenessClause completeness_clause;
non terminal Map<List<Behavior>, LoopInvariant> loop_behaviors;
non terminal List<String> behavior_identifiers, identifiers;
non terminal Behavior behavior;
non terminal ACSLPredicate predicate;
non terminal ACSLPredicate asc_comp_predicate, desc_comp_predicate, eq_chain, asc_base, desc_base;
non terminal ACSLTerm term;
non terminal BinaryOperator asc_rel_op, desc_rel_op, log_op, arith_op, bit_op;
non terminal UnaryOperator unary_op;

precedence right QUESTION;
precedence left EQV;
precedence right IMP;
precedence left OR;
precedence left XOR;
precedence left AND;
precedence left BEQV;
precedence right BIMP;
precedence left BOR;
precedence left BXOR;
precedence left BAND;
precedence nonassoc EQ, NEQ;
precedence nonassoc LEQ, GEQ, GT, LT;
precedence left LSHIFT, RSHIFT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right NEG, BNEG, UPLUS, UMINUS, STAR, AMPERSAND, RPAREN;
precedence right LBRACKET;

annotations ::= annotations:as annotation:a {: assert !a.getCompletenessPredicate().equals(ACSLPredicate.getFalse());
                                               as.add(a); RESULT = as; :}
            | /* nothing */                 {: RESULT = new ArrayList<>(); :};
annotation ::= fcontract:f {: RESULT = f; :}
            | scontract:s           {:  RESULT = s; :}
            | loopannotation:l {: RESULT = l; :}
            | assertion:a {: RESULT = a; :};
assertion ::= NEXTCONTRACT ASSERT predicate:p SEMI                        {: RESULT = new ACSLAssertion(ACSLAssertion.AssertionKind.ASSERT, p); :}
            | NEXTCONTRACT behavior_identifiers:i ASSERT predicate:p SEMI {: List<Behavior> enclosingBehaviors = new ArrayList<>();
                                                                             CFANode node = parser.getCurrentNode();
                                                                             for(String id : i) { enclosingBehaviors.add(parser.getBehavior(node.getFunctionName(), id, node)); }
                                                                             RESULT = new ACSLAssertion(ACSLAssertion.AssertionKind.ASSERT, enclosingBehaviors, p); :}
            | NEXTCONTRACT CHECK predicate:p SEMI                         {: RESULT = new ACSLAssertion(ACSLAssertion.AssertionKind.CHECK, p); :}
            | NEXTCONTRACT behavior_identifiers:i CHECK predicate:p SEMI  {: List<Behavior> enclosingBehaviors = new ArrayList<>();
                                                                             CFANode node = parser.getCurrentNode();
                                                                             for(String id : i) { enclosingBehaviors.add(parser.getBehavior(node.getFunctionName(), id, node)); }
                                                                             RESULT = new ACSLAssertion(ACSLAssertion.AssertionKind.CHECK, enclosingBehaviors, p); :};
loopannotation ::= NEXTCONTRACT loop_clauses:c loop_behaviors:b {: RESULT = new ACSLLoopAnnotation(c, b); :}
                | NEXTCONTRACT loop_behaviors:b                 {: RESULT = new ACSLLoopAnnotation(b); :}
                | NEXTCONTRACT loop_clauses:c                   {: RESULT = new ACSLLoopAnnotation(c); :};
fcontract ::= NEXTCONTRACT clauses:c                {: RESULT = c.build(); :};
scontract ::= NEXTCONTRACT behavior_identifiers:i clauses:c
                                                    {: List<Behavior> enclosingBehaviors = new ArrayList<>();
                                                       CFANode node = parser.getCurrentNode();
                                                       for(String id : i) { enclosingBehaviors.add(parser.getBehavior(node.getFunctionName(), id, node)); }
                                                       RESULT = StatementContract.fromFunctionContract(enclosingBehaviors, c.build()); :};
behavior_identifiers ::= FOR identifiers:i COLON PRED_START {: RESULT = i; :};
identifiers ::= identifiers:is COMMA IDENTIFIER:i    {: is.add(i); RESULT = is; :}
            | IDENTIFIER:i      {: List<String> identifiers = new ArrayList<>();
                                   identifiers.add(i); RESULT = identifiers; :};
loop_behaviors ::= loop_behaviors:b behavior_identifiers:i loop_clauses:c   {: List<Behavior> holdsFor = new ArrayList<>(i.size());
                                                                               CFANode node = parser.getCurrentNode();
                                                                               for(String id : i) {
                                                                               holdsFor.add(parser.getBehavior(node.getFunctionName(), id, node)); }
                                                                               b.put(holdsFor, c); RESULT = b; :}
                | behavior_identifiers:i loop_clauses:c                     {: Map<List<Behavior>, LoopInvariant> loopBehaviors = new HashMap<>();
                                                                               List<Behavior> holdsFor = new ArrayList<>(i.size());
                                                                               CFANode node = parser.getCurrentNode();
                                                                               for(String id : i) {
                                                                               holdsFor.add(parser.getBehavior(node.getFunctionName(), id, node)); }
                                                                               loopBehaviors.put(holdsFor, c); RESULT = loopBehaviors; :};
loop_clauses ::= loop_clauses:c LINVARIANT predicate:p SEMI {: RESULT = c.and(p); :}
            | LINVARIANT predicate:p SEMI                   {: assert p.isAllowedIn(LoopInvariant.class); RESULT = new LoopInvariant(p); :};
clauses ::= req_clauses:r ens_clauses:e behaviors:b completeness_clauses:c {: RESULT = new ContractBuilder().addAll(r).addAll(e).addAll(b).addAll(c); :};
req_clauses ::=
            req_clauses:c req_clause:r              {: c.add(r); RESULT = c; :}
            | /* nothing */                         {: RESULT = new HashSet<>(); :};
ens_clauses ::=
            ens_clauses:c ens_clause:e              {: c.add(e); RESULT = c; :}
            | /* nothing */                         {: RESULT = new HashSet<>(); :};
behaviors ::=
            behaviors:c behavior:b                  {: c.add(b); RESULT = c; :}
            | /* nothing */                         {: RESULT = new HashSet<>(); :};
behavior ::= BEHAVIOR IDENTIFIER:i COLON PRED_START behavior_body:bb   {: bb.setBehaviorName(i);
                                                                          Behavior b = bb.build();
                                                                          CFANode node = parser.getCurrentNode();
                                                                          parser.putBehavior(node.getFunctionName(), Pair.of(b, node)); RESULT = b; :};
completeness_clauses ::= completeness_clauses:cs completeness_clause:c  {: cs.add(c); RESULT = cs; :}
                        | /* nothing */                                 {: RESULT = new HashSet<>(); :};
completeness_clause ::= COMPLETE_BEHAVIORS identifiers:i SEMI {: List<Behavior> behaviors = new ArrayList<>(i.size());
                                                                 CFANode node = parser.getCurrentNode();
                                                               for (String id : i) { behaviors.add(parser.getBehavior(node.getFunctionName(), id, node)); }
                                                               RESULT = new CompletenessClause(behaviors, CompletenessClause.RelationKind.COMPLETE); :}
                        | COMPLETE_BEHAVIORS SEMI {: RESULT = new CompletenessClause(
                        ImmutableList.copyOf((parser.getAllBehaviors(parser.getCurrentNode().getFunctionName()))), CompletenessClause.RelationKind.COMPLETE); :}
                        | DISJOINT_BEHAVIORS identifiers:i SEMI {: List<Behavior> behaviors = new ArrayList<>(i.size());
                                                                   CFANode node = parser.getCurrentNode();
                                                               for (String id : i) { behaviors.add(parser.getBehavior(node.getFunctionName(), id, node)); }
                                                               RESULT = new CompletenessClause(behaviors, CompletenessClause.RelationKind.DISJOINT); :}
                        | DISJOINT_BEHAVIORS SEMI {: RESULT = new CompletenessClause(
                        ImmutableList.copyOf((parser.getAllBehaviors(parser.getCurrentNode().getFunctionName()))), CompletenessClause.RelationKind.DISJOINT); :};
behavior_body ::= ass_clauses:a req_clauses:r ens_clauses:e
                                                    {: RESULT = new BehaviorBuilder().addAll(a).addAll(r).addAll(e); :};
ass_clauses ::=
            ass_clauses:c ass_clause:a              {: c.add(a); RESULT = c; :}
            | /* nothing */                         {: RESULT = new HashSet<>(); :};
req_clause ::= REQ predicate:p SEMI {: assert p.isAllowedIn(RequiresClause.class); RESULT = new RequiresClause(p); :};
ens_clause ::= ENS predicate:p SEMI {: assert p.isAllowedIn(EnsuresClause.class); RESULT = new EnsuresClause(p); :};
ass_clause ::= ASS predicate:p SEMI {: assert p.isAllowedIn(AssumesClause.class); RESULT = new AssumesClause(p); :};
predicate ::= PRED_START TRUE                                       {: RESULT = ACSLPredicate.getTrue(); :}
        | PRED_START FALSE                                          {: RESULT = ACSLPredicate.getFalse(); :}
	| predicate:p1 log_op:op predicate:p2                       {: RESULT = new ACSLLogicalPredicate(p1, p2, op); :}
	| PRED_START term:t1 NEQ term:t2                            {: RESULT = new ACSLSimplePredicate(new ACSLBinaryTerm(t1, t2, BinaryOperator.NEQ)); :}
	| PRED_START eq_chain:ec                                    {: RESULT = ec; :}
	| PRED_START asc_comp_predicate:p                           {: RESULT = p; :}
	| PRED_START desc_comp_predicate:p                          {: RESULT = p; :}
	| PRED_START NEG predicate:p                                {: RESULT = p.negate(); :} %prec NEG
	| PRED_START LPAREN predicate:p RPAREN                      {: RESULT = p; :}
	| predicate:p1 QUESTION predicate:p2 COLON predicate:p3     {: RESULT = new TernaryCondition(p1, p2, p3); :}
	| PRED_START OLD LPAREN predicate:p RPAREN                  {: RESULT = new At(p, ACSLDefaultLabel.OLD); :};
asc_comp_predicate ::= asc_comp_predicate:p asc_rel_op:op term:t    {: ACSLTerm innerLeft;
                                                                       if (p instanceof ACSLSimplePredicate) {
                                                                        innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) p).getTerm()).getRight();
                                                                       } else {
                                                                        innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) ((ACSLLogicalPredicate) p).
                                                                           getRight()).getTerm()).getRight();
                                                                       }
                                                                       ACSLPredicate right = new ACSLSimplePredicate(new ACSLBinaryTerm(innerLeft, t, op));
                                                                       RESULT = new ACSLLogicalPredicate(p, right, BinaryOperator.AND);  :}
        | asc_comp_predicate:p EQ term:t                            {: ACSLTerm innerLeft;
                                                                      if (p instanceof ACSLSimplePredicate) {
                                                                       innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) p).getTerm()).getRight();
                                                                      } else {
                                                                       innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) ((ACSLLogicalPredicate) p).
                                                                          getRight()).getTerm()).getRight();
                                                                      }
                                                                      ACSLPredicate right = new ACSLSimplePredicate(new ACSLBinaryTerm(innerLeft, t, BinaryOperator.EQ));
                                                                      RESULT = new ACSLLogicalPredicate(p, right, BinaryOperator.AND); :}
        | asc_base:ab                      {: RESULT = ab; :}
        | eq_chain:ec asc_rel_op:op term:t {: ACSLTerm innerLeft;
                                              if (ec instanceof ACSLSimplePredicate) {
                                                innerLeft = ((ACSLBinaryTerm)((ACSLSimplePredicate) ec).getTerm()).getRight();
                                              } else {
                                                innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) ((ACSLLogicalPredicate) ec).getRight()).getTerm()).
                                                   getRight();
                                              }
                                              ACSLPredicate right = new ACSLSimplePredicate(new ACSLBinaryTerm(innerLeft, t, op));
                                              RESULT = new ACSLLogicalPredicate(ec, right, BinaryOperator.AND); :};
desc_comp_predicate ::= desc_comp_predicate:p desc_rel_op:op term:t {: ACSLTerm innerLeft;
                                                                       if (p instanceof ACSLSimplePredicate) {
                                                                        innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) p).getTerm()).getRight();
                                                                       } else {
                                                                        innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) ((ACSLLogicalPredicate) p).
                                                                           getRight()).getTerm()).getRight();
                                                                       }
                                                                       ACSLPredicate right = new ACSLSimplePredicate(new ACSLBinaryTerm(innerLeft, t, op));
                                                                       RESULT = new ACSLLogicalPredicate(p, right, BinaryOperator.AND); :}
        | desc_comp_predicate:p EQ term:t                             {: ACSLTerm innerLeft;
                                                                       if (p instanceof ACSLSimplePredicate) {
                                                                        innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) p).getTerm()).getRight();
                                                                       } else {
                                                                        innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) ((ACSLLogicalPredicate) p).
                                                                           getRight()).getTerm()).getRight();
                                                                       }
                                                                       ACSLPredicate right = new ACSLSimplePredicate(new ACSLBinaryTerm(innerLeft, t, BinaryOperator.EQ));
                                                                       RESULT = new ACSLLogicalPredicate(p, right, BinaryOperator.AND); :}
        | desc_base:db                      {: RESULT = db; :}
        | eq_chain:ec desc_rel_op:op term:t {: ACSLTerm innerLeft;
                                               if (ec instanceof ACSLSimplePredicate) {
                                                innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) ec).getTerm()).getRight();
                                               } else {
                                                innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) ((ACSLLogicalPredicate) ec).getRight()).getTerm()).
                                                   getRight();
                                               }
                                               ACSLPredicate right = new ACSLSimplePredicate(new ACSLBinaryTerm(innerLeft, t, op));
                                               RESULT = new ACSLLogicalPredicate(ec, right, BinaryOperator.AND); :};
eq_chain ::= eq_chain:ec EQ term:t  {: ACSLTerm innerLeft;
                                       if (ec instanceof ACSLSimplePredicate) {
                                        innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) ec).getTerm()).getRight();
                                       } else {
                                        innerLeft = ((ACSLBinaryTerm) ((ACSLSimplePredicate) ((ACSLLogicalPredicate) ec).getRight()).getTerm()).getRight();
                                       }
                                       ACSLPredicate right = new ACSLSimplePredicate(new ACSLBinaryTerm(innerLeft, t, BinaryOperator.EQ));
                                       RESULT = new ACSLLogicalPredicate(ec, right, BinaryOperator.AND); :}
           | term:t1 EQ term:t2     {: RESULT = new ACSLSimplePredicate(new ACSLBinaryTerm(t1, t2, BinaryOperator.EQ)); :};
asc_base ::= term:t1 asc_rel_op:op term:t2    {: RESULT = new ACSLSimplePredicate(new ACSLBinaryTerm(t1, t2, op)); :};
desc_base ::= term:t1 desc_rel_op:op term:t2  {: RESULT = new ACSLSimplePredicate(new ACSLBinaryTerm(t1, t2, op)); :};
term ::= PRED_START term:t                              {: RESULT = t; :}
        | LITERAL:l                                     {: RESULT = new IntegerLiteral(l); :}
        | STRING_LITERAL:l                              {: RESULT = new StringLiteral(l); :}
        | IDENTIFIER:i                                  {: Identifier identifier = new Identifier(i, parser.getCurrentNode().getFunctionName());
                                                           checkIdentifier(identifier); RESULT = identifier; :}
        | term:t1 LBRACKET term:t2 RBRACKET             {: RESULT = new ArrayAccess(t1, t2); :}
        | unary_op:op term:t                            {: RESULT = new ACSLUnaryTerm(t, op); :}
        | SIZEOF LPAREN term:t RPAREN                   {: RESULT = new ACSLUnaryTerm(t, UnaryOperator.SIZEOF); :}
        | LPAREN PRED_START IDENTIFIER:i RPAREN term:t  {: RESULT = new Cast(new Type(i), t); :}
        | term:t1 arith_op:op term:t2                   {: RESULT = new ACSLBinaryTerm(t1, t2, op); :}
        | term:t1 bit_op:op term:t2                     {: RESULT = new ACSLBinaryTerm(t1, t2, op); :}
        | LPAREN term:t RPAREN                          {: RESULT = t; :}
        | OLD LPAREN term:t RPAREN                      {: RESULT = new At(t, ACSLDefaultLabel.OLD); :}
        | RETVAL                                        {: RESULT = new Result(parser.getCurrentNode().getFunctionName()); :};
log_op ::= AND  {: RESULT = BinaryOperator.AND; :}
        | OR    {: RESULT = BinaryOperator.OR; :}
        | IMP   {: RESULT = BinaryOperator.IMP; :}
        | EQV   {: RESULT = BinaryOperator.EQV; :}
        | XOR   {: RESULT = BinaryOperator.XOR; :};
asc_rel_op ::= LEQ      {: RESULT = BinaryOperator.LEQ; :}
        | LT            {: RESULT = BinaryOperator.LT; :};
desc_rel_op ::= GT      {: RESULT = BinaryOperator.GT; :}
        | GEQ           {: RESULT = BinaryOperator.GEQ; :};
arith_op ::= PLUS       {: RESULT = BinaryOperator.PLUS; :}
        | MINUS         {: RESULT = BinaryOperator.MINUS; :}
        | STAR          {: RESULT = BinaryOperator.TIMES; :}    %prec TIMES
        | DIVIDE        {: RESULT = BinaryOperator.DIVIDE; :}
        | MOD           {: RESULT = BinaryOperator.MOD; :}
        | LSHIFT        {: RESULT = BinaryOperator.LSHIFT; :}
        | RSHIFT        {: RESULT = BinaryOperator.RSHIFT; :};
bit_op ::= AMPERSAND    {: RESULT = BinaryOperator.BAND; :}     %prec BAND
        | BOR           {: RESULT = BinaryOperator.BOR; :}
        | BIMP          {: RESULT = BinaryOperator.BIMP; :}
        | BEQV          {: RESULT = BinaryOperator.BEQV; :}
        | BXOR          {: RESULT = BinaryOperator.BXOR; :};
unary_op ::= BNEG       {: RESULT = UnaryOperator.BNEG; :}
        | PLUS          {: RESULT = UnaryOperator.PLUS; :}      %prec UPLUS
        | MINUS         {: RESULT = UnaryOperator.MINUS; :}     %prec UMINUS
        | STAR          {: RESULT = UnaryOperator.POINTER_DEREF; :}
        | AMPERSAND     {: RESULT = UnaryOperator.ADDRESS_OF; :};